[["problem-set.html", "3 Problem Set 3.1 Data representation 3.2 Data transformation 3.3 Scaling", " 3 Problem Set Designing an interactive data visualization system presents a unique set of challenges which need to be addressed. Some of these have been already mentioned in the Introduction. This section discusses these inherent challenges in greater depth, and begins exploring avenues for possible solutions. 3.1 Data representation There is no data visualization without data. However, all data is not equal. Data can come to use in various shapes and sizes, and this can affect various aspects of the system, including design, memory, and performance. In most data analytic languages, the default data model is that of two-dimensional table or dataframe. Examples include the S3 data.frame class in base R (R Core Team 2024), the tbl_df S3 class in the tibble package (Müller and Wickham 2023), the DataFrame class in the Python pandas package (Pandas Core Team 2024), the DataFrame class in the polars library (Team 2024), or the DataFrame type in the Julia DataFrame.jl package (Bouchet-Valat and Kamiński 2023). In this model, data is organized in columns, which are homogeneous arrays each storing values of the same type. Unlike in a matrix, the columns can be of different types (such as floats, integers, or strings). The dataframe object is then just a dictionary of columns, with some optional metadata, such as row names, column labels, or grouping structure (R Core Team 2024; Bouchet-Valat and Kamiński 2023). However, this column-based organization of data is not universal. For example, in the popular JavaScript data visualization and transformation library D3 (Bostock 2022) ascribes to a row-based data model, such that data is organized as an array of rows, with each row being its own separate dictionary. In a more general programming context, the column-based and row-based data layouts are also known as the struct of arrays (SoA) and array of structs (AoS) data structures, respectively. These data layouts have generally different performance characteristics, and hence why they are also studied in database design (see e.g. Abadi et al. 2013). The SoA layout has (typically) smaller memory footprint and better performance in tight loops that operate on individual columns, thanks to cache locality (Abadi et al. 2013; Acton 2014; Kelley 2023). The AoS layout can have arguably better developer ergonomics and can perform better when retrieving individual records/rows (hence why it is more common in traditional Online Transaction Processing databases, Abadi et al. 2013). 3.2 Data transformation When visualizing data, it is rarely the case that we can just draw the raw data as is. Often, the quantities underlying a specific plot type are instead summaries or aggregates of some kind. Take for example a typical barplot. To draw a barplot, we first need to divide the data into disjoint parts, each corresponding to one bar, and then summarize each part by some metric, usually either the number of cases (count) or the sum of some continuous variable. Similarly, in a histogram, we first need to divide the data into bins and then summarize them (typically by count). Thus, there are two fundamental operations involved in every visualization: splitting the data into parts and computing the summaries on these parts. 3.2.1 Partitioning the data 3.2.1.1 Leave no data out A common-sense guideline that many data visualization experts provide is that a faithful visualization should show the full data and leave nothing out. For instance, Cleveland (1985) argues that axis limits should generally be expanded so that data points at or near these limits are not arbitrarily obscured. Take for example the following two scatterplots: Figure 3.1: Without expanding axes, data points near the limits can become obscured. Left: axis limits match the data limits exactly, and so points at or near the axis limits (top-left and bottom-right corner of the plot) are represented by smaller area and become less salient. Right: by expanding axis limits, we can ensure that all data is represented faithfully. In the left plot, the axis limits match the data limits exactly, whereas in the right plot, they are expanded by a small fraction (5%, ggplot2 default, Wickham 2016). The problem with the left plot is that the data points near the axis limits (top-left and bottom-right corner) are represented only by a fraction of the area: for example, the point in the bottom-right corner lies simultaneously at the limits of the x- and y-axis, and is thus represented only by 1/4 of the area of the points in the center of the plot. The example above shows how data can be obscured visually, even after all of the data points have been included in the plot (rendering all rows of the data set). Clearly then, when complete data is available, leaving information out by arbitrarily dropping rows is even less acceptable. This issue becomes more complicated in the presence of missing or incomplete data, however, there exist ways of dealing with that as well, see e.g. Unwin et al. (1996), Tierney and Cook (2023). Thus, ideally, the visualization should represent a surjective mapping from the space of the geometric objects to the underlying data set, such that there are no cases (rows of the data) that are left out of the figure (Ziemkiewicz and Kosara 2009). 3.2.1.2 Splitting data into disjoint parts In data visualization, a practice so ubiquitous that it is often overlooked is that, in most types of plots, each geometric object represents a disjoint part of the data. That is, each point, bar, line, or polygon typically represents a unique set of cases (rows of the data), with no overlap with the sets represented by the other objects. Why is this the case? The reason for this unconscious “law” might be rooted in the fundamental purpose of data visualization: comparison. When we visualize, we draw our graphics with the ultimate goal of being able to compare our data along a set of visual channels, such as position, length, size, or colour (Bertin 1983; Wilkinson 2012; Franconeri et al. 2021; Wilke 2019). This mirrors the comparisons we make in the real world, where we generally tend to compare distinct entities rather than overlapping ones. To make this idea more concrete, take the following barplot representing vote share of the top three parties in the 2023 New Zealand general election (Electoral Commission New Zealand 2023): Figure 3.2: Geometric objects typically represent disjoint subsets of the data. The plot shows the vote share of the top three parties in the 2023 New Zealand general election, with each bar representing a unique subset of voters. Each bar represents a unique set of voters and thus the subsets of the data represented by the bars are disjoint. Technically, there is no hard and fast rule about having each geometric object represent a disjoint part of the data. For example, we could transform the first bar by taking a union of the votes of National and Labour parties, and represent the same underlying data the following way: Figure 3.3: Hypothetically, there is nothing preventing us from encoding the same information in multiple objects, and showing non-disjoint parts of our data. The plot shows the same underlying data as 3.2, with the leftmost bar representing a union of National and Labour voters. The National votes are thus counted twice, once in the leftmost bar and again in the second left bar, and thus the two bars do not represent mutually disjoint subsets of the data. For a more realistic example of non-disjoint geometric objects, see Figure 3.5. This way of representing the data has several problems, however. First, there is the issue of its suitability towards the main goal of the visualization. Specifically, when visualizing election data such as this one, we are typically interested in judging the relative number of votes each party received. The second barplot makes this comparison difficult. Specifically, in the second barplot, since the National bar represents a subset of the National OR Labour bar, we have to perform additional mental calculation if we want to find out how many votes Labour received and compare the absolute counts directly (Cleveland 1985). Second, we have metadata knowledge (see e.g. Wilkinson 2012; Velleman and Wilkinson 1993) about the data being disjoint - we know that, in the New Zealand parliament electoral system, each voter can only cast one vote for a single party. Finally, there is the issue of duplicating information: in the second barplot, the number of votes the National party received is counted twice, once in the leftmost bar and again in the second-left bar. This goes against the general principle of representing our data in the most parsimonious way (Tufte 2001). Even when our goal is not to compare absolute counts, there are usually better disjoint data visualization techniques available. For example, if we were interested in visualizing the proportion of votes that each party received, we could draw the following plot: Figure 3.4: Even when proportions are of interest, there are usually disjoint data visualization techniques available. The plot shows proportion of vote share of the top three parties in the 2023 New Zealand general election, with each bar segment again representing a unique subset of voters. By stacking the bar segments on top of each other, we can easily compare proportion of the total number of votes while retaining a parsimonious representation of our data. Each bar segments now again represents a unique subset of voters. The example above was fairly clear case of where a non-disjoint representation of the data would be the wrong choice, however, there are also more ambiguous situations. One such situation is when there are multiple attributes of the data which can be simultaneously present or absent for each case. For example, in 2020, a joint referendum was held in New Zealand on the question of legalization of euthanasia and cannabis. The two issues were simultaneously included on the same ballot. The legalization of euthanasia was accepted by the voters, with 65.1% of votes supporting the decision, whereas the legalization of cannabis was rejected, with 50.7% of voters rejecting the decision (Electoral Commission New Zealand 2020). The referendum data can be visualized in the following way: Figure 3.5: Realistic example of a non-disjoint data representation. The plot shows the vote share in the combined 2020 New Zealand referendum on euthanasia and cannabis, where the two issues were simultaneousy presented on the same ballot. The two bars each show (mostly) the same subset of ballot, with each ballot contributing to the height of one segment in each bar. By definition, both bars include votes which were cast by the same voter (ignoring the votes where no preference was given for either issue, Electoral Commission New Zealand 2020). Thus, the sets of voters that the two bars and the four bar segments represent overlap. In general, there is nothing inherently wrong with the plot above. Non-disjoint representations of the data can work well for certain data types such as set-typed data (see e.g. Alsallakh et al. 2014). In the context of static data visualization, plots like these can serve useful roles. However, even here, there is a simple way of representing the same data in a disjoint way - draw two separate plots: Figure 3.6: Non-disjoint data representations can often be recast into disjoint ones. The figure again shows the vote share in the combined 2020 New Zealand referendum on euthanasia and cannabis, however, now each issue is plotted in a separate plot, and thus each geometric object in each plot represents a unique subset of ballots/voters. Why should we care about whether our representations of the data are disjoint or not? I argue that, for many types of plots, disjointness presents a simpler mental model: one geometric object for one unique set of things. If the objects in our plots do not represent disjoint subsets of the data, then we need to keep a model of how these objects are connected, in order to make correct inferences. This may be particularly true for interactive visualization. The natural correspondence between geometric objects and disjoint subsets of the data makes certain interactions more intuitive, and, conversely, having overlap between the cases represented by the objects introduces complications. For example, if a user clicks on a bar in a linked barplot, they might be surprised if parts of the other bars within the same plot get highlighted as well: they wanted to highlight that bar, not the others. Likewise, when querying, if our objects do not represent disjoint subsets of the data, we have to think about what querying means: are we querying the object or the cases corresponding to the object? 3.2.1.3 Plots as partitions In the two preceding sections, I have argued that the plots within our interactive data visualization system should fulfill two fundamental properties: They should represents the full data (surjective mapping) The geometric objects in these plots should represent distinct subsets of the data (disjoint parts) These two properties suggest a fundamental model for our plots: that of a partition. While I have not been able to find explicit references linking geometric objects to partitions, some authors have used the language of partitions. For example, Wilkinson describes a stacked bar as a partitioned bar (Wilkinson 2012, pp 210). 3.2.1.4 Partitions and products In a typical interactive plot, the data will be partitioned across multiple dimensions. Moreover, often, this multi-way partitioning will not form a single flat partition, but instead a hierarchy of partitions. To give a concrete example, suppose we want to draw the following barplot: We start with the following data, which includes a categorical variable (group) that we will plot along the x-axis, a variable representing selection status (selection) that we will color the bar segments with, and a continuous variable that we want to summarize (value): group selection value 1 A 1 10 2 B 1 15 3 B 2 20 4 A 2 10 5 C 2 12 6 A 1 21 7 C 1 15 8 C 2 11 To draw the individual bar segments, we need to find the sum of the value variable across the cases corresponding to each segment. To do this, we first need to split our data into multiple small disjoint subsets according to the product of group and selection variables: # Using paste() here to simulate a product of two factors product_factor &lt;- paste0(df$group, df$selection) split_dfs &lt;- split(df, product_factor) render_tables(split_dfs) group selection value 1 A 1 10 6 A 1 21 group selection value 4 A 2 10 group selection value 2 B 1 15 group selection value 3 B 2 20 group selection value 7 C 1 15 group selection value 5 C 2 12 8 C 2 11 We could then summarize each small data set by summing value: summarized_dfs &lt;- lapply(split_dfs, function(x) { aggregate(value ~ ., data = x, sum) }) render_tables(summarized_dfs) group selection value A 1 31 group selection value A 2 10 group selection value B 1 15 group selection value B 2 20 group selection value C 1 15 group selection value C 2 23 Finally, we need to combine the summaries back together, according to the levels of group, and take the cumulative sum in order to “stack” the segments on top of each other: grouped_dfs &lt;- split(summarized_dfs, sapply(summarized_dfs, function(x) x$group)) stacked_dfs &lt;- lapply(grouped_dfs, function(x) { x &lt;- do.call(rbind, x) x$value &lt;- cumsum(x$value) rownames(x) &lt;- NULL x }) render_tables(stacked_dfs) group selection value A 1 31 A 2 41 group selection value B 1 15 B 2 35 group selection value C 1 15 C 2 38 Now, we have shown how we can compute summary statistics for a stacked barplot using a split-apply-combine pipeline (Wickham 2011). For certain types of plots, a simple strategy like this might work fine. However, the reason why the example above is simple is because we have ignored or side-stepped certain issues. For example, how do we know if we are stacking the summaries in the right order? What if we need to transform the bar segments in some way, such as divide by the height of the parent bar? Once we start dealing with plots like spineplots or spinograms, it becomes clear that a simple “flat” partition structure is not enough. 3.2.1.5 Partitions and hierarchy 3.2.1.6 Partition data structures 3.2.2 Computing summaries After we have partitioned our data, we need a way to summarize each part by a set of summary statistics. Moreover, since the partitions of our data (may) form a hierarchy, we also need a way of referring to parts across the levels of the hierarchy. 3.2.2.1 Reducers Suppose we are summarizing a part consisting of \\(n\\) data points. 3.3 Scaling Information needs to be encoded in visual attributes (Cleveland 1985) References Abadi, Daniel, Peter Boncz, Stavros Harizopoulos, Stratos Idreos, Samuel Madden, et al. 2013. “The Design and Implementation of Modern Column-Oriented Database Systems.” Foundations and Trends in Databases 5 (3): 197–280. Acton, Mike. 2014. “Data-Oriented Design and c++.” Luento. CppCon. https://www.youtube.com/watch?v=rX0ItVEVjHc. Alsallakh, Bilal, Luana Micallef, Wolfgang Aigner, Helwig Hauser, Silvia Miksch, and Peter Rodgers. 2014. “Visualizing Sets and Set-Typed Data: State-of-the-Art and Future Challenges.” Eurographics Conference on Visualization (EuroVis). Bertin, Jacques. 1983. Semiology of Graphics. University of Wisconsin press. Bostock, Mike. 2022. “D3.js - Data-Driven Documents.” https://d3js.org. Bouchet-Valat, Milan, and Bogumił Kamiński. 2023. “DataFrames.jl: Flexible and Fast Tabular Data in Julia.” Journal of Statistical Software 107 (September): 1–32. https://doi.org/10.18637/jss.v107.i04. Cleveland, William S. 1985. The Elements of Graphing Data. Wadsworth Publ. Co. Electoral Commission New Zealand. 2020. “Official Referendum Results Released.” https://elections.nz/media-and-news/2020/official-referendum-results-released. ———. 2023. “E9 Statistics - Overall Results.” https://www.electionresults.govt.nz/electionresults_2023/index.html. Franconeri, Steven L, Lace M Padilla, Priti Shah, Jeffrey M Zacks, and Jessica Hullman. 2021. “The Science of Visual Data Communication: What Works.” Psychological Science in the Public Interest 22 (3): 110–61. Kelley, Andew. 2023. “A Practical Guide to Applying Data Oriented Design (DoD).” Handmade Seattle. https://www.youtube.com/watch?v=IroPQ150F6c. Müller, Kirill, and Hadley Wickham. 2023. Tibble: Simple Data Frames. https://CRAN.R-project.org/package=tibble. Pandas Core Team. 2024. “DataFrame — Pandas 2.2.3 Documentation.” https://pandas.pydata.org/docs/reference/frame.html. R Core Team. 2024. R: A Language and Environment for Statistical Computing. Vienna, Austria: R Foundation for Statistical Computing. https://www.R-project.org/. Team, Polars Core. 2024. “Index - Polars User Guide.” https://docs.pola.rs. Tierney, Nicholas, and Dianne Cook. 2023. “Expanding Tidy Data Principles to Facilitate Missing Data Exploration, Visualization and Assessment of Imputations.” J. Stat. Soft. 105 (February): 1–31. https://doi.org/10.18637/jss.v105.i07. Tufte, Edward R. 2001. The Visual Display of Quantitative Information. Cheshire, Connecticut: Graphics Press LLC. Unwin, Antony, George Hawkins, Heike Hofmann, and Bernd Siegl. 1996. “Interactive Graphics for Data Sets with Missing Values—MANET.” J. Comput. Graph. Stat., June. https://www.tandfonline.com/doi/abs/10.1080/10618600.1996.10474700. Velleman, Paul F, and Leland Wilkinson. 1993. “Nominal, Ordinal, Interval, and Ratio Typologies Are Misleading.” The American Statistician 47 (1): 65–72. Wickham, Hadley. 2011. “The Split-Apply-Combine Strategy for Data Analysis.” Journal of Statistical Software 40: 1–29. ———. 2016. Ggplot2: Elegant Graphics for Data Analysis. Springer-Verlag New York. https://ggplot2.tidyverse.org. Wilke, Claus O. 2019. Fundamentals of Data Visualization: A Primer on Making Informative and Compelling Figures. O’Reilly Media. Wilkinson, Leland. 2012. The Grammar of Graphics. Springer. Ziemkiewicz, Caroline, and Robert Kosara. 2009. “Embedding Information Visualization Within Visual Representation.” In Advances in Information and Intelligent Systems, 307–26. Springer. "],["404.html", "Page not found", " Page not found The page you requested cannot be found (perhaps it was moved or renamed). You may want to try searching to find the page's new location, or use the table of contents to find the page you are looking for. "]]
