[["high-level-design.html", "3 High-level design 3.1 Programming paradigm 3.2 Reactivity 3.3 Row-based or column-based 3.4 Rendering engine", " 3 High-level design “Designing is fundamentally about taking things apart […] in such a way that they can be put back together. Separating things into things that can be composed.” Rich Hickey (2013) This section contains a description of some of the high-level design decisions that went into making the system. The example code chunks in this section are written in both R and TypeScript. While I would prefer to use R for all code examples, due to its tight integration with RMarkdown, some of the concepts are much easier to explain in a language with static typing like TypeScript (particularly, type annotations and interfaces). However, since some examples can also be greatly enhanced by graphical output, I also wanted to use R. So, where graphical output is important, the code examples are written in R, and, where the code itself is the main focus, they are written in TypeScript. I hope this bilingualism is not too confusing. I have tried to use only the core features of each language to make the examples clear. 3.0.1 User profile The profile of average user can also differ significantly, across systems and research areas. For example, some areas of interactive data visualization and HCI make no assumptions about the user’s level of experience or motivation, whereas others assume a highly motivated “expert” user with a sufficient level of domain knowledge (Dimara and Perin 2019). While designing my system, I have attempted to 3.1 Programming paradigm “apex predator of grug is complexity complexity bad say again: complexity very bad you say now: complexity very, very bad given choice between complexity or one on one against t-rex, grug take t-rex: at least grug see t-rex” The Grug Brained Developer, Gross (2024) It is often the case that the same task problem can be tackled in many different ways. Programs differ in how they decompose their core problem, how they represent and manipulate data, how explicit they are in handling low-level details versus relying on abstractions, and so on. These details matter since they can affect the program’s performance, reliability, readability, and maintainability. A wrong choice in one or more of them can result in poorly performing, unmaintainable software. However, there is a root concern that many of the programming details above share: complexity (Booch et al. 2008). Any given problem comes with some level inherent complexity, and, absent of careful thought, more will be piled on by the developer (Moseley and Marks 2006). Without constant effort, software grows out of scope and becomes unmanageable. Preventing this, and coming up with a set of high-level principles for safeguarding against complexity is the job of programming paradigms (Chambers 2014; Jordan et al. 2015; Moseley and Marks 2006; Van Roy et al. 2009). All programming paradigms offer techniques for decomposing code into smaller, more manageable parts, and delineating boundaries between those parts. However, the way they attempt this can differ considerably. Most programming languages are geared towards one specific programming paradigm, and typically support only one or two to a reasonable capacity (Van Roy et al. 2009). Fortunately, this is not the case for either JavaScript/TypeScript or R, since both are multiparadigm programming languages (Chambers 2014; MDN 2024d). Both languages support object-oriented programming, via prototype inheritance in the case of JavaScript (MDN 2024a) and the S3, S4, and R6 systems in the case of R (Wickham 2019), and treat functions as first class citizens, allowing for functional programming style (Chambers 2014; MDN 2024c). Further, as C based languages, both also support classical imperative/procedural programming style, and also provide some utilities for reflective metaprogramming. The flexibility of JavaScript and R had allowed me to experiment with different programming paradigms while developing my interactive data visualization package. I have rewritten the JavaScript side of the package multiple times from scratch, testing out several different programming paradigms and styles in the process. Below, I provide a rough sketch of the paradigms I have sampled, as well as an account of my experience of using each paradigm and some thoughts on its suitability for designing interactive data visualization systems. 3.1.1 Imperative programming Imperative programming is one of the oldest and most classical programming paradigms. It conceptualizes the program as a sequence of discrete steps that manipulate some mutable state (Frame and Coffey 2014). In this way, it closely resembles the way computer programs get executed on the underlying hardware (barring some advanced techniques such as branch prediction and speculative execution, the CPU executes instructions sequentially, see e.g. Parihar 2015; Raghavan, Shachnai, and Yaniv 1998). 3.1.2 Functional programming 3.1.3 Object oriented programming Object oriented programming (OOP) is currently one of the most popular programming paradigms. There are many different interpretation and implementations of OOP, so almost anything one can say about OOP will be wrong in some language. Nevertheless, there are some key ideas which are generally true across most OOP-oriented languages. The core idea of OOP is that programs should be modeled as networks of objects: units which bundle related data and code together, as properties (members) and methods, respectively (Booch et al. 2008). Objects are self-contained, and own a hidden, private state; they expose only a limited public interface and, to communicate, they send each other messages (Meyer 1997). In this way, they behave similarly to networks of biological cells (this was the inspiration for Alan Kay, one of the creators of Smalltalk, who also coined the term “object oriented,” Kay 1996). Each object is an instance of a class, a sort of a blueprint which provides the object with both a type as well as implementation of its methods. Classes can form hierarchies, where child classes (subclasses) inherit properties and methods from parent classes (superclasses). Here’s a typical example one might see in a text-book on OOP (animals, and especially mammals are popular in introductory OOP texts). We start with a base class (superclass) Animal: // Animal.ts type Food = { nutritionalValue: number }; // Abstract classes can declare certain methods without implementing them. // Any subclasses must then implement these methods. export abstract class Animal { x = 0; // Class properties with default values y = 0; nutrition = 100; move(dx: number, dy: number) { // A basic method this.x += dx; this.y += dy; } eat(food: Food) { this.nutrition += food.nutritionalValue; } // Abstract method: subclass must implement this (every Animal has a sound) abstract getSound(): string; } Next, we subclass the Animal class and create a Dog class: import { Animal } from &quot;./Animal.ts&quot; type Meat = { type: `meat`; nutritionalValue: number }; class Dog extends Animal { eat(food: Meat) { // Overwrite superclass method such that it only accepts Meat super.eat(food); // Call superclass method } getSound() { // Implement the abstract method return `Woof!`; } } const dog = new Dog(); dog.move(-10, 10); // Dog inherits all of the methods and properties of Animal dog.eat({ type: `meat`, nutritionalValue: 10 }); // This is fine // dog.eat({ nutritionalValue: 10 }); This would result in a TS compiler error console.log(dog.x, dog.y, dog.nutrition) console.log(dog.getSound()); ## -10 10 110 ## Woof! This is only a very basic example of how OOP can be done in practice. A more detailed explanation is outside of the scope of the present thesis. However, it is important to discuss some of the big ideas of OOP. 3.1.3.1 Encapsulation Encapsulation or information hiding refers to the idea that some (if not most) properties of a class should not be accessible from the outside. Encapsulation is generally seen as one of the most important concepts in OOP, since it allows for continuity: by encapsulating data/functionality, the developer of an OOP system may modify these private properties without affecting the public interface (Meyer 1997). Note that the encapsulation does not mean that the hidden data or implementation has to be entirely invisible to the user, merely that the user should not be able to access the hidden data and rely on it in their application (Meyer 1997). 3.1.3.2 Open-closed principle Modules should be open to extension but close to modification. 3.1.3.3 Polymorphism In other words, only the behavior of the object should matter (Black 2013). 3.1.3.4 Inheritance “programming without inheritance is distinctly not object-oriented; that would merely be programming with abstract data types” (Booch et al. 2008). 3.1.3.5 Domain-driven design One concept that is not unique to OOP but has a strong tradition in it is domain-drive design: the idea that classes and object should model things in the business domain or the real world (Hadar 2013; Meyer 1997). The stated benefit of this strategy is that this makes it easier to discover objects/classes and their relationships, by exploiting the mind’s capacity for thinking about the natural world (Booch et al. 2008; Hadar 2013; Meyer 1997). 3.1.3.6 Criticism of OOP Small interfaces (Meyer 1997). In practice, the small interfaces idea is often not closely adhered to in OOP. It is common for class methods to receive pointers to other objects as arguments, effectively sending all of the information contained in the argument objects and defeating the principle of small interfaces (Will 2016). 3.1.4 Data oriented programming My second remark is that our intellectual powers are rather geared to master static relations and that our powers to visualize processes evolving in time are relatively poorly developed. For that reason we should do (as wise programmers aware of our limitations) our utmost to shorten the conceptual gap between the static program and the dynamic process, to make the correspondence between the program (spread out in text space) and the process (spread out in time) as trivial as possible. Edgar Dijkstra -Dijkstra (1968) Data oriented programming (DOP) and data oriented design (DOD) are two newer programming paradigms that have been slowly gaining a foothold in the recent years. While the terms are sometimes used interchangeably, there are some important differences: DOP is inspired by the Clojure style of programming and focuses more on high-level principles such as the structure and organization of code (Hickey 2011, 2018; Sharvit 2022; Nicolai Parlog 2024), whereas DOD originates in the world of video-game development and tends to be more concerned with low-level optimization details such as memory layout and CPU access patterns (Acton 2014; Bayliss 2022; Kelley 2023; Nikolov 2018; Fabian 2018). Nevertheless, there is a considerable overlap in the general conclusions and directions that the two programming paradigms provide. For this reason, I will discuss both DOP and DOD here simultaneously, within the same section, and refer to both as “DOP” unless explicitly stated otherwise. The core idea of DOP is a data-first perspective. In the DOP view, programs should be viewed as transformations of data, nothing less, nothing more (Acton 2014; Fabian 2018; Sharvit 2022). As a result, every program is composed of two sets of components: stateful data and stateless functions that act on and transform this data (Fabian 2018). In other words, data and code should always be kept separate, such that both can be reasoned about in isolation. Code should live inside modules composed of pure (stateless) functions (Fabian 2018; Sharvit 2022). This strict segregation brings several benefits. The data becomes easy to pass around and serialize, and, since the code is composed of pure functions, it becomes easy to test and mock (Sharvit 2022). Program is split between what is and what does. Data should be represented by plain data structures. These can formed by combining generic components, such as primitives, arrays, and maps/dictionaries/structs (for example JSON; Hickey 2011, 2018; Sharvit 2022). It may even be desirable that the data adheres to the relational model (Codd 1970; Moseley and Marks 2006; Fabian 2018). This does not mean that the data has to actually live inside a relational database, just that its shape should be close to that of normalized relational database tables, with columns represented by generic arrays (Fabian 2018). Data represents just itself - data - and there is no obligation for it to model the real world or any kind of abstract entity. As a result, and we are free to represent data in any way we want, and this can in fact bring significant performance benefits (Acton 2014; Fabian 2018). A typical example of this in DOD is the Structure of Arrays (SoA; aka “parallel arrays” or “columnar format”) data structure (Acton 2014, 2019; Kelley 2023), in which a list of records is stored as a single object, with the records’ properties being stored as homogeneous arrays (this is also how R’s data.frame class is implemented). This type of representation reduces memory footprint and can improve cache line utilization, resulting in faster runtime (Acton 2014; Fabian 2018; Kelley 2023). Another example of idiosyncratic data representation that can lead to improved performance are Entity Component Systems in videogames (Härkönen 2019). Either way, even if performance is not the nubmer one concern, another benefit data representing itself is that it allows us introduce abstraction only gradually, since we can get far by relying on generic data manipulation functions (Fabian 2018; Sharvit 2022). It may seem that many of the DOP principles directly contradict many popular OOP principles, specifically encapsulation, inheritance, polymorphism, and domain driven design. However, many of these principles can either be reconciled with DOP, or DOP in fact provides better alternatives. Below, I go over these principles and provide code examples that further illustrate how DOP works. 3.1.4.0.1 Encapsulation When it comes to encapsulation in DOP, we have to differentiate between encapsulating data and encapsulating code. Encapsulating code is easy in DOP - we can simply not export certain functions from the code modules. We are then free to modify the signature of these functions without affecting the public interface (Fabian 2018). Encapsulating data may require a bit more work. Depending on the language, generic data structures may not have property access modifiers (although there does seem to be a trend in recent languages to support property access modifiers more generically, see e.g. Rust Foundation 2024; Zig Software Foundation 2024). For instance, in JavaScript, private properties can only be declared as part of a class declaration (MDN 2024c). However, in most languages, it is still possible to use other language features and metaprogramming to achieve data encapsulation - for example, in JavaScript, we can use the Proxy class to emulate private property access (see Appendix). Thus, encapsulation of data is certainly possible in DOP. However, a question still remains whether it is a good idea. While in OOP, encapsulation is generally seen as a net positive, in DOP it is thought to come with trade-offs. It does provide an additional layer of security, however, it also makes systems more complex and harder to debug (Fabian 2018; Sharvit 2022). And, even with full encapsulation, users may still come to rely on hidden features of the system (Fabian 2018). Ultimately, it is necessary to weigh the pros and cons of encapsulating data within the context of the specific use-case. Some languages also have features which allow for a weak form encapsulation which is compatible with DOP. In JavaScript, this can be implemented by using symbol keys for object properties (MDN 2024b). Symbols are builtin primitive in JavaScript and are guaranteed to be unique. If we assign a property to an object using an unexported symbol as the key, the user will still be able to inspect the object and see the property, however, they will not be able to access it without using reflection. This is actually in line with the data hiding concept as laid out by Meyer (1997). I actually found this form a weak encapsulation a good fit for plotscape. For example, here is how I implemented the Meta mixin which allows use to store arbitrary metadata on objects: // Meta.ts const METADATA = Symbol(&quot;metadata&quot;); type METADATA = typeof METADATA; export interface Meta&lt;T extends Record&lt;string, any&gt;&gt; { [METADATA]: T; } export namespace Meta { export function of&lt;T extends Object&gt;(object: T) { return { ...object, [METADATA]: {} }; } export function get&lt;T extends Meta&gt;(object: T, key: keyof T[METADATA]) { return object[METADATA][key]; } export function set&lt;T extends Meta, K extends keyof T[METADATA]&gt;( object: T, key: K, value: T[METADATA][K] ) { object[METADATA][key] = value; } } Now we can import the module and use it to add secret metadata to arbitrary data objects: import { Meta } from &quot;./Meta.ts&quot; interface User extends Meta&lt;{ id: number }&gt; { name: string; } const user: User = Meta.of({ name: &quot;Adam&quot; }); Meta.set(user, `id`, 1337); console.log(user) console.log(Meta.get(user, `id`)); ## { ## name: &quot;Adam&quot;, ## [Symbol(metadata)]: { ## id: 1337, ## }, ## } ## 1337 We can now use the Meta module internally, and, if we do not export the module or the METADATA symbol, then the user will not be able to access those properties easily. The user can still inspect the object and see the associated metadata, however, they cannot access it without the symbol. They may still be able to retrieve the symbol using the via the Reflect.ownKeys and Object.getOwnPropertySymbols functions, and so this method does not provide a strong form of encapsulation (MDN 2024b). Arguably, however, if the user goes as far as to retrieve the symbol using reflection, and, assuming we are not storing any sensitive data (which is not usually the case in data visualization systems), it may be reasonable to allow them to access these “private” properties and suffer the consequences. 3.1.4.0.2 Inheritance In OOP, the primary mechanism for code reuse is inheritance. In DOP, since data is generic and separate from behavior, we can call functions from any module as long as the data we provide it as arguments adheres to the module’s interface. This makes code reuse trivial. For example, here’s a simplified version of the Reactive interface (Observer pattern) from plotscape: const LISTENERS = Symbol(`listeners`); // A unique symbol, to avoid namespace clashes type Dict = Record&lt;string, any&gt;; // Generic dictionary type type Callback = (data: Dict) =&gt; void; // Generic callback function type interface Reactive { [LISTENERS]: Record&lt;string, Callback[]&gt;; } namespace Reactive { export function of&lt;T extends Object&gt;(object: T): T &amp; Reactive { return { ...object, [LISTENERS]: {} }; } export function listen(object: Reactive, event: string, cb: Callback) { if (!object[LISTENERS][event]) object[LISTENERS][event] = []; object[LISTENERS][event].push(cb); } export function dispatch(object: Reactive, event: string, data: Dict) { for (const cb of object[LISTENERS][event] ?? []) cb(data); } } interface Dog extends Reactive { name: string } namespace Dog { export function of(name: string) { return Reactive.of({ name }) } } const dog = Dog.of(`Terry`) Reactive.listen(dog, `car goes by`, () =&gt; console.log(`Woof!`)) Reactive.dispatch(dog, `car goes by`) ## Woof! 3.2 Reactivity 3.3 Row-based or column-based 3.4 Rendering engine References Acton, Mike. 2014. “Data-Oriented Design and c++.” Luento. CppCon. https://www.youtube.com/watch?v=rX0ItVEVjHc. ———. 2019. “Building a Data-Oriented Future.” WeAreDevelopers. https://www.youtube.com/watch?v=u8B3j8rqYMw. Bayliss, Jessica D. 2022. “The Data-Oriented Design Process for Game Development.” Computer 55 (5): 31–38. Black, Andrew P. 2013. “Object-Oriented Programming: Some History, and Challenges for the Next Fifty Years.” Information and Computation 231: 3–20. Booch, Grady, Robert A Maksimchuk, Michael W Engle, Bobbi J Young, Jim Connallen, and Kelli A Houston. 2008. “Object-Oriented Analysis and Design with Applications.” ACM SIGSOFT Software Engineering Notes 33 (5): 29–29. Chambers, John M. 2014. “Object-Oriented Programming, Functional Programming and r.” Statistical Science 29 (2): 167–80. https://doi.org/10.1214/13-STS452. Codd, Edgar F. 1970. “A Relational Model of Data for Large Shared Data Banks.” Communications of the ACM 13 (6): 377–87. Dijkstra, Edsger W. 1968. “Letters to the Editor: Go to Statement Considered Harmful.” Communications of the ACM 11 (3): 147–48. Dimara, Evanthia, and Charles Perin. 2019. “What Is Interaction for Data Visualization?” IEEE Transactions on Visualization and Computer Graphics 26 (1): 119–29. Fabian, Richard. 2018. “Data-Oriented Design.” Framework 21: 1–7. Frame, Scott, and John W Coffey. 2014. “A Comparison of Functional and Imperative Programming Techniques for Mathematical Software Development.” Journal of Systemics, Cybernetics and Informatics 12 (2): 1–10. Gross, Carson. 2024. “The Grug Brained Developer.” https://grugbrain.dev. Hadar, Irit. 2013. “When Intuition and Logic Clash: The Case of the Object-Oriented Paradigm.” Science of Computer Programming 78 (9): 1407–26. Härkönen, Toni. 2019. “Advantages and Implementation of Entity-Component-Systems.” Hickey, Rich. 2011. “Simple Made Easy.” Strange Loop. https://www.youtube.com/watch?v=LKtk3HCgTa8. ———. 2013. “Design, Composition, and Performance.” ETE Conference. https://www.youtube.com/watch?v=QCwqnjxqfmY. ———. 2018. “Maybe Not.” Clojure Conj. https://www.youtube.com/watch?v=YR5WdGrpoug. Jordan, Howell, Goetz Botterweck, John Noll, Andrew Butterfield, and Rem Collier. 2015. “A Feature Model of Actor, Agent, Functional, Object, and Procedural Programming Languages.” Science of Computer Programming 98: 120–39. Kay, Alan C. 1996. “The Early History of Smalltalk.” In History of Programming Languages—II, 511–98. Kelley, Andew. 2023. “A Practical Guide to Applying Data Oriented Design (DoD).” Handmade Seattle. https://www.youtube.com/watch?v=IroPQ150F6c. MDN. 2024a. “Classes - JavaScript \\(\\vert\\) MDN.” MDN Web Docs. https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Classes. ———. 2024b. “Symbol - JavaScript \\(\\vert\\) MDN.” MDN Web Docs. https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Symbol. ———. 2024c. “Functions - JavaScript \\(\\vert\\) MDN.” MDN Web Docs. https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Functions. ———. 2024d. “JavaScript Language Overview - JavaScript \\(\\vert\\) MDN.” MDN Web Docs. https://developer.mozilla.org/en-US/docs/Web/JavaScript/Language_overview. Meyer, Bertrand. 1997. Object-Oriented Software Construction. Vol. 2. Prentice hall Englewood Cliffs. Moseley, Ben, and Peter Marks. 2006. “Out of the Tar Pit.” Software Practice Advancement (SPA) 2006. Nicolai Parlog. 2024. “Data Oriented Programming in Java 21.” Devoxx. https://www.youtube.com/watch?v=8FRU_aGY4mY. Nikolov, Stoyan. 2018. “OOP Is Dead, Long Live Data-Oriented Design.” CppCon. https://www.youtube.com/watch?v=yy8jQgmhbAU&amp;t=2810s. Parihar, Raj. 2015. “Branch Prediction Techniques and Optimizations.” University of Rochester, NY, USA. Raghavan, P., H. Shachnai, and M. Yaniv. 1998. “Dynamic Schemes for Speculative Execution of Code.” In Proceedings. Sixth International Symposium on Modeling, Analysis and Simulation of Computer and Telecommunication Systems (Cat. No.98TB100247), 24. IEEE. https://doi.org/10.1109/MASCOT.1998.693711. Rust Foundation. 2024. “Pub - Rust.” https://doc.rust-lang.org/std/keyword.pub.html. Sharvit, Yehonathan. 2022. Data-Oriented Programming: Reduce Software Complexity. Simon; Schuster. Van Roy, Peter et al. 2009. “Programming Paradigms for Dummies: What Every Programmer Should Know.” New Computational Paradigms for Computer Music 104: 616–21. Wickham, Hadley. 2019. Advanced r. Chapman; Hall/CRC. Will, Brian. 2016. “Object-Oriented Programming Is Bad.” Youtube. https://www.youtube.com/watch?v=QM1iUe6IofM. Zig Software Foundation. 2024. “Documentation - the Zig Programming Language.” https://ziglang.org/documentation/master. "],["404.html", "Page not found", " Page not found The page you requested cannot be found (perhaps it was moved or renamed). You may want to try searching to find the page's new location, or use the table of contents to find the page you are looking for. "]]
