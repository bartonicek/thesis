<!DOCTYPE html>
<html lang="" xml:lang="">
<head>

  <meta charset="utf-8" />
  <meta http-equiv="X-UA-Compatible" content="IE=edge" />
  <title>4 Challenges | The Fabric of Interactive Visualization</title>
  <meta name="description" content="4 Challenges | The Fabric of Interactive Visualization" />
  <meta name="generator" content="bookdown 0.43 and GitBook 2.6.7" />

  <meta property="og:title" content="4 Challenges | The Fabric of Interactive Visualization" />
  <meta property="og:type" content="book" />
  
  
  

  <meta name="twitter:card" content="summary" />
  <meta name="twitter:title" content="4 Challenges | The Fabric of Interactive Visualization" />
  
  
  

<meta name="author" content="Adam Bartonicek" />



  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <meta name="apple-mobile-web-app-capable" content="yes" />
  <meta name="apple-mobile-web-app-status-bar-style" content="black" />
  
  
<link rel="prev" href="background.html"/>
<link rel="next" href="goals.html"/>
<script src="libs/jquery-3.6.0/jquery-3.6.0.min.js"></script>
<script src="https://cdn.jsdelivr.net/npm/fuse.js@6.4.6/dist/fuse.min.js"></script>
<link href="libs/gitbook-2.6.7/css/style.css" rel="stylesheet" />
<link href="libs/gitbook-2.6.7/css/plugin-table.css" rel="stylesheet" />
<link href="libs/gitbook-2.6.7/css/plugin-bookdown.css" rel="stylesheet" />
<link href="libs/gitbook-2.6.7/css/plugin-highlight.css" rel="stylesheet" />
<link href="libs/gitbook-2.6.7/css/plugin-search.css" rel="stylesheet" />
<link href="libs/gitbook-2.6.7/css/plugin-fontsettings.css" rel="stylesheet" />
<link href="libs/gitbook-2.6.7/css/plugin-clipboard.css" rel="stylesheet" />








<link href="libs/anchor-sections-1.1.0/anchor-sections.css" rel="stylesheet" />
<link href="libs/anchor-sections-1.1.0/anchor-sections-hash.css" rel="stylesheet" />
<script src="libs/anchor-sections-1.1.0/anchor-sections.js"></script>


<style type="text/css">
pre > code.sourceCode { white-space: pre; position: relative; }
pre > code.sourceCode > span { line-height: 1.25; }
pre > code.sourceCode > span:empty { height: 1.2em; }
.sourceCode { overflow: visible; }
code.sourceCode > span { color: inherit; text-decoration: inherit; }
pre.sourceCode { margin: 0; }
@media screen {
div.sourceCode { overflow: auto; }
}
@media print {
pre > code.sourceCode { white-space: pre-wrap; }
pre > code.sourceCode > span { display: inline-block; text-indent: -5em; padding-left: 5em; }
}
pre.numberSource code
  { counter-reset: source-line 0; }
pre.numberSource code > span
  { position: relative; left: -4em; counter-increment: source-line; }
pre.numberSource code > span > a:first-child::before
  { content: counter(source-line);
    position: relative; left: -1em; text-align: right; vertical-align: baseline;
    border: none; display: inline-block;
    -webkit-touch-callout: none; -webkit-user-select: none;
    -khtml-user-select: none; -moz-user-select: none;
    -ms-user-select: none; user-select: none;
    padding: 0 4px; width: 4em;
    color: #aaaaaa;
  }
pre.numberSource { margin-left: 3em; border-left: 1px solid #aaaaaa;  padding-left: 4px; }
div.sourceCode
  {   }
@media screen {
pre > code.sourceCode > span > a:first-child::before { text-decoration: underline; }
}
code span.al { color: #ff0000; font-weight: bold; } /* Alert */
code span.an { color: #60a0b0; font-weight: bold; font-style: italic; } /* Annotation */
code span.at { color: #7d9029; } /* Attribute */
code span.bn { color: #40a070; } /* BaseN */
code span.bu { color: #008000; } /* BuiltIn */
code span.cf { color: #007020; font-weight: bold; } /* ControlFlow */
code span.ch { color: #4070a0; } /* Char */
code span.cn { color: #880000; } /* Constant */
code span.co { color: #60a0b0; font-style: italic; } /* Comment */
code span.cv { color: #60a0b0; font-weight: bold; font-style: italic; } /* CommentVar */
code span.do { color: #ba2121; font-style: italic; } /* Documentation */
code span.dt { color: #902000; } /* DataType */
code span.dv { color: #40a070; } /* DecVal */
code span.er { color: #ff0000; font-weight: bold; } /* Error */
code span.ex { } /* Extension */
code span.fl { color: #40a070; } /* Float */
code span.fu { color: #06287e; } /* Function */
code span.im { color: #008000; font-weight: bold; } /* Import */
code span.in { color: #60a0b0; font-weight: bold; font-style: italic; } /* Information */
code span.kw { color: #007020; font-weight: bold; } /* Keyword */
code span.op { color: #666666; } /* Operator */
code span.ot { color: #007020; } /* Other */
code span.pp { color: #bc7a00; } /* Preprocessor */
code span.sc { color: #4070a0; } /* SpecialChar */
code span.ss { color: #bb6688; } /* SpecialString */
code span.st { color: #4070a0; } /* String */
code span.va { color: #19177c; } /* Variable */
code span.vs { color: #4070a0; } /* VerbatimString */
code span.wa { color: #60a0b0; font-weight: bold; font-style: italic; } /* Warning */
</style>

<style type="text/css">
  
  div.hanging-indent{margin-left: 1.5em; text-indent: -1.5em;}
</style>
<style type="text/css">
/* Used with Pandoc 2.11+ new --citeproc when CSL is used */
div.csl-bib-body { }
div.csl-entry {
  clear: both;
  margin-bottom: 0em;
}
.hanging div.csl-entry {
  margin-left:2em;
  text-indent:-2em;
}
div.csl-left-margin {
  min-width:2em;
  float:left;
}
div.csl-right-inline {
  margin-left:2em;
  padding-left:1em;
}
div.csl-indent {
  margin-left: 2em;
}
</style>

<link rel="stylesheet" href="styles.css" type="text/css" />
</head>

<body>



  <div class="book without-animation with-summary font-size-2 font-family-1" data-basepath=".">

    <div class="book-summary">
      <nav role="navigation">

<ul class="summary">
<li class="chapter" data-level="1" data-path="index.html"><a href="index.html"><i class="fa fa-check"></i><b>1</b> Abstract</a></li>
<li class="chapter" data-level="2" data-path="introduction.html"><a href="introduction.html"><i class="fa fa-check"></i><b>2</b> Introduction</a></li>
<li class="chapter" data-level="3" data-path="background.html"><a href="background.html"><i class="fa fa-check"></i><b>3</b> Background</a>
<ul>
<li class="chapter" data-level="3.1" data-path="background.html"><a href="background.html#brief-history"><i class="fa fa-check"></i><b>3.1</b> Brief history of interactive data visualization</a>
<ul>
<li class="chapter" data-level="3.1.1" data-path="background.html"><a href="background.html#static-visualization"><i class="fa fa-check"></i><b>3.1.1</b> Static data visualization: From ancient times to the space age</a></li>
<li class="chapter" data-level="3.1.2" data-path="background.html"><a href="background.html#early-interactive"><i class="fa fa-check"></i><b>3.1.2</b> Early interactive data visualization: By statisticians for statisticians</a></li>
<li class="chapter" data-level="3.1.3" data-path="background.html"><a href="background.html#web-based"><i class="fa fa-check"></i><b>3.1.3</b> Interactive data visualization and the internet: Web-based interactivity</a></li>
</ul></li>
<li class="chapter" data-level="3.2" data-path="background.html"><a href="background.html#what-is-interactive-visualization"><i class="fa fa-check"></i><b>3.2</b> What even is interactive data visualization?</a>
<ul>
<li class="chapter" data-level="3.2.1" data-path="background.html"><a href="background.html#interactive-interacting"><i class="fa fa-check"></i><b>3.2.1</b> Interactive vs. interacting with</a></li>
<li class="chapter" data-level="3.2.2" data-path="background.html"><a href="background.html#interactive-enough"><i class="fa fa-check"></i><b>3.2.2</b> Interactive <em>enough</em>?</a></li>
<li class="chapter" data-level="3.2.3" data-path="background.html"><a href="background.html#complexity-of-features"><i class="fa fa-check"></i><b>3.2.3</b> Complexity of interactive features</a></li>
<li class="chapter" data-level="3.2.4" data-path="background.html"><a href="background.html#working-definition"><i class="fa fa-check"></i><b>3.2.4</b> Working definition</a></li>
<li class="chapter" data-level="3.2.5" data-path="background.html"><a href="background.html#common-features"><i class="fa fa-check"></i><b>3.2.5</b> Common interactive features</a></li>
</ul></li>
<li class="chapter" data-level="3.3" data-path="background.html"><a href="background.html#overview-of-broader-data-visualization-topics"><i class="fa fa-check"></i><b>3.3</b> Overview of broader data visualization topics</a>
<ul>
<li class="chapter" data-level="3.3.1" data-path="background.html"><a href="background.html#visualization-goals"><i class="fa fa-check"></i><b>3.3.1</b> Visualization goals</a></li>
<li class="chapter" data-level="3.3.2" data-path="background.html"><a href="background.html#visual-perception"><i class="fa fa-check"></i><b>3.3.2</b> Visual perception</a></li>
<li class="chapter" data-level="3.3.3" data-path="background.html"><a href="background.html#scales-measurement"><i class="fa fa-check"></i><b>3.3.3</b> Scales and measurement</a></li>
<li class="chapter" data-level="3.3.4" data-path="background.html"><a href="background.html#graphics-formats"><i class="fa fa-check"></i><b>3.3.4</b> Graphics formats</a></li>
</ul></li>
<li class="chapter" data-level="3.4" data-path="background.html"><a href="background.html#summary"><i class="fa fa-check"></i><b>3.4</b> Summary</a></li>
</ul></li>
<li class="chapter" data-level="4" data-path="problems.html"><a href="problems.html"><i class="fa fa-check"></i><b>4</b> Challenges</a>
<ul>
<li class="chapter" data-level="4.1" data-path="problems.html"><a href="problems.html#the-structure-of-this-chapter-data-visualization-pipeline"><i class="fa fa-check"></i><b>4.1</b> The structure of this chapter: Data visualization pipeline</a></li>
<li class="chapter" data-level="4.2" data-path="problems.html"><a href="problems.html#partitioning"><i class="fa fa-check"></i><b>4.2</b> Partitioning</a>
<ul>
<li class="chapter" data-level="4.2.1" data-path="problems.html"><a href="problems.html#show-all-data"><i class="fa fa-check"></i><b>4.2.1</b> Showing the full data</a></li>
<li class="chapter" data-level="4.2.2" data-path="problems.html"><a href="problems.html#comparison-disjointness"><i class="fa fa-check"></i><b>4.2.2</b> Comparison and disjointness</a></li>
<li class="chapter" data-level="4.2.3" data-path="problems.html"><a href="problems.html#plots-as-partitions"><i class="fa fa-check"></i><b>4.2.3</b> Plots as partitions</a></li>
<li class="chapter" data-level="4.2.4" data-path="problems.html"><a href="problems.html#hierarchy"><i class="fa fa-check"></i><b>4.2.4</b> Partitions, hierarchy, and preorders</a></li>
</ul></li>
<li class="chapter" data-level="4.3" data-path="problems.html"><a href="problems.html#aggregation"><i class="fa fa-check"></i><b>4.3</b> Aggregation</a>
<ul>
<li class="chapter" data-level="4.3.1" data-path="problems.html"><a href="problems.html#the-relationship-between-graphics-and-statistics"><i class="fa fa-check"></i><b>4.3.1</b> The relationship between graphics and statistics</a></li>
<li class="chapter" data-level="4.3.2" data-path="problems.html"><a href="problems.html#aggregation-category-theory"><i class="fa fa-check"></i><b>4.3.2</b> Stackable summaries: A brief journey into Category Theory</a></li>
</ul></li>
<li class="chapter" data-level="4.4" data-path="problems.html"><a href="problems.html#scaling"><i class="fa fa-check"></i><b>4.4</b> Scaling and encoding</a></li>
<li class="chapter" data-level="4.5" data-path="problems.html"><a href="problems.html#rendering"><i class="fa fa-check"></i><b>4.5</b> Rendering</a>
<ul>
<li class="chapter" data-level="4.5.1" data-path="problems.html"><a href="problems.html#frames"><i class="fa fa-check"></i><b>4.5.1</b> Frames</a></li>
<li class="chapter" data-level="4.5.2" data-path="problems.html"><a href="problems.html#geoms"><i class="fa fa-check"></i><b>4.5.2</b> Geoms</a></li>
<li class="chapter" data-level="4.5.3" data-path="problems.html"><a href="problems.html#auxiliary-elements"><i class="fa fa-check"></i><b>4.5.3</b> Auxiliary graphical elements</a></li>
</ul></li>
<li class="chapter" data-level="4.6" data-path="problems.html"><a href="problems.html#summary-1"><i class="fa fa-check"></i><b>4.6</b> Summary</a></li>
</ul></li>
<li class="chapter" data-level="5" data-path="goals.html"><a href="goals.html"><i class="fa fa-check"></i><b>5</b> Goals</a>
<ul>
<li class="chapter" data-level="5.1" data-path="goals.html"><a href="goals.html#user-profile"><i class="fa fa-check"></i><b>5.1</b> User profile</a></li>
<li class="chapter" data-level="5.2" data-path="goals.html"><a href="goals.html#programming-interface"><i class="fa fa-check"></i><b>5.2</b> Programming interface</a></li>
<li class="chapter" data-level="5.3" data-path="goals.html"><a href="goals.html#user-interface"><i class="fa fa-check"></i><b>5.3</b> User interface</a></li>
<li class="chapter" data-level="5.4" data-path="goals.html"><a href="goals.html#interactive-features"><i class="fa fa-check"></i><b>5.4</b> Interactive features</a></li>
<li class="chapter" data-level="5.5" data-path="goals.html"><a href="goals.html#summary-2"><i class="fa fa-check"></i><b>5.5</b> Summary</a></li>
</ul></li>
<li class="chapter" data-level="6" data-path="system.html"><a href="system.html"><i class="fa fa-check"></i><b>6</b> System description</a>
<ul>
<li class="chapter" data-level="6.1" data-path="system.html"><a href="system.html#core-requirements"><i class="fa fa-check"></i><b>6.1</b> Core requirements</a></li>
<li class="chapter" data-level="6.2" data-path="system.html"><a href="system.html#high-level-api"><i class="fa fa-check"></i><b>6.2</b> High-level API (<code>plotscaper</code>)</a>
<ul>
<li class="chapter" data-level="6.2.1" data-path="system.html"><a href="system.html#api-design"><i class="fa fa-check"></i><b>6.2.1</b> API design</a></li>
<li class="chapter" data-level="6.2.2" data-path="system.html"><a href="system.html#basic-example"><i class="fa fa-check"></i><b>6.2.2</b> Basic example</a></li>
<li class="chapter" data-level="6.2.3" data-path="system.html"><a href="system.html#scene-and-schema"><i class="fa fa-check"></i><b>6.2.3</b> The scene and the schema</a></li>
<li class="chapter" data-level="6.2.4" data-path="system.html"><a href="system.html#client-server"><i class="fa fa-check"></i><b>6.2.4</b> Client-server communication</a></li>
<li class="chapter" data-level="6.2.5" data-path="system.html"><a href="system.html#html-embedding"><i class="fa fa-check"></i><b>6.2.5</b> HTML embedding</a></li>
</ul></li>
<li class="chapter" data-level="6.3" data-path="system.html"><a href="system.html#overview-of-the-system-model"><i class="fa fa-check"></i><b>6.3</b> Overview of the system model</a>
<ul>
<li class="chapter" data-level="6.3.1" data-path="system.html"><a href="system.html#model-pipeline"><i class="fa fa-check"></i><b>6.3.1</b> The interactive data visualization pipeline</a></li>
<li class="chapter" data-level="6.3.2" data-path="system.html"><a href="system.html#scene-model"><i class="fa fa-check"></i><b>6.3.2</b> Scene model</a></li>
<li class="chapter" data-level="6.3.3" data-path="system.html"><a href="system.html#plot-model"><i class="fa fa-check"></i><b>6.3.3</b> Plot model</a></li>
<li class="chapter" data-level="6.3.4" data-path="system.html"><a href="system.html#hierarchical-data-summaries-computation-transformation-and-encoding"><i class="fa fa-check"></i><b>6.3.4</b> Hierarchical data summaries: computation, transformation, and encoding</a></li>
</ul></li>
<li class="chapter" data-level="6.4" data-path="system.html"><a href="system.html#low-level-implementation"><i class="fa fa-check"></i><b>6.4</b> Low-level implementation (<code>plotscape</code>)</a>
<ul>
<li class="chapter" data-level="6.4.1" data-path="system.html"><a href="system.html#programming-paradigm"><i class="fa fa-check"></i><b>6.4.1</b> Programming paradigm</a></li>
<li class="chapter" data-level="6.4.2" data-path="system.html"><a href="system.html#row-column"><i class="fa fa-check"></i><b>6.4.2</b> Data representation: Row-oriented vs. column-oriented</a></li>
<li class="chapter" data-level="6.4.3" data-path="system.html"><a href="system.html#reactivity"><i class="fa fa-check"></i><b>6.4.3</b> Reactivity</a></li>
<li class="chapter" data-level="6.4.4" data-path="system.html"><a href="system.html#components"><i class="fa fa-check"></i><b>6.4.4</b> System components</a></li>
</ul></li>
</ul></li>
<li class="chapter" data-level="7" data-path="applied-example.html"><a href="applied-example.html"><i class="fa fa-check"></i><b>7</b> Applied example</a>
<ul>
<li class="chapter" data-level="7.0.1" data-path="applied-example.html"><a href="applied-example.html#about-the-data-set"><i class="fa fa-check"></i><b>7.0.1</b> About the data set</a></li>
<li class="chapter" data-level="7.0.2" data-path="applied-example.html"><a href="applied-example.html#interactive-exploration"><i class="fa fa-check"></i><b>7.0.2</b> Interactive exploration</a></li>
<li class="chapter" data-level="7.1" data-path="applied-example.html"><a href="applied-example.html#summary-3"><i class="fa fa-check"></i><b>7.1</b> Summary</a></li>
</ul></li>
<li class="chapter" data-level="8" data-path="discussion.html"><a href="discussion.html"><i class="fa fa-check"></i><b>8</b> Discussion</a>
<ul>
<li class="chapter" data-level="8.1" data-path="discussion.html"><a href="discussion.html#theoretical-model"><i class="fa fa-check"></i><b>8.1</b> Theoretical model</a>
<ul>
<li class="chapter" data-level="8.1.1" data-path="discussion.html"><a href="discussion.html#why-the-model-is-necessary"><i class="fa fa-check"></i><b>8.1.1</b> Why the model is necessary</a></li>
<li class="chapter" data-level="8.1.2" data-path="discussion.html"><a href="discussion.html#disjointness"><i class="fa fa-check"></i><b>8.1.2</b> Disjointness</a></li>
<li class="chapter" data-level="8.1.3" data-path="discussion.html"><a href="discussion.html#associativity-unitality"><i class="fa fa-check"></i><b>8.1.3</b> Associativity and unitality</a></li>
<li class="chapter" data-level="8.1.4" data-path="discussion.html"><a href="discussion.html#discussion-groups-inverses"><i class="fa fa-check"></i><b>8.1.4</b> Groups and inverses</a></li>
<li class="chapter" data-level="8.1.5" data-path="discussion.html"><a href="discussion.html#additional-properties-monotonicity-commutativity-and-others"><i class="fa fa-check"></i><b>8.1.5</b> Additional properties: Monotonicity, commutativity, and others</a></li>
<li class="chapter" data-level="8.1.6" data-path="discussion.html"><a href="discussion.html#model-constraints"><i class="fa fa-check"></i><b>8.1.6</b> Model constraints</a></li>
<li class="chapter" data-level="8.1.7" data-path="discussion.html"><a href="discussion.html#potential-future-directions"><i class="fa fa-check"></i><b>8.1.7</b> Potential future directions</a></li>
</ul></li>
<li class="chapter" data-level="8.2" data-path="discussion.html"><a href="discussion.html#delivered-software-plotscaper"><i class="fa fa-check"></i><b>8.2</b> Delivered software (<code>plotscaper</code>)</a>
<ul>
<li class="chapter" data-level="8.2.1" data-path="discussion.html"><a href="discussion.html#scope-and-features"><i class="fa fa-check"></i><b>8.2.1</b> Scope and features</a></li>
<li class="chapter" data-level="8.2.2" data-path="discussion.html"><a href="discussion.html#declarative-schemas"><i class="fa fa-check"></i><b>8.2.2</b> Declarative schemas and extensibility</a></li>
<li class="chapter" data-level="8.2.3" data-path="discussion.html"><a href="discussion.html#performance"><i class="fa fa-check"></i><b>8.2.3</b> Performance</a></li>
</ul></li>
</ul></li>
<li class="chapter" data-level="9" data-path="conclusion.html"><a href="conclusion.html"><i class="fa fa-check"></i><b>9</b> Conclusion</a></li>
<li class="chapter" data-level="10" data-path="appendix-glossary.html"><a href="appendix-glossary.html"><i class="fa fa-check"></i><b>10</b> Appendix: Glossary</a></li>
<li class="chapter" data-level="11" data-path="math.html"><a href="math.html"><i class="fa fa-check"></i><b>11</b> Appendix: Mathematical theory</a></li>
<li class="chapter" data-level="12" data-path="references.html"><a href="references.html"><i class="fa fa-check"></i><b>12</b> References</a></li>
</ul>

      </nav>
    </div>

    <div class="book-body">
      <div class="body-inner">
        <div class="book-header" role="navigation">
          <h1>
            <i class="fa fa-circle-o-notch fa-spin"></i><a href="./">The Fabric of Interactive Visualization</a>
          </h1>
        </div>

        <div class="page-wrapper" tabindex="-1" role="main">
          <div class="page-inner">

            <section class="normal" id="section-">
<div id="problems" class="section level1 hasAnchor" number="4">
<h1><span class="header-section-number">4</span> Challenges<a href="problems.html#problems" class="anchor-section" aria-label="Anchor link to header"></a></h1>
<p>Designing an interactive data visualization system presents a unique set of challenges. Some of these have been already touched on in the Section <a href="background.html#background">3</a>. This section homes in on these inherent challenges, discusses them in greater depth, and begins exploring avenues for possible solutions.</p>
<div id="the-structure-of-this-chapter-data-visualization-pipeline" class="section level2 hasAnchor" number="4.1">
<h2><span class="header-section-number">4.1</span> The structure of this chapter: Data visualization pipeline<a href="problems.html#the-structure-of-this-chapter-data-visualization-pipeline" class="anchor-section" aria-label="Anchor link to header"></a></h2>
<p>When creating visualizations, be they static or interactive, our ultimate goal is to render geometric objects that will represent our data in some way. However, it is rarely the case that we can plot the raw data directly, as is. Instead, before the data can be rendered, it often has to pass through several distinct transformation steps or stages. Together, these steps form a data visualization pipeline <span class="citation">(see e.g. <a href="#ref-chi2000">Chi 2000</a>; <a href="#ref-wickham2009">Wickham et al. 2009</a>; <a href="#ref-wu2024">Wu and Chang 2024</a>)</span>. Each of these steps come with its inherent set of considerations and challenges, particularly when interaction is involved.</p>
<p>Take, for instance, the typical barplot. There are several steps to drawing a barplot. First, we have to divide the data into subsets, based on the levels of some categorical variable. Second, we need to summarize or aggregate these subsets by some metric, usually either sum or count. Third, we need to take these summaries and map them to visual encodings, such as x-axis position, y-axis position, and length. Finally, we use these encodings and render the individual bars as rectangles on the computer screen <span class="citation">(see e.g. <a href="#ref-franconeri2021">Franconeri et al. 2021</a>)</span>.</p>
<p>Thus, the data visualization pipeline can be described by four fundamental steps:</p>
<ul>
<li>Partitioning</li>
<li>Aggregation</li>
<li>Scaling/encoding</li>
<li>Rendering</li>
</ul>
<p>These four steps are common to both static and interactive visualization systems, however, interactivity does introduce some unique challenges. User interaction may affect any of the four stages, and as a result, changes need to be propagated accordingly. Finding a general and efficient solution to this change-propagation remains an open research topic <span class="citation">(<a href="#ref-wickham2009">Wickham et al. 2009</a>; <a href="#ref-franconeri2021">Franconeri et al. 2021</a>)</span>. Consequently, discussions of the role interaction within the data visualization pipeline are often fairly vague <span class="citation">(see <a href="#ref-dimara2019">Dimara and Perin 2019</a>; <a href="#ref-wu2024">Wu and Chang 2024</a>)</span>.</p>
<p>This chapter attempts to clarify some of this conceptual ambiguity. Mirroring the structure of the data visualization pipeline, it delves into each of the four steps and explores challenges related to their implementation in interactive systems. The central argument is that interaction is not just a thin veneer that can be layered on top of static graphics; instead, it fundamentally penetrates the abstract machinery of the pipeline. Moreover, for interaction to be predictable, intuitive, and efficient, the components of the pipeline must compose together in specific, well-defined ways, that may be described algebraically using the language of category theory. Mapping out this algebraic composition is crucial for building truly generic and robust interactive data visualization systems <span class="citation">(see also <a href="#ref-wu2024">Wu and Chang 2024</a>; <a href="#ref-sievert2020">Sievert 2020</a>)</span>.</p>
</div>
<div id="partitioning" class="section level2 hasAnchor" number="4.2">
<h2><span class="header-section-number">4.2</span> Partitioning<a href="problems.html#partitioning" class="anchor-section" aria-label="Anchor link to header"></a></h2>
<p>The first step of any data visualization pipeline is to divide the data into parts or subsets. The justification for this initial step lies in our ultimate goal: to represent some aspects of our data by drawing one or (usually) more geometric objects <span class="citation">(<a href="#ref-wilkinson2012">Wilkinson 2012</a>; also known as “marks,” <a href="#ref-satyanarayan2016">Satyanarayan et al. 2016</a>; <a href="#ref-bostock2022">Mike Bostock 2022</a>; and “graphic items,” <a href="#ref-wills2008">Wills 2008</a>)</span>. However, before we can do anything else, we need to define the set of data points each geometric object will represent. In the typical case of two-dimensional tables or data frames, this amounts to slicing the data set into multiple smaller sets of rows or tables.</p>
<p>The partitioning operation is fairly intuitive for aggregate plots, where each object represents several rows of the data. For instance, in a barplot, each bar represents the subset of cases corresponding to a single category, while in histogram, each bar represents the subset of cases which fall within the same bin along some continuous dimension. However, even one-to-one representations of the data may be viewed this way. For example, in scatterplots and parallel coordinate plots, geometric objects (points, lines) can be thought of as representing many small tables of one row each. Similarly, in plots with a single geometric object (e.g. density/radar plots), the corresponding data subset is just the whole data set.</p>
<p>Thus, the process of splitting our data into subsets is in some way fairly straightforward. However, it does raise two fundamental questions:</p>
<ul>
<li>How much of the original data should the subsets contain?</li>
<li>What should be the relations between the subsets?</li>
</ul>
<p>While common data visualization practices provide implicit solutions to these questions, explicit formulations are rarely given in the data visualization literature. This lack of conceptual clarity is problematic because how we choose to partition our data is a consequential decision; when we split our data into subsets, we make assumptions, about the data itself as well as the goals of the visualization process. In interactive data visualization particularly, the relations between the parts of our data become of key importance. Therefore, discussing the two questions above in greater depth is essential.</p>
<div id="show-all-data" class="section level3 hasAnchor" number="4.2.1">
<h3><span class="header-section-number">4.2.1</span> Showing the full data<a href="problems.html#show-all-data" class="anchor-section" aria-label="Anchor link to header"></a></h3>
<blockquote>
<p>“If someone hides data from you, it’s probably because he has something to hide.” <span class="citation">(<a href="#ref-cairo2016">Cairo 2016, 47</a>)</span></p>
</blockquote>
<p>A common recommendation that many data visualization experts provide is that faithful visualizations should show the full data and leave nothing out. The moral behind this recommendation is fairly intuitive. A visualization which hides or obscures information, be it by intent or negligence, cannot be considered a truthful representation of the underlying information <span class="citation">(<a href="#ref-cairo2016">Cairo 2016</a>, <a href="#ref-cairo2019">2019</a>)</span>.</p>
<p>However, data hiding can occur in many different ways. First, the data itself can be cherry-picked or massaged <span class="citation">(see e.g. <a href="#ref-lisnic2024">Lisnic et al. 2024</a>)</span>. This is arguably the most egregious case, and can in some cases amount to malicious statistical practices such as HARKing or p-hacking <span class="citation">(see e.g. <a href="#ref-kerr1998">Kerr 1998</a>; <a href="#ref-lisnic2024">Lisnic et al. 2024</a>; <a href="#ref-head2015">Head et al. 2015</a>)</span>. However, even when showing the full data, some visualizations can obscure or downplay certain data features via poor design or incorrect use of visual encodings <span class="citation">(<a href="#ref-cairo2016">Cairo 2016</a>, <a href="#ref-cairo2019">2019</a>; <a href="#ref-cleveland1985">Cleveland 1985</a>; <a href="#ref-ziemkiewicz2009">Ziemkiewicz and Kosara 2009</a>)</span>. Finally, there is the issue of missing or incomplete data, where some data cannot be easily represented because it is simply not there.</p>
<p>An infamous example of data hiding leading to disastrous real-world consequences was the 1986 crash of the Space Shuttle Challenger <span class="citation">(see <a href="#ref-dalal1989">Dalal, Fowlkes, and Hoadley 1989</a>)</span>. During a pre-launch teleconference, engineers debated the effect of temperature on the performance of O-ring gaskets, as the forecasted temperature was significantly lower than during previous launches. The plot in the left panel of Figure <a href="problems.html#fig:challenger">4.1</a> was used to argue that there was no correlation between temperature and O-ring failures. However, this plot had one significant flaw: it excluded launches where no failures occurred. After the disaster, when the data including the zero-failure launches was plotted, it revealed a clear trend of increasing number of failures as temperature decreased <span class="citation">(see right panel of Figure <a href="problems.html#fig:challenger">4.1</a>, see also <a href="#ref-dalal1989">Dalal, Fowlkes, and Hoadley 1989</a>)</span>.</p>

<div class="figure"><span style="display:block;" id="fig:challenger"></span>
<img src="figures/challenger.png" alt="Relationship between temperature and the number of O-ring failures within the 1986 Challenger data. Left: the original plot as presented during the pre-launch teleconference. Right: a reproduced plot of the same data, including the original data points (black), the excluded data points with zero failures (grey), and an estimated logistic regression fit (red, the source of right-panel data is Dalal, Fowlkes, and Hoadley 1989)." width="750" />
<p class="caption">
Figure 4.1: Relationship between temperature and the number of O-ring failures within the 1986 Challenger data. Left: the original plot as presented during the pre-launch teleconference. Right: a reproduced plot of the same data, including the original data points (black), the excluded data points with zero failures (grey), and an estimated logistic regression fit <span class="citation">(red, the source of right-panel data is <a href="#ref-dalal1989">Dalal, Fowlkes, and Hoadley 1989</a>)</span>.
</p>
</div>
<p>Not all data hiding involves outright omission, however; it can also arise from subtle design choices. Take, for example, axis limits. <span class="citation">Cleveland (<a href="#ref-cleveland1985">1985</a>)</span> argues that axis limits should generally be expanded to avoid inadvertently obscuring data near the edges of the plot <span class="citation">(see also e.g. <a href="#ref-chen2008">Chen et al. 2008, 64</a>)</span>:</p>
<div class="figure"><span style="display:block;" id="fig:expanding-axis-limits"></span>
<img src="figures/expand-scatterplot.png" alt="Without expanding axis limits, objects near the edges of the plot become less salient. Left: axis limits match the data limits exactly, and so the points in the top-left and bottom-right corner of the plot are represented by smaller area and the overall trend is distorted. Right: by expanding axis limits, we can ensure that trend is represented faithfully." width="750" />
<p class="caption">
Figure 4.2: Without expanding axis limits, objects near the edges of the plot become less salient. Left: axis limits match the data limits exactly, and so the points in the top-left and bottom-right corner of the plot are represented by smaller area and the overall trend is distorted. Right: by expanding axis limits, we can ensure that trend is represented faithfully.
</p>
</div>
<p>Figure <a href="problems.html#fig:expanding-axis-limits">4.2</a> illustrates the effect of (not) expanding axis limits. The axis limits of the left scatterplot match the data limits exactly, however, this results in a misrepresentation of the underlying trend, since points near the edges of the plot are represented by smaller area (compared to points in the center of the plot). For instance, the point in the bottom-right corner of the plot lies simultaneously at the x- and y-axis limits, and is thus represented by only one-quarter of the area. In contrast, in the right scatterplot, the axis limits are expanded by a small fraction <span class="citation">(5%, <code>ggplot2</code> default, <a href="#ref-wickham2016">Wickham 2016</a>)</span>, guaranteeing that all data points are represented by equal area<a href="#fn1" class="footnote-ref" id="fnref1"><sup>1</sup></a>.</p>
<p>Finally, there is the issue of data hiding due to missing or incomplete data, which is a bit more complicated. While techniques of visualizing data with missing values do exist <span class="citation">(see e.g. <a href="#ref-unwin1996">Unwin et al. 1996</a>; <a href="#ref-tierney2023">Tierney and Cook 2023</a>)</span>, they are often tied to specific visualization types and styles, and few general solutions are available. In fact, properly analyzing the patterns of missingness in the data may call for a separate, dedicated visualization workflow <span class="citation">(<a href="#ref-tierney2023">Tierney and Cook 2023</a>)</span>.</p>
<p>Either way, data hiding is something we should be mindful of. Unless there is a clear and justifiable reason, no data should be arbitrarily removed or discarded, and we should pick appropriate visual representations to display all of our data faithfully. In the ideal case, the visualization should present a clear and unambiguous mapping between the graphics and the data <span class="citation">(<a href="#ref-ziemkiewicz2009">Ziemkiewicz and Kosara 2009</a>)</span>.</p>
</div>
<div id="comparison-disjointness" class="section level3 hasAnchor" number="4.2.2">
<h3><span class="header-section-number">4.2.2</span> Comparison and disjointness<a href="problems.html#comparison-disjointness" class="anchor-section" aria-label="Anchor link to header"></a></h3>
<blockquote>
<p>“To be truthful and revealing, data graphics must bear on the question at the heart of quantitative thinking: ‘compared to what’?” <span class="citation">(<a href="#ref-tufte2001">Tufte 2001, 74</a>)</span>.</p>
</blockquote>
<blockquote>
<p>“Graphics are for comparison - comparison of one kind or another - not for access to individual amounts.” <span class="citation">(<a href="#ref-tukey1993">Tukey 1993</a>)</span></p>
</blockquote>
<p>The essence of visualization is comparison <span class="citation">(see e.g. <a href="#ref-tufte2001">Tufte 2001</a>; <a href="#ref-tukey1993">Tukey 1993</a>)</span>. That is, when we visualize, we do so with the ultimate goal of comparing our data as geometric objects mapped to a set of visual channels <span class="citation">(<a href="#ref-bertin1983">Bertin 1983</a>; <a href="#ref-wilkinson2012">Wilkinson 2012</a>; <a href="#ref-franconeri2021">Franconeri et al. 2021</a>; <a href="#ref-wilke2019">Wilke 2019</a>)</span>. However, an important question to ask is, what is the essence of the things we are comparing? And how do they relate to each other?</p>
<p>An interesting yet underappreciated fact is that, in many common visualizations, geometric objects within the same graphical layer represent disjoint subsets of the data. That is, in most plots, each point, bar, line, or polygon corresponds a unique set of data points (rows of the data), with no overlap with the other objects in that layer. While different layers can represent the same data (e.g., a smooth fit may be overlaid over scatterplot points, and point clouds may be plotted over boxplot boxes), between objects within the same layer, data is rarely shared. This practice, despite being so common to border on a rule, is surprisingly seldom discussed.</p>
<p>There are, of course, counter-examples. For instance, certain visualizations of set-typed data “double up” the contribution of data subsets, such that the same subset of the data may appear in multiple objects <span class="citation">(see e.g. <a href="#ref-alsallakh2013">Alsallakh et al. 2013</a>, <a href="#ref-alsallakh2014">2014</a>; <a href="#ref-conway2017">Conway, Lex, and Gehlenborg 2017</a>; <a href="#ref-lex2014">Lex et al. 2014</a>)</span>. Similarly, two-dimensional kernel density plots are unusual in that each line or polygon represents an isopleth over a joint probability density of all data points<a href="#fn2" class="footnote-ref" id="fnref2"><sup>2</sup></a>. However, these visualizations represent a fairly small fraction of all plot types. Typically, when we see a plot, we expect each geometric object to represent a distinct set of cases.</p>
<p>This tendency to visualize disjoint objects may partly come from established norms, however, I contend that there is also a deeper reason: the nature of comparison itself. Specifically, my argument is that, in general, it is far easier to compare and reason about objects which are disjoint, rather than ones which are entangled. This makes disjointness a particularly nice, “natural” property.</p>
<div id="naturality-of-disjointness" class="section level4 hasAnchor" number="4.2.2.1">
<h4><span class="header-section-number">4.2.2.1</span> Naturality of disjointness<a href="problems.html#naturality-of-disjointness" class="anchor-section" aria-label="Anchor link to header"></a></h4>
<p>There is evidence about the naturality of disjointness from several fields. First, as statisticians, we know that disjointness underlies one of the fundamental axioms of probability: the sum rule <span class="citation">(<a href="#ref-kolmogorov2018">Kolmogorov and Bharucha-Reid 2018</a>)</span>. Specifically, when multiple events consist of disjoint subsets of the sample space, we can compute the probability of the union of these events by simply summing up their individual probabilities <span class="citation">(see also e.g. <a href="#ref-blitzstein2019">Blitzstein and Hwang 2019</a>; <a href="#ref-bishop2006">Bishop and Nasrabadi 2006</a>)</span>. This fundamental axiom underlies all of statistics <span class="citation">(<a href="#ref-kolmogorov2018">Kolmogorov and Bharucha-Reid 2018</a>)</span>.</p>
<p>Similarly, in computer science, disjointness also plays a crucial role. Specifically, in an area known as generic programming (also known as value semantics), disjointness is one of the fundamental properties for forming software components with whole-part relationships <span class="citation">(<a href="#ref-stepanov2009">Stepanov and McJones 2009, 214</a>)</span>. Unlike components with reference semantics (pointers), these part-whole software components behave like “plain values” (e.g. integers), meaning that they have well defined notions of copy, assignment, equality, and destruction <span class="citation">(<a href="#ref-stepanov2014">Stepanov and Rose 2014</a>)</span>. This greatly simplifies the complexity of programs and allows for equational reasoning, making value semantics a particularly appealing programming model <span class="citation">(see also e.g. <a href="#ref-parent2013">Parent 2013</a>, <a href="#ref-parent2018">2018</a>; <a href="#ref-vaneerd2023">Van Eerd 2023</a>, <a href="#ref-vaneerd2024">2024</a>)</span>.</p>
<p>Finally, there is also empirical evidence showing that people generally struggle with reasoning about non-disjoint events. One particularly famous example is the “Linda experiment” from behavioral psychology <span class="citation">(<a href="#ref-tversky1983">Tversky and Kahneman 1983</a>)</span>. In this experiment, participants presented with a stereotyped description of a woman (Linda) judged her as more likely to be a “bank teller and a feminist” rather than just a “bank teller”, despite the former being a subset of the latter. While generality and the interpretation of the Linda experiment has been debated in the literature, the general finding seems to have been corroborated by other research <span class="citation">(see e.g. <a href="#ref-benjamin2019">Benjamin 2019</a>)</span>.</p>
</div>
<div id="disjointness-and-bijections" class="section level4 hasAnchor" number="4.2.2.2">
<h4><span class="header-section-number">4.2.2.2</span> Disjointness and bijections<a href="problems.html#disjointness-and-bijections" class="anchor-section" aria-label="Anchor link to header"></a></h4>
<p>But even more fundamentally, disjointness is related to a structure which mathematicians have long considered natural: a <a href="math.html#functions">bijection</a> or one-to-one mapping <span class="citation">(see e.g. <a href="#ref-fong2019">Fong and Spivak 2019</a>; <a href="#ref-lawvere2009">Lawvere and Schanuel 2009</a>)</span>. Specifically, if we take a set <span class="math inline">\(S\)</span>, divide it into disjoint subsets, and then assign each subset a label, there will be a one-to-one mapping between the labels and the subsets (i.e. each label corresponds to an <a href="math.html#partitions">equivalence class</a> on <span class="math inline">\(S\)</span>). Practically, this means that we can go back and forth between the subsets and labels, without losing any information, and the converse does not hold when the subsets are non-disjoint.</p>
<p>This bijective property of dijsoint subsets may be particularly useful in data visualization, see Figure <a href="problems.html#fig:geoms-bijection">4.3</a>. For instance, when drawing a barplot, if we divide our data into disjoint subsets and draw one bar corresponding to each part, then we can go back and forth between data subsets and bars (the function of identifying data subsets from bars is invertible). In plots where the objects are non-disjoint, this correspondence is broken: if we select the set of cases corresponding to a bar, there may be no way to identify the original bar from the cases alone.</p>
<div class="figure"><span style="display:block;" id="fig:geoms-bijection"></span>
<img src="figures/geoms-bijection.png" alt="Disjointness induces a one-to-one mapping (bijection) between geometric objects and subsets of the data. Suppose we mark out the cases corresponding to the leftmost bar (red). Top row: when each geometric object (bar) represents unique subset of data points, we can easily go back and forth between the object and its underlying subset (middle panel), and so the function of picking cases corresponding to each object is invertible. Bottom row: if there is an overlap between the cases represented by each object, then there may be no way to identify the original object after we have picked out the corresponding cases." width="886" />
<p class="caption">
Figure 4.3: Disjointness induces a one-to-one mapping (bijection) between geometric objects and subsets of the data. Suppose we mark out the cases corresponding to the leftmost bar (red). Top row: when each geometric object (bar) represents unique subset of data points, we can easily go back and forth between the object and its underlying subset (middle panel), and so the function of picking cases corresponding to each object is invertible. Bottom row: if there is an overlap between the cases represented by each object, then there may be no way to identify the original object after we have picked out the corresponding cases.
</p>
</div>
<p>In static visualizations, non-disjointness impacts interpretability: for any pair of objects, the user has to remember whether they share the underlying data or not. Further, in interactive plots, the consequences may be even more far reaching, and will be discussed in Section <a href="problems.html#disjointness-interaction">4.2.2.4</a>. For now, however, let’s first illustrate the idea of disjointness in more detail, on a real-world example.</p>
</div>
<div id="disjointness-in-visualizations-real-world-example" class="section level4 hasAnchor" number="4.2.2.3">
<h4><span class="header-section-number">4.2.2.3</span> Disjointness in visualizations: Real-world example<a href="problems.html#disjointness-in-visualizations-real-world-example" class="anchor-section" aria-label="Anchor link to header"></a></h4>
<p>To illustrate the idea of disjointness on a real-world example, take the following barplot representing the vote share among the top three parties in the 2023 New Zealand general election <span class="citation">(<a href="#ref-election2023">Electoral Commission New Zealand 2023</a>)</span>:</p>
<div class="figure"><span style="display:block;" id="fig:barplot-bijection"></span>
<img src="figures/barplot-bijection.png" alt="Barplot showing disjoint subsets of the data. The bars show the vote share among the top three parties in the 2023 New Zealand general election, with each bar representing a unique subset of voters." width="750" />
<p class="caption">
Figure 4.4: Barplot showing disjoint subsets of the data. The bars show the vote share among the top three parties in the 2023 New Zealand general election, with each bar representing a unique subset of voters.
</p>
</div>
<p>Each bar represents a unique set of voters. Thus, the data subsets represented by the individual bars are disjoint. This is the case in almost all barplots we encounter; however, as far as I am aware, there are no explicit guidelines in the data visualization literature about this. For example, we could hypothetically transform our data to display the combined votes of the National and Labour parties in the leftmost bar, violating this disjoint property:</p>
<div class="figure"><span style="display:block;" id="fig:union-geoms"></span>
<img src="figures/barplot-notbijection.png" alt="Barplot showing non-disjoint subsets of the data: the leftmost bar represents the union of National and Labour voters." width="750" />
<p class="caption">
Figure 4.5: Barplot showing non-disjoint subsets of the data: the leftmost bar represents the union of National and Labour voters.
</p>
</div>
<p>However, this way of representing the data has several issues. First, the plot in Figure <a href="problems.html#fig:union-geoms">4.5</a> is arguably not very useful for addressing typical visualization goals. For example, when visualizing election data, we care about the relative number of votes each party received. Figure <a href="problems.html#fig:union-geoms">4.5</a> makes complicates this comparison. Specifically, since the leftmost bar represents the union of National and Labour votes, we have to perform additional mental arithmetic if we want to compare the votes received by National and Labour directly <span class="citation">(<a href="#ref-cleveland1985">Cleveland 1985</a>)</span>. Second, we have metadata knowledge <span class="citation">(see e.g. <a href="#ref-wilkinson2012">Wilkinson 2012</a>; <a href="#ref-velleman1993">Velleman and Wilkinson 1993</a>)</span> about the underlying information actually being disjoint. Specifically, we know that, in the New Zealand electoral system, each voter can only vote for a single party. Hence, it does not make sense to arbitrarily merge the data in this way. Finally, Figure <a href="problems.html#fig:union-geoms">4.5</a> also needlessly duplicates information: the number of votes the National party received is rendered twice, once in the leftmost bar and again in the second-left bar. This goes against the general principle of representing our data parsimoniously <span class="citation">(<a href="#ref-tufte2001">Tufte 2001</a>)</span>.</p>
<p>Even when our goal is not to compare absolute counts, there are often better disjoint data visualization methods available. For instance, if we were interested in visualizing the <em>proportion</em> of votes that each party received, we could instead draw the following plot:</p>
<div class="figure"><span style="display:block;" id="fig:stacked-proportion"></span>
<img src="figures/barplot-bijection-proportions.png" alt="Even when proportions are of interest, there are usually disjoint data visualization techniques available. The plot shows proportion of vote share of the top three parties in the 2023 New Zealand general election, with each bar segment again representing a unique subset of voters." width="750" />
<p class="caption">
Figure 4.6: Even when proportions are of interest, there are usually disjoint data visualization techniques available. The plot shows proportion of vote share of the top three parties in the 2023 New Zealand general election, with each bar segment again representing a unique subset of voters.
</p>
</div>
<p>By stacking the bar segments on top of each other as in Figure <a href="problems.html#fig:stacked-proportion">4.6</a>, we can easily compare proportion of the total number of votes each party received, while retaining a disjoint representation: each bar segment represents a disjoint subset of the voters.</p>
<p>The example above is fairly clear-cut case of where disjoint data representation is the better choice. However, there are also more ambiguous situations, such as when multiple attributes of the data are simultaneously present or absent for each case. Take, for example, the 2020 New Zealand joint referendum on the legalization of euthanasia and cannabis. In this referendum, the two issues were included on the same ballot and voters would vote on them simultaneously. The legalization of euthanasia was accepted by the voters, with 65.1% of votes supporting the decision, whereas the legalization of cannabis was rejected, with 50.7% of voters rejecting the decision <span class="citation">(<a href="#ref-referendum2020">Electoral Commission New Zealand 2020</a>)</span>.</p>
<p>We could visualize the referendum data in the following way:</p>
<div class="figure"><span style="display:block;" id="fig:union-geoms2"></span>
<img src="figures/referendum-notbijection.png" alt="Barplot showing a more realistic example of non-disjoint data representation. The bars show the vote share cast by New Zealand voters in the joint 2020 referendum on euthanasia and cannabis. The two bars show (mostly) the same set of ballots, with each ballot contributing to the height of one segment in each bar." width="750" />
<p class="caption">
Figure 4.7: Barplot showing a more realistic example of non-disjoint data representation. The bars show the vote share cast by New Zealand voters in the joint 2020 referendum on euthanasia and cannabis. The two bars show (mostly) the same set of ballots, with each ballot contributing to the height of one segment in each bar.
</p>
</div>
<p>In Figure <a href="problems.html#fig:union-geoms2">4.7</a>, both bars include votes cast by the same voter <span class="citation">(ignoring the votes where no preference was given for either issue, <a href="#ref-referendum2020">Electoral Commission New Zealand 2020</a>)</span>, making the representation non-disjoint. In
this case, the visualization works, since the underlying data is genuinely non-independent (each person cast two votes). If we had information about individual votes, it might be interesting to see how many people voted for both euthanasia and cannabis, how many voted for euthanasia but against cannabis, and so on. As was mentioned before, these types of visualizations can be useful for set-typed data <span class="citation">(see e.g. <a href="#ref-alsallakh2014">Alsallakh et al. 2014</a>)</span>.</p>
<p>However, even though the data here is fundamentally non-independent, there is often a way to represent it in a disjoint way that preserves most of the desirable properties. Specifically, we can split the data and draw it as separate plots or small multiples <span class="citation">(<a href="#ref-tufte2001">Tufte 2001</a>)</span>:</p>
<div class="figure"><span style="display:block;" id="fig:small-multiples"></span>
<img src="figures/referendum-bijection.png" alt="Small multiple figure showing the non-disjoint data represented as disjoint bars. The bars again show the vote share cast by New Zealand voters in the joint 2020 referendum on euthanasia and cannabis, however, this time, each bar within one plot represents a unique subset of the cases." width="750" />
<p class="caption">
Figure 4.8: Small multiple figure showing the non-disjoint data represented as disjoint bars. The bars again show the vote share cast by New Zealand voters in the joint 2020 referendum on euthanasia and cannabis, however, this time, each bar within one plot represents a unique subset of the cases.
</p>
</div>
<p>Here again, in Figure <a href="problems.html#fig:small-multiples">4.8</a>, each bar (segment) in each plot represents a disjoint subset of voters.</p>
</div>
<div id="disjointness-interaction" class="section level4 hasAnchor" number="4.2.2.4">
<h4><span class="header-section-number">4.2.2.4</span> Disjointness and interaction<a href="problems.html#disjointness-interaction" class="anchor-section" aria-label="Anchor link to header"></a></h4>
<p>As I argued above, disjoint subsets offer a simpler mental model for understanding data visualizations. When each geometric object represents a unique set of data points, it becomes easier to reason about the comparisons being made. Conversely, when objects overlap or share underlying data points, additional cognitive effort is required to track the relationships between them.</p>
<p>Further, I argue that disjointness presents a particularly good model for interactive visualization <span class="citation">(see also <a href="#ref-wilhelm2008">Wilhelm 2008</a>)</span>. The natural correspondence between geometric objects and subsets of the data makes certain interactions more intuitive, and conversely, overlapping subsets can produce unexpected or unintuitive behavior. For instance, when a user clicks on a bar in a linked barplot, they might reasonably expect to highlight <em>that particular bar</em>, within the active plot, and the corresponding cases within all the other (passive) plots. If they see parts of other bars within the active plot get highlighted as well, they have to spend additional mental effort thinking about the relation between the objects (bars) and the subsets of the data, since this is no longer one-to-one.</p>
<p>Similar issue arises during querying. When a user queries an object that does not represent a disjoint subset of the data, should the returned summary statistics match the object or the (non-disjoint) subset? And how do we signal this to the user? Again, lack of disjointness introduces subtle ambiguities and complicates the interpretation of the presented information.</p>
<p>This does not mean that non-disjoint subsets cannot be usefuly combined with interaction, in specific contexts <span class="citation">(see e.g. <a href="#ref-alsallakh2014">Alsallakh et al. 2014</a>; <a href="#ref-wilhelm2008">Wilhelm 2008</a>)</span>. However, I argue that, as a general model, disjointness provides a very good default. Disjoint subsets simplify our mental model, and this may be the reason why some authors discuss interactive features in the context of partitions, which are by definition disjoint <span class="citation">(see e.g. <a href="#ref-buja1996">Buja, Cook, and Swayne 1996</a>; <a href="#ref-keim2002">Keim 2002</a>)</span>. Likewise, many common data analytic operations, such as SQL aggregation queries <span class="citation">(<code>GROUP BY</code>, <a href="#ref-hellerstein1999">Hellerstein et al. 1999</a>)</span>, operate on disjoint subsets, and this may be another reason why this model is familiar.</p>
</div>
</div>
<div id="plots-as-partitions" class="section level3 hasAnchor" number="4.2.3">
<h3><span class="header-section-number">4.2.3</span> Plots as partitions<a href="problems.html#plots-as-partitions" class="anchor-section" aria-label="Anchor link to header"></a></h3>
<p>In the two preceding sections, I have argued that it is generally desirable for plots in our (interactive) data visualization system to have two fundamental features:</p>
<ul>
<li>Completeness: They should show the full data</li>
<li>Distinctness: Geometric objects should represent distinct subsets of data points</li>
</ul>
<p>These two features actually map onto two fundamental mathematical properties: <a href="math.html#functions">surjectivity</a> and <a href="math.html#partitions">disjointness</a>. In turn, these two properties define a well-known mathematical structure: a <a href="math.html#partitions">partition</a>. Therefore, partitions offer a compelling model for structuring our plots. I propose the following definition of a <em>regular plot</em>:</p>
<div class="definition">
<p><span id="def:unlabeled-div-1" class="definition"><strong>Definition 4.1  (Regular plot) </strong></span>Regular plot is a plot where the geometric objects within one layer represent a partition of the data, such that there is a bijection between these objects and (possibly aggregated) subsets of the original data.</p>
</div>
<p>Note that this definition still allows for plots where geometric objects in different layers represent overlapping data subsets, such as boxplots with overlaid points, or scatterplots with a smooth fit.</p>
<p>I propose regular plots as a fundamental building block of our interactive data visualization system. By building our interactive figures out of regular plots <span class="citation">(as small multiples, <a href="#ref-tufte2001">Tufte 2001</a>)</span>, we can ensure that the resulting visualization will be easily interpretable, even when combined with interactive features such as linking and querying.</p>
<div id="bijection-on-cases-vs.-bijection-on-subsets" class="section level4 hasAnchor" number="4.2.3.1">
<h4><span class="header-section-number">4.2.3.1</span> Bijection on cases vs. bijection on subsets<a href="problems.html#bijection-on-cases-vs.-bijection-on-subsets" class="anchor-section" aria-label="Anchor link to header"></a></h4>
<p>Although I have not been able to find references conceptualizing plots as partitions in the same general way as I do here, some data visualization researchers have used the language of bijections when discussing graphics. For example, <span class="citation">Dastani (<a href="#ref-dastani2002">2002</a>)</span> discusses plots as bijections (homomorphisms) between data tables and visual attribute tables. Similarly, <span class="citation">Ziemkiewicz and Kosara (<a href="#ref-ziemkiewicz2009">2009</a>)</span>, and <span class="citation">Vickers, Faith, and Rossiter (<a href="#ref-vickers2012">2012</a>)</span> argue that, in order to be visually unambiguous, plots should represent bijections of the underlying data. Essentially, these researchers argue that plots should represent bijective mappings of the data tables, such that each object represents one row of the data.</p>
<p>This “one-row-one-object” model has one important flaw, however: it sidesteps the issue of aggregation (see also Section <a href="problems.html#aggregation">4.3</a>). Specifically, it operates on the assumption that the data arrives pre-aggregated, such that, for instance, when we draw a barplot or a histogram, we start with a table with one row per bar. In practice, this is rarely the case - most data visualization systems incorporate aggregation as an explicit component of the data visualization pipeline <span class="citation">(see e.g. <a href="#ref-chi2000">Chi 2000</a>; <a href="#ref-wickham2016">Wickham 2016</a>; <a href="#ref-satyanarayan2015">Satyanarayan et al. 2015</a>, <a href="#ref-satyanarayan2016">2016</a>; <a href="#ref-wu2024">Wu and Chang 2024</a>)</span>. However, this presents a problem: aggregation is, by definition, not injective. Once we aggregate multiple data points into a set of summaries, we cannot recover the original cases <span class="citation">(see also <a href="#ref-wu2024">Wu and Chang 2024</a>)</span>. Thus, the model proposed by authors such as <span class="citation">Dastani (<a href="#ref-dastani2002">2002</a>)</span>, <span class="citation">Ziemkiewicz and Kosara (<a href="#ref-ziemkiewicz2009">2009</a>)</span>, and <span class="citation">Vickers, Faith, and Rossiter (<a href="#ref-vickers2012">2012</a>)</span> would preclude many common, aggregation-based plot types, such as barplots and histograms. <span class="citation">Ziemkiewicz and Kosara (<a href="#ref-ziemkiewicz2009">2009</a>)</span> do acknowledge that this is a problem, and admit that, at times, aggregation can be an acceptable trade-off, despite the inherent information loss.</p>
<p>However, I propose a different perspective: if we instead model plots as a bijection between <em>parts of data</em> and geometric objects, rather than between individual <em>data points</em> and geometric objects, then aggregation ceases to be a problem. That is, under this view, after we aggregate a multi-row subsets of the data into single-row summaries, the bijective mapping between data and objects is preserved, since we can use an object to uniquely identify a subset of cases. For instance, if we split our data into ten tables and aggregate each table, we are still left with ten tables of one row each. The individual case data is, of course, lost, however, the question is whether we care about that. If we liken plots to bitmap images, we can imagine aggregation as rescaling an image to a lower resolution while preserving salient features (and not introducing any distortion or artifacts). Clearly, the individual pixels of the original image cannot be recovered, however, if the features are what we care about, then the rescaled image may still be considered a faithful representation. Thus, in my view, aggregation can be included in the bijective model of data visualization.</p>
</div>
<div id="products-of-partitions" class="section level4 hasAnchor" number="4.2.3.2">
<h4><span class="header-section-number">4.2.3.2</span> Products of partitions<a href="problems.html#products-of-partitions" class="anchor-section" aria-label="Anchor link to header"></a></h4>
<p>Every plot involves at least one partition that establishes the connection between data and geometric objects. However, many plot types also divide data across multiple dimensions using several partitioning variables. Each data point is then associated with a unique combination (Cartesian product) of these variables. This multidimensional partitioning is particularly common in interactive data visualization, where features such as linking inherently add level of partitioning <span class="citation">(<a href="#ref-wilhelm2008">Wilhelm 2008</a>)</span>. Therefore, it is important to briefly discuss the idea of taking Cartesian products of partitioning variables. While the material might seem simple, I encourage the reader to bear with me as it will become important later.</p>
<p>The idea of partition products may be best illustrated on concrete code examples. First, let’s start with an example of a simple partition. In R, the canonical data structure for creating a grouping structure (partition) is the S3 <code>factor</code> class. We can use <code>factor</code>s to partition our data and compute various aggregate summaries over the parts:</p>
<div class="sourceCode" id="cb1"><pre class="sourceCode r"><code class="sourceCode r"><span id="cb1-1"><a href="problems.html#cb1-1" tabindex="-1"></a>group <span class="ot">&lt;-</span> <span class="fu">factor</span>(<span class="fu">c</span>(<span class="st">&quot;A&quot;</span>, <span class="st">&quot;A&quot;</span>, <span class="st">&quot;A&quot;</span>, <span class="st">&quot;B&quot;</span>, <span class="st">&quot;B&quot;</span>, <span class="st">&quot;C&quot;</span>, <span class="st">&quot;C&quot;</span>, <span class="st">&quot;C&quot;</span>))</span>
<span id="cb1-2"><a href="problems.html#cb1-2" tabindex="-1"></a>income <span class="ot">&lt;-</span> <span class="fu">c</span>(<span class="dv">170</span>, <span class="dv">150</span>, <span class="dv">200</span>, <span class="dv">300</span>, <span class="dv">150</span>, <span class="dv">230</span>, <span class="dv">220</span>, <span class="dv">140</span>)</span>
<span id="cb1-3"><a href="problems.html#cb1-3" tabindex="-1"></a>age <span class="ot">&lt;-</span> <span class="fu">c</span>(<span class="dv">20</span>, <span class="dv">32</span>, <span class="dv">45</span>, <span class="dv">19</span>, <span class="dv">67</span>, <span class="dv">42</span>, <span class="dv">35</span>, <span class="dv">32</span>)</span>
<span id="cb1-4"><a href="problems.html#cb1-4" tabindex="-1"></a></span>
<span id="cb1-5"><a href="problems.html#cb1-5" tabindex="-1"></a><span class="fu">split</span>(<span class="fu">data.frame</span>(income, age), group)</span></code></pre></div>
<pre><code>## $A
##   income age
## 1    170  20
## 2    150  32
## 3    200  45
## 
## $B
##   income age
## 4    300  19
## 5    150  67
## 
## $C
##   income age
## 6    230  42
## 7    220  35
## 8    140  32</code></pre>
<div class="sourceCode" id="cb3"><pre class="sourceCode r"><code class="sourceCode r"><span id="cb3-1"><a href="problems.html#cb3-1" tabindex="-1"></a><span class="fu">aggregate</span>(<span class="fu">cbind</span>(income, age) <span class="sc">~</span> group, <span class="at">FUN =</span> mean)</span></code></pre></div>
<pre><code>##   group   income      age
## 1     A 173.3333 32.33333
## 2     B 225.0000 43.00000
## 3     C 196.6667 36.33333</code></pre>
<div class="sourceCode" id="cb5"><pre class="sourceCode r"><code class="sourceCode r"><span id="cb5-1"><a href="problems.html#cb5-1" tabindex="-1"></a><span class="fu">aggregate</span>(<span class="fu">cbind</span>(income, age) <span class="sc">~</span> group, <span class="at">FUN =</span> sum)</span></code></pre></div>
<pre><code>##   group income age
## 1     A    520  97
## 2     B    450  86
## 3     C    590 109</code></pre>
<p>Once we partition our data and compute the summaries, we can visualize them as geometric objects in a plot. For instance, we could render the summarized data above as a simple barplot using <code>ggplot2</code> <span class="citation">(<a href="#ref-wickham2016">Wickham 2016</a>)</span>:</p>
<div class="sourceCode" id="cb7"><pre class="sourceCode r"><code class="sourceCode r"><span id="cb7-1"><a href="problems.html#cb7-1" tabindex="-1"></a><span class="fu">library</span>(ggplot2)</span>
<span id="cb7-2"><a href="problems.html#cb7-2" tabindex="-1"></a>df <span class="ot">&lt;-</span> <span class="fu">aggregate</span>(income <span class="sc">~</span> group, <span class="at">FUN =</span> sum)</span>
<span id="cb7-3"><a href="problems.html#cb7-3" tabindex="-1"></a></span>
<span id="cb7-4"><a href="problems.html#cb7-4" tabindex="-1"></a><span class="fu">ggplot</span>(df, <span class="fu">aes</span>(group, income)) <span class="sc">+</span></span>
<span id="cb7-5"><a href="problems.html#cb7-5" tabindex="-1"></a>  <span class="fu">geom_col</span>(<span class="at">fill =</span> <span class="st">&quot;#1F78B4&quot;</span>) <span class="sc">+</span></span>
<span id="cb7-6"><a href="problems.html#cb7-6" tabindex="-1"></a>  <span class="fu">labs</span>(<span class="at">x =</span> <span class="st">&quot;Group&quot;</span>, <span class="at">y =</span> <span class="st">&quot;Sum of income&quot;</span>)</span></code></pre></div>
<p><img src="_main_files/figure-html/unnamed-chunk-2-1.png" width="672" /></p>
<p>However, there is only so much we can glean from our data with simple partitions like the one above. When we have multiple partitioning variables, we can investigate more granular subsets of our data by taking their product. While base R does not have a standalone data structure for products of multiple <code>factor</code>s<a href="#fn3" class="footnote-ref" id="fnref3"><sup>3</sup></a>, many built-in functions create this data structure implicitly, when supplied with <code>list()</code> or formula arguments (using the <code>+</code> operator on the right-hand side of the formula to define the product):</p>
<div class="sourceCode" id="cb8"><pre class="sourceCode r"><code class="sourceCode r"><span id="cb8-1"><a href="problems.html#cb8-1" tabindex="-1"></a>gender <span class="ot">&lt;-</span> <span class="fu">factor</span>(<span class="fu">c</span>(<span class="st">&quot;M&quot;</span>, <span class="st">&quot;F&quot;</span>, <span class="st">&quot;F&quot;</span>, <span class="st">&quot;M&quot;</span>, <span class="st">&quot;F&quot;</span>, <span class="st">&quot;M&quot;</span>, <span class="st">&quot;F&quot;</span>, <span class="st">&quot;F&quot;</span>))</span>
<span id="cb8-2"><a href="problems.html#cb8-2" tabindex="-1"></a><span class="fu">split</span>(<span class="fu">data.frame</span>(income, age), <span class="fu">list</span>(group, gender))</span></code></pre></div>
<pre><code>## $A.F
##   income age
## 2    150  32
## 3    200  45
## 
## $B.F
##   income age
## 5    150  67
## 
## $C.F
##   income age
## 7    220  35
## 8    140  32
## 
## $A.M
##   income age
## 1    170  20
## 
## $B.M
##   income age
## 4    300  19
## 
## $C.M
##   income age
## 6    230  42</code></pre>
<div class="sourceCode" id="cb10"><pre class="sourceCode r"><code class="sourceCode r"><span id="cb10-1"><a href="problems.html#cb10-1" tabindex="-1"></a><span class="fu">aggregate</span>(<span class="fu">cbind</span>(income, age) <span class="sc">~</span> group <span class="sc">+</span> gender, <span class="at">FUN =</span> mean)</span></code></pre></div>
<pre><code>##   group gender income  age
## 1     A      F    175 38.5
## 2     B      F    150 67.0
## 3     C      F    180 33.5
## 4     A      M    170 20.0
## 5     B      M    300 19.0
## 6     C      M    230 42.0</code></pre>
<div class="sourceCode" id="cb12"><pre class="sourceCode r"><code class="sourceCode r"><span id="cb12-1"><a href="problems.html#cb12-1" tabindex="-1"></a><span class="fu">aggregate</span>(<span class="fu">cbind</span>(income, age) <span class="sc">~</span> group <span class="sc">+</span> gender, <span class="at">FUN =</span> sum)</span></code></pre></div>
<pre><code>##   group gender income age
## 1     A      F    350  77
## 2     B      F    150  67
## 3     C      F    360  67
## 4     A      M    170  20
## 5     B      M    300  19
## 6     C      M    230  42</code></pre>
<p>These product partitions can also be visualized, to display our data at a greater level of details (for instance, as a stacked barplot):</p>
<div class="sourceCode" id="cb14"><pre class="sourceCode r"><code class="sourceCode r"><span id="cb14-1"><a href="problems.html#cb14-1" tabindex="-1"></a>df <span class="ot">&lt;-</span> <span class="fu">aggregate</span>(income <span class="sc">~</span> group <span class="sc">+</span> gender, <span class="at">FUN =</span> sum)</span>
<span id="cb14-2"><a href="problems.html#cb14-2" tabindex="-1"></a></span>
<span id="cb14-3"><a href="problems.html#cb14-3" tabindex="-1"></a><span class="fu">ggplot</span>(df, <span class="fu">aes</span>(group, income, <span class="at">fill =</span> gender)) <span class="sc">+</span></span>
<span id="cb14-4"><a href="problems.html#cb14-4" tabindex="-1"></a>  <span class="fu">geom_col</span>(<span class="at">col =</span> <span class="st">&quot;white&quot;</span>) <span class="sc">+</span></span>
<span id="cb14-5"><a href="problems.html#cb14-5" tabindex="-1"></a>  <span class="fu">scale_fill_manual</span>(<span class="at">values =</span> <span class="fu">c</span>(<span class="st">&quot;#1F78B4&quot;</span>, <span class="st">&quot;#E31A1C&quot;</span>)) <span class="sc">+</span></span>
<span id="cb14-6"><a href="problems.html#cb14-6" tabindex="-1"></a>  <span class="fu">labs</span>(<span class="at">x =</span> <span class="st">&quot;Group&quot;</span>, <span class="at">y =</span> <span class="st">&quot;Sum of income&quot;</span>, <span class="at">fill =</span> <span class="st">&quot;Gender&quot;</span>)</span></code></pre></div>
<p><img src="_main_files/figure-html/unnamed-chunk-4-1.png" width="672" /></p>
<p>In fact, Cartesian products of partitions are so useful and ubiquitous in data visualization that many data visualization systems <span class="citation">(particularly ones based on the Grammar of Graphics, <a href="#ref-wilkinson2012">Wilkinson 2012</a>)</span> construct them automatically. For instance, we can produce the exact same plot without having to explicitly aggregate the data ourselves, by running the following <code>ggplot</code> call:</p>
<div class="sourceCode" id="cb15"><pre class="sourceCode r"><code class="sourceCode r"><span id="cb15-1"><a href="problems.html#cb15-1" tabindex="-1"></a>df <span class="ot">&lt;-</span> <span class="fu">data.frame</span>(group, gender, income)</span>
<span id="cb15-2"><a href="problems.html#cb15-2" tabindex="-1"></a></span>
<span id="cb15-3"><a href="problems.html#cb15-3" tabindex="-1"></a><span class="fu">ggplot</span>(df, <span class="fu">aes</span>(group, income, <span class="at">fill =</span> gender)) <span class="sc">+</span></span>
<span id="cb15-4"><a href="problems.html#cb15-4" tabindex="-1"></a>  <span class="fu">geom_bar</span>(<span class="at">stat =</span> <span class="st">&quot;summary&quot;</span>, <span class="at">fun =</span> <span class="st">&quot;sum&quot;</span>, <span class="at">col =</span> <span class="st">&quot;white&quot;</span>) <span class="sc">+</span></span>
<span id="cb15-5"><a href="problems.html#cb15-5" tabindex="-1"></a>  <span class="fu">scale_fill_manual</span>(<span class="at">values =</span> <span class="fu">c</span>(<span class="st">&quot;#1F78B4&quot;</span>, <span class="st">&quot;#E31A1C&quot;</span>)) <span class="sc">+</span></span>
<span id="cb15-6"><a href="problems.html#cb15-6" tabindex="-1"></a>  <span class="fu">labs</span>(<span class="at">x =</span> <span class="st">&quot;Group&quot;</span>, <span class="at">y =</span> <span class="st">&quot;Income&quot;</span>, <span class="at">fill =</span> <span class="st">&quot;Gender&quot;</span>)</span></code></pre></div>
<p><img src="_main_files/figure-html/unnamed-chunk-5-1.png" width="672" /></p>
<p>It is worth taking a moment to analyze what is happening inside the <code>ggplot</code> call. The function takes the variables specified inside the <code>aes</code> call and constructs a Cartesian product of partitions. Importantly, it also automatically infers which variables should be used to construct the product and which should instead be aggregated over it. For instance, in the example above, the <code>income</code> variable is <em>not</em> included in the product. This is because it is a continuous variable mapped to the y-axis, and this, in combination with the geometric object (<code>geom_bar</code>), marks it as a an aggregation variable. This behavior is described in the <code>ggplot2</code> codebase in the following code comment:</p>
<blockquote>
<p>If the <code>group</code> variable is not present, then a new group variable is generated from the interaction of all discrete (factor or character) vectors, excluding <code>label</code>.</p>
<p><a href="https://github.com/tidyverse/ggplot2/blob/f46805349d6ca8ca7a99f8966cfa0f29279c2f6c/R/grouping.R#L7"><code>grouping.R</code> file, <code>ggplot2</code> codebase</a> <span class="citation">(<a href="#ref-wickham2016">Wickham 2016</a>)</span></p>
</blockquote>
<p>Thus, clearly, products of partitions are a fundamental building block of graphics. However, an important thing to discuss is that there are actually two different ways we view products <span class="citation">(see <a href="#ref-wilkinson2012">Wilkinson 2012, 64</a>)</span>. First, there is the simple, commutative perspective where the order of variables that form the product does not matter. In these “flat” products, the product of <span class="math inline">\(x\)</span> and <span class="math inline">\(y\)</span> is the same as the product of <span class="math inline">\(y\)</span> and <span class="math inline">\(x\)</span>. Second, we can also view products as nesting, which does establish a hierarchy. While flat partitions are sufficient to describe for many types of visualizations, some plot types require this hierarchical structure. This issue will be discussed in greater depth in the following section.</p>
</div>
<div id="limits-of-flat-products" class="section level4 hasAnchor" number="4.2.3.3">
<h4><span class="header-section-number">4.2.3.3</span> Limits of flat product partitions<a href="problems.html#limits-of-flat-products" class="anchor-section" aria-label="Anchor link to header"></a></h4>
<p>As mentioned in the previous section, a fair number of common plots can be represented via a single flat product of all of the partitioning variables. However, for other types of plots, this simple model is not sufficient. Specifically, certain types of plots exhibit hierarchical dependencies which cannot be represented under this flat model <span class="citation">(see also <a href="#ref-slingsby2009">Slingsby, Dykes, and Wood 2009</a>; <a href="#ref-wu2022">Wu 2022</a>)</span>.</p>
<p>To give a concrete example, let’s turn back to the barplot from the previous section (Section <a href="problems.html#plots-as-partitions">4.2.3</a>). To draw the barplot, we first split our data into smaller tables and summarized each table by summing the values. We then passed this data to the visualization library <span class="citation">(<code>ggplot2</code>, <a href="#ref-wickham2016">Wickham 2016</a>)</span>, and represented it as a stacked barplot. This gave us a good visualization for comparing absolute counts across categories.</p>
<p>However, what if, instead of comparing absolute counts, we wanted to compare proportions? It turns out there is another type of visualization, called the spineplot, which can be used to represent the same underlying data as a barplot, however, is much better suited for comparing proportions:</p>
<div class="figure"><span style="display:block;" id="fig:barplot-spineplot"></span>
<img src="figures/barplot-spineplot.png" alt="The same underlying data represented as a barplot (left) and a spineplot (right)." width="750" />
<p class="caption">
Figure 4.9: The same underlying data represented as a barplot (left) and a spineplot (right).
</p>
</div>
<p>Like barplots, spineplots represent some summary statistic (usually counts), aggregated within the levels of a product of two categorical variables. However, unlike barplots, spineplots map the underlying statistics to both the y-axis position (height) and the bar width. Furthermore, the y-axis position is normalized, such that the heights of the different segments within the same category add up to one. This normalization makes it possible to compare the relative frequencies within categories directly (notice how the right panel in Figure <a href="problems.html#fig:barplot-spineplot">4.9</a> makes it obvious that the proportion of red cases within the B and C categories is the same). Thus, like the barplot, the spineplot is a valuable tool for visualizing categorical data, especially when we can use interactive features to switch from one type of representation to the other.</p>
<p>However, while barplot and spineplot represent the same underlying data, turning one into the other is not easy, and many common grammar-of-graphics-based visualization systems lack simple declarative means for defining spineplots. For instance, there is no built-in functionality for drawing spineplots in <code>ggplot2</code>; to draw the spineplot in the right panel of Figure <a href="problems.html#fig:barplot-spineplot">4.9</a> required over 10 lines of external data wrangling code <span class="citation">(using standard <code>dplyr</code> syntax, <a href="#ref-wickham2023">Wickham, Pedersen, and Seidel 2023</a>)</span>. But what makes spineplots so challenging? The reason for this is that there are hierarchical dependencies between the different components of the graphic <span class="citation">(see also e.g. <a href="#ref-mcdonald1990">McDonald, Stuetzle, and Buja 1990</a>; <a href="#ref-keller2024">Keller, Manz, and Gehlenborg 2024</a>)</span>. As a result spineplot cannot be represented by the simple flat partition product model underlying <code>ggplot2</code>. In the language of relational algebra, we cannot render a spineplot based on a single aggregated table of summaries which is in the third normal form <span class="citation">(3NF, <a href="#ref-codd1970">Codd 1970</a>)</span>; to compute the normalized heights of bar segments, we need to compute and left-join parent data values, breaking the 3NF. Similar issues apply to other “normalized” types of plots, such as spinograms, as well as other innately hierarchical displays such as treemaps and mosaic plots [see e.g. <span class="citation">Theus (<a href="#ref-theus2002">2002</a>)</span>; slingsby2009].</p>
</div>
</div>
<div id="hierarchy" class="section level3 hasAnchor" number="4.2.4">
<h3><span class="header-section-number">4.2.4</span> Partitions, hierarchy, and preorders<a href="problems.html#hierarchy" class="anchor-section" aria-label="Anchor link to header"></a></h3>
<p>Thus, a core issue is that certain types of visualizations exhibit hierarchical dependencies (nesting) which cannot be represented by simple, “flat” products of partitions. Let’s illustrate the point in more detail, by outlining the hierarchical dependencies in a spineplot. In a spineplot, the data is summarized and stacked <em>along and across</em> different levels of aggregation <span class="citation">(see also <a href="#ref-wu2024">Wu and Chang 2024</a>)</span>:</p>
<ul>
<li>Along the x-axis, we stack the summaries <em>across the levels of the top-level partitioning variable</em></li>
<li>Along the y-axis, we stack the summaries <em>across the levels of a product of two partitioning variables</em> and normalize them by the values <em>within the levels of the top-level factor</em>.</li>
</ul>
<p>For example, assume we have a data set with two categorical variables, with <span class="math inline">\(j\)</span> and <span class="math inline">\(k\)</span> levels respectively. If we want to render a spineplot using these two variables, it is not enough to simply split our data into <span class="math inline">\(j \cdot k\)</span> tables. Instead, we need to partition our data twice: first, split it into <span class="math inline">\(j\)</span> tables, and second, split it into <span class="math inline">\(j \cdot k\)</span> tables. We also need to keep track to which of the larger <span class="math inline">\(j\)</span> tables each of the smaller <span class="math inline">\(j \cdot k\)</span> tables relates to. This inherently induces a hierarchical relationship, where the resulting data subsets form a graph - specifically, a tree - see Figure <a href="problems.html#fig:spineplot-tree">4.10</a>:</p>
<div class="figure"><span style="display:block;" id="fig:spineplot-tree"></span>
<img src="figures/spineplot-tree.png" alt="A diagram of the hierarchical relationship between the subsets of the data represented by a spineplot/barplot. The whole data set is partitioned into bars, which are in turn partitioned into bar segments." width="708" />
<p class="caption">
Figure 4.10: A diagram of the hierarchical relationship between the subsets of the data represented by a spineplot/barplot. The whole data set is partitioned into bars, which are in turn partitioned into bar segments.
</p>
</div>
<p>In <a href="problems.html#fig:spineplot-tree">4.10</a>, each vertical level represents a data partition, and arrows indicate relationships between data subsets, such that a bar subset is composed of segment subsets, and the whole data set is in turn composed of bar subsets. This same tree can be used to represent both barplots and spineplots. For a stacked barplot, this tree structure can be implicit, since, hypothetically, we can work with the lowest level of the partitioning only (provided we can maintain the correct stacking order). However, for spineplots, this hierarchical structure is essential, since we need to apply transformations <em>across</em> the levels of the hierarchy: normalize the statistics corresponding to each segment by the values corresponding to the parent bar. This is only possible if each segment has a reference to its parent, necessitating a hierarchical structure.</p>
<p>Thus, to model a broad class of plots, we need ways for encoding hierarchical partitioning of our data. Furthermore, for reasons that will become clear later, it may be beneficial to introduce a more formal, mathematical framework for thinking about this hierarchy. A simple algebraic structure for encoding such class of hierarchies is a preorder.</p>
<div id="plots-as-preorders" class="section level4 hasAnchor" number="4.2.4.1">
<h4><span class="header-section-number">4.2.4.1</span> Plots as preorders<a href="problems.html#plots-as-preorders" class="anchor-section" aria-label="Anchor link to header"></a></h4>
<p>A <a href="math.html#preorders">preorder</a> is a binary relation on a set <span class="math inline">\(S\)</span>, generally denoted by <span class="math inline">\(\leq\)</span>, that is both reflexive and transitive. In simpler terms, given a preordered set <span class="math inline">\(S\)</span>, any two elements <span class="math inline">\(a, b \in S\)</span> either relate (<span class="math inline">\(a \leq b\)</span>, meaning <span class="math inline">\(a\)</span> is “less than” <span class="math inline">\(b\)</span>), or they do not relate at all. Further, the relation obeys some common sense properties: every element relates to itself (reflexivity), and if <span class="math inline">\(a\)</span> relates to <span class="math inline">\(b\)</span> and <span class="math inline">\(b\)</span> relates to <span class="math inline">\(c\)</span>, then <span class="math inline">\(a\)</span> relates to <span class="math inline">\(c\)</span> as well (transitivity).</p>
<p>We can turn our hierarchy of data subsets in Figure <a href="problems.html#fig:spineplot-tree">4.10</a> into a preorder very easily, by simply being more explicit about the relations, see Figure <a href="problems.html#fig:barplot-preorder">4.11</a>. Specifically, define set <span class="math inline">\(S\)</span> as the set of data subsets <span class="math inline">\(D\)</span>, with the individual subsets indexed by identity such that e.g. <span class="math inline">\(D_D\)</span> corresponds to the whole data set, <span class="math inline">\(D_{B_1}, \ldots D_{B_n}\)</span> correspond to bar subsets, and <span class="math inline">\(D_{S_1}, \ldots D_{S_k}\)</span> correspond to segment subsets. Further, define the binary relation <span class="math inline">\(\leq\)</span> as the set inclusion relation <span class="math inline">\(\subseteq\)</span>.</p>
<div class="figure"><span style="display:block;" id="fig:barplot-preorder"></span>
<img src="figures/barplot-preorder.png" alt="A diagram of a barplot or spinogram, represented as a preorder ordered by set inclusion. $D_D$ represents the whole data set, $D_{B_i}$ represent bar subsets, and $D_{S_j}$ represent individual bar segment subsets. Arrows indicate set inclusion." width="717" />
<p class="caption">
Figure 4.11: A diagram of a barplot or spinogram, represented as a preorder ordered by set inclusion. <span class="math inline">\(D_D\)</span> represents the whole data set, <span class="math inline">\(D_{B_i}\)</span> represent bar subsets, and <span class="math inline">\(D_{S_j}\)</span> represent individual bar segment subsets. Arrows indicate set inclusion.
</p>
</div>
<p>Then, we see that the two properties of preorders do indeed hold: every data subset is included in itself (reflexivity), and if a segment subset is a part of a bar subset, and bar subset is a part of the whole data set, then the segment subset is, clearly, a part of the whole data set as well (transitivity).</p>
<p>While set inclusion (<span class="math inline">\(\subseteq\)</span>) is a perfectly valid way to describe the relation between data subsets, a slightly different perspective using set union <span class="math inline">\((\cup)\)</span> will be more beneficial later. Specifically, instead of stating that a segment subset is included in a bar subset, we can express the relation by stating that a segment subset can be combined with another set to form the bar subset:</p>
<div class="figure"><span style="display:block;" id="fig:barplot-preorder2"></span>
<img src="figures/barplot-preorder2.png" alt="A more precise version of the diagram of a barplot/spinogram, with the relation identified as set union with the sibling subsets." width="717" />
<p class="caption">
Figure 4.12: A more precise version of the diagram of a barplot/spinogram, with the relation identified as set union with the sibling subsets.
</p>
</div>
<p>This definition is still fairly vague, however, it will be made more precise in Section <a href="problems.html#preorders-categories">4.3.2.2</a>. To summarize the key points, our data subset hierarchy can be described as a preorder, where the ordering is defined by a kind of set union operation. This is really the same idea as Figure <a href="problems.html#fig:spineplot-tree">4.10</a>, we are simply being more explicit about our data assumptions. The real utility of this approach will be revealed later, in Section <a href="problems.html#aggregation">4.3</a>. However, for now, it may be useful to revise our definition of a regular plot:</p>
<div class="definition">
<p><span id="def:unlabeled-div-2" class="definition"><strong>Definition 4.2  (Regular plot 2) </strong></span>Regular plot is a plot where the geometric objects within one layer represent a preorder of data subsets ordered by set inclusion/union (such that there is a bijection between these objects and the data subsets, and the subsets on the same order level represent a partition of the data).</p>
</div>
</div>
<div id="the-graph-behind-the-graph" class="section level4 hasAnchor" number="4.2.4.2">
<h4><span class="header-section-number">4.2.4.2</span> The graph behind the graph<a href="problems.html#the-graph-behind-the-graph" class="anchor-section" aria-label="Anchor link to header"></a></h4>
<p>To summarize the main point of this entire section, <em>graphs are graphs</em>. As a bit of a playful side-note, this view is not shared by everyone. Particularly, the poster of the following meme shared on the Mathematical Mathematics Memes Facebook group <span class="citation">(<a href="#ref-mathematicalmathematics2024">Martínez 2024</a>)</span> might not agree:</p>

<div class="figure"><span style="display:block;" id="fig:meme"></span>
<img src="figures/graphs-cosplayers.jpg" alt="A joke image shared in the Mathematical Mathematics Memes Facebook group on the 28th of March, 2024 (Martínez 2024)." width="75%" />
<p class="caption">
Figure 4.13: A joke image shared in the Mathematical Mathematics Memes Facebook group on the 28th of March, 2024 <span class="citation">(<a href="#ref-mathematicalmathematics2024">Martínez 2024</a>)</span>.
</p>
</div>
<p>I hope I have made a reasonably strong case here that many data visualization types really are graphs, and not “delusional cosplayers”. By organizing our data subsets into a preorder, we induce a graph-like structure of part-whole relationships.</p>
<p>However, organizing our data into a hierarchy introduces a new kind of challenge: preserving the inherent relationships. Preorders, as algebraic objects, have structure encoded in their order relations. Intuitively, it would be wrong to disregard this structure in the subsequent steps of the data visualization pipeline. For instance, imagine taking a barplot, dividing the bars into segments, and then stacking half of the segments and dodging the rest. Clearly, something would be wrong with this approach - it would not preserve the part-whole relationships between the underlying data subsets.</p>
<p>However, what does it <em>really</em> mean to preserve the relationships in our data? This question will be explored in detail in the following section, which deals with the next step of the data visualization pipeline: aggregation.</p>
</div>
</div>
</div>
<div id="aggregation" class="section level2 hasAnchor" number="4.3">
<h2><span class="header-section-number">4.3</span> Aggregation<a href="problems.html#aggregation" class="anchor-section" aria-label="Anchor link to header"></a></h2>
<blockquote>
<p>“This system cannot produce a meaningless graphic, however. This is a strong claim, vulnerable to a single counter-example. It is a claim based on the formal rules of the system, however, not on the evaluation of specific graphics it may produce.”</p>
<p>“Some of the combinations of graphs and statistical methods may be degenerate or bizarre, but there is no moral reason to restrict them.”</p>
<p><span class="citation">Wilkinson (<a href="#ref-wilkinson2012">2012</a>)</span>, The Grammar of Graphics, pp. 15 and 112.</p>
</blockquote>
<p>The second step of any data visualization pipeline is aggregation. Specifically, after we split our data into a hierarchy of parts (a preorder), we need to summarize each part via a set of summary statistics. Further, as I have hinted at in the previous section, these summaries should respect the hierarchical relationships in our data. Thus, while the computing summaries may seem like a fairly straightforward step in the visualization pipeline, there is more complexity here than meets the eye, and this will be the main subject of the current section.</p>
<div id="the-relationship-between-graphics-and-statistics" class="section level3 hasAnchor" number="4.3.1">
<h3><span class="header-section-number">4.3.1</span> The relationship between graphics and statistics<a href="problems.html#the-relationship-between-graphics-and-statistics" class="anchor-section" aria-label="Anchor link to header"></a></h3>
<p>A key issue in data visualization, which is also the central theme of the present thesis, concerns the relationship between graphics and statistics. Specifically, when we summarize our data and want to render these summaries as geometric objects, a couple of important questions arise: can we pair arbitrary statistics and geometric objects? Or are there some constraints on which which statistics and geometric objects can be meaningfully combined? Further, does interaction play any role in this?</p>
<div id="independence-the-grammar-based-model" class="section level4 hasAnchor" number="4.3.1.1">
<h4><span class="header-section-number">4.3.1.1</span> Independence: The grammar-based model<a href="problems.html#independence-the-grammar-based-model" class="anchor-section" aria-label="Anchor link to header"></a></h4>
<p>Currently, a highly popular approach based on Wilkinson’s Grammar of Graphics <span class="citation">(<a href="#ref-wilkinson2012">2012</a>)</span> involves treating graphics and statistics as independent entities. Under this “grammar-based” model, visualizations are constructed out of independent, modular components, such as geometric objects, statistics, scales, and coordinate systems. See, for example, the following quote by Wilkinson <span class="citation">(<a href="#ref-wilkinson2012">2012, 14–15</a>)</span>:</p>
<blockquote>
<p>“We have tried to avoid adding functions, graphs, or operators that do not work independently across the system. There are doubtless many statistical graphics the system in this book cannot completely specify. We can add many different graphs, transformations, types of axes, annotations, etc., but there are two limitations we will always face with a formal system.</p>
</blockquote>
<p>The grammar-based model offers many advantages, including simplicity, ease of use, and expressive power. This has contributed to its widespread adoption and implementation in many data visualization systems <span class="citation">(see e.g. <a href="#ref-mcnutt2022">McNutt 2022</a>; <a href="#ref-kim2022">Kim et al. 2022</a>; <a href="#ref-vanderplas2020">Vanderplas, Cook, and Hofmann 2020</a>; <a href="#ref-wickham2010">Wickham 2010</a>; <a href="#ref-satyanarayan2014">Satyanarayan, Wongsuphasawat, and Heer 2014</a>; <a href="#ref-satyanarayan2016">Satyanarayan et al. 2016</a>)</span>. The canonical example is the famous <code>ggplot2</code> package <span class="citation">(<a href="#ref-wickham2010">Wickham 2010</a>)</span>. In <code>ggplot2</code>, plots are built out of components such as geometric objects (called <code>geoms</code>), statistical summaries (<code>stats</code>), and scales. These components can be flexibly combined, allowing the user to express a wide range of graphics using a small set of primitives. The expressive power of <code>ggplot2</code> has made it one of the most popular R packages of all time.<a href="#fn4" class="footnote-ref" id="fnref4"><sup>4</sup></a>.</p>
<p>However, despite its advantages, the grammar-based model has one fundamental flaw: graphics and statistics are not truly independent <span class="citation">(see also <a href="#ref-wu2024">Wu and Chang 2024</a>)</span>. Instead, any visual representation must be congruent with the mathematical properties of the underlying data. This constraint, while present even in static visualizations, becomes especially critical in interactive contexts. To clarify these ideas, the following section will develop an example that demonstrates the lack of independence between visual representations and statistical summaries.</p>
</div>
<div id="stacking-not-graphical" class="section level4 hasAnchor" number="4.3.1.2">
<h4><span class="header-section-number">4.3.1.2</span> Motivating example: Limits of independence<a href="problems.html#stacking-not-graphical" class="anchor-section" aria-label="Anchor link to header"></a></h4>
<p>For this example, I will use famous data set from a study on the effect of smoking on child lung capacity <span class="citation">(<a href="#ref-tager1979">Tager et al. 1979</a>; <a href="#ref-kahn2005">Kahn 2005</a>)</span>. In the study, the researchers measured children’s forced expiratory volume (FEV), and recorded it alongside age, height, sex, and smoking status.</p>
<p>A rather surprising feature of this data set is that, at a glance, the children who smoked actually had <em>greater</em> lung capacity than non-smokers. In <code>ggplot2</code>, we can easily create a boxplot showing the relationship between smoking status and FEV using the following code snippet:</p>
<div class="sourceCode" id="cb16"><pre class="sourceCode r"><code class="sourceCode r"><span id="cb16-1"><a href="problems.html#cb16-1" tabindex="-1"></a>fev <span class="ot">&lt;-</span> <span class="fu">read.csv</span>(<span class="st">&quot;./data/fev.csv&quot;</span>)</span>
<span id="cb16-2"><a href="problems.html#cb16-2" tabindex="-1"></a></span>
<span id="cb16-3"><a href="problems.html#cb16-3" tabindex="-1"></a><span class="fu">library</span>(ggplot2)</span>
<span id="cb16-4"><a href="problems.html#cb16-4" tabindex="-1"></a></span>
<span id="cb16-5"><a href="problems.html#cb16-5" tabindex="-1"></a><span class="fu">ggplot</span>(fev, <span class="fu">aes</span>(smoke, fev, <span class="at">fill =</span> smoke)) <span class="sc">+</span></span>
<span id="cb16-6"><a href="problems.html#cb16-6" tabindex="-1"></a>  <span class="fu">geom_boxplot</span>()</span></code></pre></div>
<p><img src="figures/grammar-boxplot.png" width="750" /></p>
<p>Before we start extolling the benefits of smoking for juvenile lung health however, it may be a good idea to first investigate some possible confounding. Lung volume develops with age, and the researchers had collected data from children ages three and up. Clearly, there would be few smokers among three-year olds, so we should make sure age is not a confounding variable.</p>
<p>We can verify that there indeed is a strong correlation between age and FEV like so:</p>
<div class="sourceCode" id="cb17"><pre class="sourceCode r"><code class="sourceCode r"><span id="cb17-1"><a href="problems.html#cb17-1" tabindex="-1"></a><span class="fu">ggplot</span>(fev, <span class="fu">aes</span>(age, fev, <span class="at">fill =</span> smoke)) <span class="sc">+</span></span>
<span id="cb17-2"><a href="problems.html#cb17-2" tabindex="-1"></a>  <span class="fu">geom_point</span>()</span></code></pre></div>
<p><img src="figures/grammar-scatterplot.png" width="750" /></p>
<p>From the plot above, we can see that age and FEV correlate strongly, and also that smokers tended to be quite a bit older than the non-smokers. To visualize the age-distribution of smokers and non-smokers a bit more clearly, we can draw an ordinary stacked barplot:</p>
<div class="sourceCode" id="cb18"><pre class="sourceCode r"><code class="sourceCode r"><span id="cb18-1"><a href="problems.html#cb18-1" tabindex="-1"></a><span class="fu">ggplot</span>(fev, <span class="fu">aes</span>(age, <span class="at">fill =</span> smoke)) <span class="sc">+</span></span>
<span id="cb18-2"><a href="problems.html#cb18-2" tabindex="-1"></a>  <span class="fu">geom_bar</span>()</span></code></pre></div>
<div class="figure"><span style="display:block;" id="fig:grammar-barplot-counts"></span>
<img src="figures/grammar-barplot-counts.png" alt="The number of participants by age and smoking status. Notice that the bar segments 'stack', such that the height of the whole bar accurately represents the combined number of smokers and non-smokers." width="750" />
<p class="caption">
Figure 4.14: The number of participants by age and smoking status. Notice that the bar segments ‘stack’, such that the height of the whole bar accurately represents the combined number of smokers and non-smokers.
</p>
</div>
<p>The plot above clearly shows that there were more far more non-smokers than smokers, and that, on average, smokers tended to older. This provides some support for our confounding hypothesis.</p>
<p>Now, what if we wanted to compare FEV across the different ages? A data visualization novice might do something like below, and draw a stacked barplot of the average FEV within each age group:</p>
<div class="sourceCode" id="cb19"><pre class="sourceCode r"><code class="sourceCode r"><span id="cb19-1"><a href="problems.html#cb19-1" tabindex="-1"></a><span class="fu">ggplot</span>(fev, <span class="fu">aes</span>(age, fev, <span class="at">fill =</span> smoke)) <span class="sc">+</span></span>
<span id="cb19-2"><a href="problems.html#cb19-2" tabindex="-1"></a>  <span class="fu">geom_bar</span>(<span class="at">stat =</span> <span class="st">&quot;summary&quot;</span>, <span class="at">fun =</span> <span class="st">&quot;mean&quot;</span>)</span></code></pre></div>
<div class="figure"><span style="display:block;" id="fig:grammar-barplot-means"></span>
<img src="figures/grammar-barplot-means.png" alt="A fundamentally flawed visualization of the average FEV by age and smoking status. Notice that the total height of the stacked bars is meaningless: it represents the sum of grouped averages, which is not a valid summary of the combined smoker and non-smoker data." width="750" />
<p class="caption">
Figure 4.15: A fundamentally flawed visualization of the average FEV by age and smoking status. Notice that the total height of the stacked bars is meaningless: it represents the sum of grouped averages, which is not a valid summary of the combined smoker and non-smoker data.
</p>
</div>
<p>At a glance, the plot in <a href="problems.html#fig:grammar-barplot-means">4.15</a> looks fine. However, what do the heights of the stacked bars actually represent? Each coloured bar segment represents a mean of the <code>fev</code> variable, grouped by the levels defined by the product of the <code>age</code> and <code>smoke</code> variables. By stacking the bars on top of each other, we are essentially summing up the average FEV of smokers and non-smokers, within the given age category.</p>
</div>
<div id="stackable-or-not" class="section level4 hasAnchor" number="4.3.1.3">
<h4><span class="header-section-number">4.3.1.3</span> Some statistics are stackable but others are not<a href="problems.html#stackable-or-not" class="anchor-section" aria-label="Anchor link to header"></a></h4>
<p>The plot in Figure <a href="problems.html#fig:grammar-barplot-means">4.15</a> is a bad visualization because the bar heights lack a meaningful statistical interpretation - the sum of grouped averages is not something that most visualization consumers would know how to interpret or care about. However, contrast that with the previous example, Figure <a href="problems.html#fig:grammar-barplot-counts">4.14</a>. There, the heights of the stacked bars represented valid overall counts - the number of smokers and non-smokers within a given age category combined. In Figure <a href="problems.html#fig:grammar-barplot-means">4.15</a>, this is not the case - the sum of the group means is different from the mean of the combined cases.</p>
<p>One of the causes of this problem is that, in <code>ggplot2</code>, stacking is implemented as a purely graphical operation. That is, within the context of the visualization system, stacking operates on geometric objects (rectangles) by summing the corresponding y-axis coordinates. This happens irrespective of the underlying summary statistic, and, as we can see in Figure <a href="problems.html#fig:grammar-barplot-means">4.15</a>, can lead to meaningless visualizations. <em>What</em> we stack matters, and indeed, many data visualization researchers have explicitly warned about this:</p>
<blockquote>
<p>“Stacking is useful when the sum of the amounts represented by the individual stacked bars is in itself a meaningful amount” <span class="citation">(<a href="#ref-wilke2019">Wilke 2019, 52</a>)</span>.</p>
</blockquote>
<blockquote>
<p>“Because this gives the visual impression of one element that is the sum of several others, it is very important that if the element’s size is used to display a statistic, then that statistic must be summable. Stacking bars that represent counts, sums, or percentages are fine, but a stacked bar chart where bars show average values is generally meaningless.” <span class="citation">(<a href="#ref-wills2011">Wills 2011, 112</a>)</span>.</p>
</blockquote>
<blockquote>
<p>“[…] We do this to ensure that aggregate statistics are always computed over the input data, and so users do not inadvertantly compute e.g., averages of averages, which can easily lead to misinterpretation.” <span class="citation">(<a href="#ref-wu2022">Wu 2022</a>)</span></p>
</blockquote>
<p>Clearly then, we cannot stack means by summing them. Is there another way? Before, with the barplot of counts, we had applied the sum operator twice - once to sum the cases in the segment, and again to sum the cases within the bar by summing the segments. Could we do something like that here and take the average of averages? Unfortunately, as <span class="citation">Wu (<a href="#ref-wu2022">2022</a>)</span> points out above, this approach also fails, since the mean of group means is different from the grand mean (unless by accident).</p>
<p>All in all, one might get the impression that we can only ever meaningfully “stack” or “highlight” sums and counts. However, take a look at the following plot:</p>
<div class="sourceCode" id="cb20"><pre class="sourceCode r"><code class="sourceCode r"><span id="cb20-1"><a href="problems.html#cb20-1" tabindex="-1"></a><span class="co"># Code is not included because this plot cannot be</span></span>
<span id="cb20-2"><a href="problems.html#cb20-2" tabindex="-1"></a><span class="co"># with a simple ggplot call (without data wrangling)</span></span></code></pre></div>
<div class="figure"><span style="display:block;" id="fig:grammar-barplot-maximums"></span>
<img src="figures/grammar-barplot-maximums.png" alt="The maximum of maxima is a valid maximum of all cases." width="750" />
<p class="caption">
Figure 4.16: The maximum of maxima is a valid maximum of all cases.
</p>
</div>
<p>Here, in Figure <a href="problems.html#fig:grammar-barplot-maximums">4.16</a>, we again plot FEV for smokers and non-smokers across the different age groups, however, this time, we display the <em>maximum FEV</em> on the y-axis. From this plot, we can see that, in most of the age categories which included smokers (age 9 and up), the child with the greatest lung capacity was a non-smoker, although there were several exceptions (ages 11, 16, and 18).</p>
<p>Notice one important feature of the plot above: the heights of the “stacked” bars represent a valid overall summary. Taking grouped data, summarizing each group by its maximum, and then taking the maximum of those maxima yields a valid overall maximum. That is, <em>the maximum of maxima is a valid maximum of all cases</em>. While the general usefulness of the plot in Figure <a href="problems.html#fig:grammar-barplot-maximums">4.16</a> could be debated - given that each bar segment effectively represents a single data point (the group maximum), and that, in small data sets, the maximum can be a highly variable <span class="citation">(c.f. <a href="#ref-wills2008">Wills 2008</a>)</span> - the plot still demonstrates one important, unshakable fact: summaries other than sums and counts can be meaningfully “stacked.”</p>
<p>Once we acknowledge this relationship between stacking and the statistics underlying our plot, we are fundamentally departing from the independence model described by <span class="citation">Wilkinson (<a href="#ref-wilkinson2012">2012</a>)</span> and implemented in, for example, <code>ggplot2</code> <span class="citation">(<a href="#ref-wickham2016">Wickham 2016</a>)</span>. Clearly, the view of stacking as a mere graphical “collision modifier” <span class="citation">(<a href="#ref-wilkinson2012">Wilkinson 2012</a>)</span> is incomplete. While moving beyond the independence model means giving up on the ability to neatly separate geometric objects from the quantities they represent - which is certainly a significant loss - it also opens up new tantalizing avenues for inquiry. What is it that makes certain statistics combine meaningfully together, such that the resulting visualization is valid under stacking? Can we describe this property more formally? And how does this relate to the rest of the data visualization pipeline? Exploring these questions is one of the core aims of the present thesis.</p>
</div>
<div id="stacking-part-whole" class="section level4 hasAnchor" number="4.3.1.4">
<h4><span class="header-section-number">4.3.1.4</span> Advantages of stacking: Part-whole relations<a href="problems.html#stacking-part-whole" class="anchor-section" aria-label="Anchor link to header"></a></h4>
<p>However, before we go on to discuss what makes certain statistics stackable, we must first justify the focus on stacking. Specifically, some might argue that stacking is only one way of presenting partitioned data, and that we could equally well present “unstackable” summaries such as the averages in Figure <a href="problems.html#fig:grammar-barplot-means">4.15</a> by plotting the corresponding bars side by side (a technique know as dodging), or by plotting them on top of each other in semi-transparent layers, see Figure <a href="problems.html#fig:dodging-layering">4.17</a>:</p>
<div class="figure"><span style="display:block;" id="fig:dodging-layering"></span>
<img src="figures/grammar-dodging-layering.png" alt="Two alternative means of displaying partitioned data: dodging and layering." width="750" />
<p class="caption">
Figure 4.17: Two alternative means of displaying partitioned data: dodging and layering.
</p>
</div>
<p>Much has been written about the relative merits of stacking, dodging, and layering. For example, layering is only useful with few categories, as blending many colors can make it difficult to tell the categories apart <span class="citation">(<a href="#ref-franconeri2021">Franconeri et al. 2021</a>; <a href="#ref-wilke2019">Wilke 2019</a>)</span>. Further, in a landmark study, <span class="citation">Cleveland and McGill (<a href="#ref-cleveland1984">1984</a>)</span> showed that people tend to be less accurate when reading information from stacked bar charts as opposed to dodged bar charts (see also Section <a href="background.html#visual-perception">3.3.2</a>). Specifically, since the lower y-axis coordinate of a stacked segment is shifted up by the cumulative height of the segments below, it becomes difficult to accurately compare the segments’ length, both within and across bars <span class="citation">(<a href="#ref-cleveland1984">Cleveland and McGill 1984</a>)</span>. Subsequent research has independently validated these findings and expanded upon them <span class="citation">(see e.g. <a href="#ref-heer2010">Heer and Bostock 2010</a>; <a href="#ref-thudt2016">Thudt et al. 2016</a>; <a href="#ref-quadri2021">Quadri and Rosen 2021</a>)</span>. Due to this suboptimal statistical legibility, many data visualization researchers have urged caution about stacking <span class="citation">(see e.g. <a href="#ref-byron2008">Byron and Wattenberg 2008</a>; <a href="#ref-cairo2014">Cairo 2014</a>; <a href="#ref-franconeri2021">Franconeri et al. 2021</a>)</span>, and some have even discouraged its use altogether <span class="citation">(<a href="#ref-kosara2016">Kosara 2016</a>; <a href="#ref-wilke2019">Wilke 2019</a>)</span>.</p>
<p>However, I contend that, while dodging and layering are indeed valuable techniques for static visualization, stacking offers significant advantages in interactive contexts. The issue comes down to how the three techniques represent the relatedness of data subsets and leverage the Gestalt principles of visual perception (see Section <a href="background.html#visual-perception">3.3.2</a>). Dodged and layered bars, the only indication that two bar segments represent related data subsets is their spatial proximity. In contrast, in stacked bars, related segments are both close together in space (proximity) and also combine together to form a single object bound by a closed contour <span class="citation">(common region, see e.g. <a href="#ref-vanderplas2020">Vanderplas, Cook, and Hofmann 2020</a>; see also <a href="#ref-slingsby2009">Slingsby, Dykes, and Wood 2009</a>)</span>.</p>
<p>Thus, in a stacked barplot, we can interpret individual segments as highlighted <em>parts</em> of a bar, and this subtle property has important implications for the figure’s visual properties and interactive behavior <span class="citation">(see also <a href="#ref-roberts2000">Roberts et al. 2000</a>; <a href="#ref-wilhelm2008">Wilhelm 2008</a>)</span>. More specifically, in the stacked barplot, the heights of the stacked segments sum to the total bar height, providing a fixed upper bound and a clear visual anchor, see Figure <a href="problems.html#fig:stacking-vs-dodging">4.18</a>. These properties become particularly useful when combined with linked selection. Specifically, during selection, even when the heights of the individual segments change, the total bar height remains constant. This leads to a more predictable visual behaviour: we do not have to track the upper edge of the bars or the overall contour since both remain constant. Further, we also know that we can maintain a fixed upper y-axis limits, and this offers a computational advantage since we know we only need to recompute the axis limits <em>when the total bar heights change</em> (e.g. during streaming or when histogram binwidth is modified). Importantly, these advantages extend beyond rectangles (bars): whenever we represent selection by highlighting interior parts of geometric objects, the resulting interaction will behave in a more “consistent” or “natural” manner, and we may be able to take computational shortcuts by caching quantities associated with the whole objects.</p>
<div class="figure"><span style="display:block;" id="fig:stacking-vs-dodging"></span>
<img src="figures/stacking-vs-dodging.png" alt="Stacking has advantages over dodging (and layering) when it comes to displaying linked selection. Plots left to right show simulated static snapshots of more cases being selected (red). In a stacked barplot (top row), the heights of the higlighted segments are always bound by the height of the whole bar, and so the outline of the figure remains constant. In contrast, in a dodged barplot, the bar segment heights are not bounded, leading to the outline of the figure fluctuating dramatically (notice the changing upper y-axis limit)." width="750" />
<p class="caption">
Figure 4.18: Stacking has advantages over dodging (and layering) when it comes to displaying linked selection. Plots left to right show simulated static snapshots of more cases being selected (red). In a stacked barplot (top row), the heights of the higlighted segments are always bound by the height of the whole bar, and so the outline of the figure remains constant. In contrast, in a dodged barplot, the bar segment heights are not bounded, leading to the outline of the figure fluctuating dramatically (notice the changing upper y-axis limit).
</p>
</div>
<p>In contrast, dodging and layering lack this degree of visual consistency. In dodged or layered barplots, the individual bar segments are not bound together in a common region. As a result, the plot contour can fluctuate dramatically with selection, creating significant visual noise (see Figure <a href="problems.html#fig:stacking-vs-dodging">4.18</a>). Research shows that translating and looming stimuli capture attention <span class="citation">(<a href="#ref-franconeri2003">Franconeri and Simons 2003</a>)</span>, and, as such, I contend that the dodged or layered bars may be more visually distracting, due to the fact that less of the figure stays constant throughout interaction. Further, to accommodate the fluctuations in the height of the unbounded bar segments, we are forced to choose between making the upper y-axis limit reactive (erasing the context that the limit provides upon selection), or risking that the segments may grow outside of plotting area. This also has computational implications: if we make the upper y-axis limit reactive, we need to dynamically recompute it on each selection event.</p>
<p>Interestingly, as far as I am aware, there has been little discussion on this topic of perceptual and computational advantages of part-whole object relations and their relationship to interactive graphics. The only two relevant references I have been able to find are Wilhelm <span class="citation">(<a href="#ref-wilhelm2008">Wilhelm 2008</a>)</span> and Sievert <span class="citation">(<a href="#ref-sievert2020">Sievert 2020</a>)</span>. Given the key importance of this topic to the main ideas of the present thesis, I will examine the content of these two references in more detail.</p>
<p>In his chapter of the Handbook of Data Visualization, <span class="citation">Wilhelm (<a href="#ref-wilhelm2008">2008</a>)</span> discusses various aspects and challenges of implementing linked selection. Importantly for this thesis, he outlines three strategies for displaying selection: replacement, overlaying, and repetition. To relate these to the previously discussed techniques (stacking, dodging, and layering), overlaying essentially conflates stacking and layering, repetition is equivalent to dodging, and replacement involves re-rendering the entire visualization from scratch upon selection. Wilhelm notes that replacement is a flawed strategy because it discards important contextual information such as axis limits whenever selection happens. He also argues that repetition is less commonly used due to the necessity of having to re-arrange the plot upon selection. Finally, he identifies two issues with overlaying: the fact that the plot parameters are inherited from the plot representing the whole data set, and the fact that parts of the original plot may become obscured by the highlighted subset (e.g. if we overlay a boxplot box with an opaque box representing selection). Ultimately, he appears to favor repetition over the other two methods.</p>
<p>Sievert <span class="citation">(<a href="#ref-sievert2020">Sievert 2020, chap. 17</a>)</span>, on the other hand, discusses the computational challenges related to rendering linked views with Shiny <span class="citation">(<a href="#ref-shiny2024">Chang et al. 2024</a>)</span> and <code>plotly</code> <span class="citation">(<a href="#ref-plotly2023">Plotly Inc. 2023</a>)</span>. He discusses the problem of making comparisons when plot context (provided by parameters such as axis limits) is lost during selection, and mentions how retaining the context of the “whole bars” improves computational efficiency, since the entire plot does not have to be re-rendered from scratch. To address this, Sievert provides a solution in the form of a fixed “base layer”, which he acknowledges “may seem like a hack”, but provides a better user-experience.</p>
<p>My personal view diverges somewhat from that of <span class="citation">Wilhelm (<a href="#ref-wilhelm2008">2008</a>)</span>, but aligns fairly closely and extends that of <span class="citation">Sievert (<a href="#ref-sievert2020">2020</a>)</span>. Contrary to Wilhelm, I contend that, while less flexible than dodging (repetition), layering, or replacement, stacking (overlaying) is the superior method, since it ensures that the context of the whole data set is always preserved. Conversely, the method favoured by Wilhelm - dodging (repetition) - suffers, in my opinion, from the same contextual information loss as replacement. Specifically, when we draw highlighted subsets as separate side-by-side objects, then, in the general case, we have to make axis limits reactive, discarding contextual information, otherwise we risk the objects growing beyond the plotting region. What <span class="citation">Wilhelm (<a href="#ref-wilhelm2008">2008</a>)</span> sees as one of the problems with stacking (overlaying) - the fact that plot parameters are inherited from the whole data - I instead see as a fundamental strength, similar to <span class="citation">Sievert (<a href="#ref-sievert2020">2020</a>)</span>. Further, I go further than Sievert in positing that the “fixed” base layer should not just be thought of as an accidental workaround, but instead as a fundamental concept. As I argued above, part-whole relations between geometric objects and highlighted segments ensure the preservation of context and may even provide computational advantage. As such, I believe them to be central to the data visualization pipeline. To formalize this idea, it will be necessary to introduce some algebraic ideas, particularly ones from category theory.</p>
</div>
</div>
<div id="aggregation-category-theory" class="section level3 hasAnchor" number="4.3.2">
<h3><span class="header-section-number">4.3.2</span> Stackable summaries: A brief journey into Category Theory<a href="problems.html#aggregation-category-theory" class="anchor-section" aria-label="Anchor link to header"></a></h3>
<p>Let’s briefly recap the key points so far. In section <a href="problems.html#partitioning">4.2</a>, I advocated for modeling plots as a hierarchy of partitions, particularly a preorder of data subsets ordered by set union. Starting with the full data set, we divide it into disjoint subsets, each corresponding to a geometric object. These subsets can then be further subdivided, representing parts of those objects (such as those resulting from linked selection). As discussed in Section <a href="problems.html#hierarchy">4.2.4</a>, we end up with a tree-like structure that encodes this part-whole relationship, which can be formally described as a preorder.</p>
<p>Further, in Section <a href="problems.html#stacking-not-graphical">4.3.1.2</a>, I demonstrated on the example <a href="problems.html#fig:grammar-barplot-maximums">4.16</a> that some “stackable” summary statistics have the property of preserving the part-whole relationships in the data hierarchy, whereas others do not. I have also and pointed to other researchers who have noted this problem. Additionally, I have argued that preserving these part-whole relationship in our visualizations is desirable, particularly when interaction is involved. They simplify certain interactive behaviors, make them more intuitive and “natural,” and reduce the workload interactive data visualization systems need to do.</p>
<p>Now it will be finally time to discuss what makes certain statistics stackable. To do this, I will need to use some concepts from category theory. These concepts are described in greater detail in the <a href="math.html#math">Appendix: Mathematical Theory</a> - the reader is advised to consult this section if they are unfamiliar with the material (links to appropriate sections will also be provided throughout the text). However, first, a quick note on the application of category theory in the data visualization literature.</p>
<div id="visualization-category-theory" class="section level4 hasAnchor" number="4.3.2.1">
<h4><span class="header-section-number">4.3.2.1</span> Past applications of category theory to data visualization<a href="problems.html#visualization-category-theory" class="anchor-section" aria-label="Anchor link to header"></a></h4>
<p>Category theory has seen some limited application to data visualization, in two distinct areas. First, a handful of researchers have used concepts from it to establish broad theoretical frameworks. For instance, <span class="citation">Beckmann (<a href="#ref-beckmann1995">1995</a>)</span>, <span class="citation">Hutchins (<a href="#ref-hutchins1999">1999</a>)</span>, and <span class="citation">Vickers, Faith, and Rossiter (<a href="#ref-vickers2012">2012</a>)</span> had used concepts such as categories, functors, and algebras to define the visualization process conceptually. Similarly, <span class="citation">Kindlmann and Scheidegger (<a href="#ref-kindlmann2014">2014</a>)</span> used functors to define valid perceptual representations of the data, and <span class="citation">Hibbard, Dyer, and Paul (<a href="#ref-hibbard1994">1994</a>)</span> used lattice theory to describe visualization in the presence of incomplete or approximate data (such as finite-precision floating-point numbers).</p>
<p>Second, other researchers have linked category theory and category theory in a more applied way, in the context of functional programming. Specifically, several functional libraries and domain-specific languages (DSLs) for data visualization have been developed over the recent years, using category theory as the foundational programming model. Examples include <span class="citation">Yorgey (<a href="#ref-yorgey2012">2012</a>)</span>, <span class="citation">Petricek (<a href="#ref-petricek2021">2021</a>)</span>, <span class="citation">Smeltzer, Erwig, and Metoyer (<a href="#ref-smeltzer2014">2014</a>)</span>, and <span class="citation">Smeltzer and Erwig (<a href="#ref-smeltzer2018">2018</a>)</span>.</p>
<p>As we will see, the way the present thesis leverages category theory is very different, occupying a middle ground. Compared to the broad theoretical models, it is significantly more applied, focusing on properties of concrete summary statistics and geometric objects, and their relation to interactive features. However, compared to the functional programming libraries, it is more abstract, being independent of any specific programming language or implementation.</p>
</div>
<div id="preorders-categories" class="section level4 hasAnchor" number="4.3.2.2">
<h4><span class="header-section-number">4.3.2.2</span> Generalizing preorders: Categories<a href="problems.html#preorders-categories" class="anchor-section" aria-label="Anchor link to header"></a></h4>
<p>Previously, I had formalized the hierarchy of data subsets as a preorder, an algebraic concept with a structure that we want to preserve. However, to truly formalize the concept of preserving structure, we need to take one more step towards abstraction. Specifically, it is necessary to recast preorders as categories, a fundamental concept in category theory.</p>
<p>The definition of a <a href="math.html#categories">category</a> is quite straightforward. In simple terms, a category <span class="math inline">\(\mathcal{C}\)</span> is just a collection of objects, connected by arrows, that conforms to several properties. More specifically, when we have a category <span class="math inline">\(\mathcal{C}\)</span>:</p>
<ul>
<li>We have a collection of objects <span class="math inline">\(\text{Ob}(\mathcal{C})\)</span></li>
<li>For every pair of objects <span class="math inline">\(c_1, c_2 \in \text{Ob}(\mathcal{C})\)</span>, there is a set of of arrows (morphisms) <span class="math inline">\(c_1 \to c_2\)</span> (this set of arrows is often denoted as <span class="math inline">\(\mathcal{C}(c_1, c_2)\)</span>)</li>
</ul>
<p>Further:</p>
<ul>
<li>Every object <span class="math inline">\(c \in \text{Ob}(\mathcal{C})\)</span> has special arrow <span class="math inline">\(\text{id}_c\)</span> pointing back to itself (called the identity morphism)</li>
<li>Arrows compose. That is, if there is an arrow <span class="math inline">\(f\)</span> from object <span class="math inline">\(c_1\)</span> to object <span class="math inline">\(c_2\)</span>, and an arrow <span class="math inline">\(g\)</span> from object <span class="math inline">\(c_2\)</span> to object <span class="math inline">\(c_3\)</span>, we can define a composite arrow <span class="math inline">\(f ;g\)</span> from <span class="math inline">\(c_1\)</span> to <span class="math inline">\(c_3\)</span></li>
</ul>
<p>Finally, the arrows need to conform to two properties:</p>
<ul>
<li>Composing with the identity morphism leaves arrows unchanged: <span class="math inline">\(\text{id}_{c_1} ;f = f ;\text{id}_{c_2} = f\)</span></li>
<li>Composition is associative: <span class="math inline">\(f ;(g ;h) = (f ;g) ;h = f ;g ;h\)</span></li>
</ul>
<p>For example, the following is a diagram of a simple category with two objects and a single non-identity morphism, called <span class="math inline">\(\underline{\textbf{2}}\)</span>:</p>
<div class="figure"><span style="display:block;" id="fig:category-two1"></span>
<img src="figures/category-two.png" alt="A category with two objects." width="75%" />
<p class="caption">
Figure 4.19: A category with two objects.
</p>
</div>
<p>Here, the morphism <span class="math inline">\(f\)</span> simply means we can get from object 1 (left) to object 2 (right). Based on the rules of a category, we can infer that, for example, <span class="math inline">\((\text{id}_1 ;f) ;\text{id}_2 = \text{id}_1 ;(f ;\text{id}_2) = f\)</span>. As a final note, since the identity arrows are always present, they are often not drawn explicitly in diagrams of categories (however, they are presumed to be there).</p>
<p>Now, what are the objects? What are the arrows? That is all left for us to specify. For example, the objects and arrows could be elements of a set and relations, sets and functions, or even entire categories and a generalizations of functions called functors (which we will discuss later). This abstract nature of categories can be initially difficult to grasp. However, there are some fairly straightforward examples that can help.</p>
<p>A key example, relevant to our discussion, are preorders. Specifically, it can be shown that every preorder is in fact a category. Given a preorder on a set <span class="math inline">\(S\)</span>, define the objects <span class="math inline">\(c \in \text{Ob}(\mathcal{C})\)</span> as the elements in <span class="math inline">\(s \in S\)</span>, and, for any two objects <span class="math inline">\(c_1\)</span> and <span class="math inline">\(c_2\)</span>, define at most one morphism <span class="math inline">\(c_1 \to c_2\)</span> if <span class="math inline">\(c_1 \leq c_2\)</span> (and no morphism if <span class="math inline">\(c_1 \not \leq c_2\)</span>). Then, the two properties of preorders just fall out of the definition of a category:</p>
<ul>
<li>Reflexivity: this is just the identity morphism. For every <span class="math inline">\(c \in \text{Ob}(\mathcal{C})\)</span>, we have <span class="math inline">\(\text{id}_c : c \to c\)</span></li>
<li>Transitivity: this is just composition of morphisms. Given <span class="math inline">\(f: c_1 \to c_2\)</span> (<span class="math inline">\(c_1 \leq c_2\)</span>) and <span class="math inline">\(g: c_2 \to c_3\)</span> (<span class="math inline">\(c_2 \leq c_3\)</span>), we can define <span class="math inline">\(h: c_1 \to c_3\)</span> as <span class="math inline">\(h = f ;g\)</span> (<span class="math inline">\(c_1 \leq c_3\)</span>)</li>
</ul>
<p>In our concrete case of preorder of data subsets ordered by set union, we can easily reuse the diagram from Section <a href="problems.html#plots-as-preorders">4.2.4.1</a> - Figure <a href="problems.html#fig:barplot-preorder2">4.12</a> - and re-intepret it as a category <span class="math inline">\(\mathcal{D}\)</span>:</p>
<div class="figure"><span style="display:block;" id="fig:barplot-preorder222"></span>
<img src="figures/barplot-preorder2.png" alt="A barplot preorder, reinterpreted as a category." width="717" />
<p class="caption">
Figure 4.20: A barplot preorder, reinterpreted as a category.
</p>
</div>
<p>Here, the objects are again just the data subsets, such as the whole data set <span class="math inline">\(D_D\)</span>, the bar subsets <span class="math inline">\(D_{B_i}\)</span>, and the segments <span class="math inline">\(D_{S_j}\)</span>. The morphisms are the arrows indicating set union. As before, the fact that there is an arrow between <span class="math inline">\(D_{S_1}\)</span> and <span class="math inline">\(D_{B_1}\)</span> simply means that Segment 1 can be combined with another set to form Bar 1 (and the absence of an arrow between <span class="math inline">\(D_{S_1}\)</span> and <span class="math inline">\(D_{S_2}\)</span> indicates that segments are disjoint). Identity morphisms are not explicitly shown, but they are of course present (every subset can be combined with the empty set <span class="math inline">\(\varnothing\)</span> to get back the original set). Finally, as mentioned above, reflexivity and transitivity automatically fall out of the definition of a category.</p>
<p>Further, this categorical definition allows us to describe the relationships in the figure in more detail. Whereas in a preorder, there is only at most one relation between any two objects, and the relation is always the same (<span class="math inline">\(\leq\)</span>), in a category, there may be multiple arrows between any two objects, and each set of arrows may be completely different. In our specific case, it first of all allows us to be more explicit about the relations <span class="math inline">\(\cup\)</span>: instead of stating that<span class="math inline">\(\cup\)</span> represents union with some unspecified set, we can explicitly define it as <em>union with all other sibling sets</em> and label the corresponding arrows appropriately. Labeling the entire graph like this would create a lot of visual clutter, however, the following example demonstrates this approach for a portion of the diagram, specifically the subsets corresponding to Bar 1:</p>
<div class="figure"><span style="display:block;" id="fig:barplot-preorder3"></span>
<img src="figures/barplot-preorder3.png" alt="A diagram of a part of the barplot/spineplot category, with all of the morphisms described explictly." width="75%" />
<p class="caption">
Figure 4.21: A diagram of a part of the barplot/spineplot category, with all of the morphisms described explictly.
</p>
</div>
<p>Figure <a href="problems.html#fig:barplot-preorder3">4.21</a> illustrates the simple fact that Bar 1 is formed by combining the data subset of Segment 1 with those of Segments 2 and 3 using the set union operator (and similarly for Segments 2 and 3). In some a, it is simply a more detailed, zoomed-in view of the Figure <a href="problems.html#fig:barplot-preorder2">4.12</a>. We could in fact go further and add nodes representing all pairwise unions of sets, e.g. <span class="math inline">\(D_{S_1} \cup D_{S_2}\)</span>, however, this is not strictly necessary. The important point is that, while before, in Figure <a href="problems.html#fig:barplot-preorder2">4.12</a>, all arrows had to represent the same relation, in Figure <a href="problems.html#fig:barplot-preorder3">4.21</a> the relations are different, and we can even begin to think about having multiple arrows between any pair of objects (for instance, including ones going in the opposite direction).</p>
<p>While the benefits of reinterpreting our data hierarchy in this abstract way may still not be entirely apparent, I encourage the reader to bear with me. In the next sections, I will show the advantages of thinking about our data and visualizations categorically.</p>
</div>
<div id="structure-functors" class="section level4 hasAnchor" number="4.3.2.3">
<h4><span class="header-section-number">4.3.2.3</span> Structure preserving maps: Functors<a href="problems.html#structure-functors" class="anchor-section" aria-label="Anchor link to header"></a></h4>
<p>A second fundamental concept in category theory is that of a structure-preserving map or a <a href="math.html#functors">functor</a>. A functor is a mapping from one category to another which preserves the relationships within the first category <span class="citation">(this can also be thought of as drawing a diagram of the the first category inside the second category, <a href="#ref-fong2019">Fong and Spivak 2019</a>)</span>.</p>
<p>In more precise terms, a functor <span class="math inline">\(F: \mathcal{C} \to \mathcal{D}\)</span> is a mapping from category <span class="math inline">\(\mathcal{C}\)</span> to category <span class="math inline">\(\mathcal{D}\)</span> such that:</p>
<ul>
<li>Every object in <span class="math inline">\(c \in \text{Ob}(\mathcal{C})\)</span> is mapped to some object <span class="math inline">\(d \in \text{Ob}(\mathcal{D})\)</span></li>
<li>Every morphism <span class="math inline">\(f: c_1 \to c_2\)</span> in <span class="math inline">\(\mathcal{C}(c_1, c_2)\)</span> is mapped to some morphism in <span class="math inline">\(\mathcal{D}(F(c_1), F(c_2))\)</span>, i.e. <span class="math inline">\(F(f): F(c_1) \to F(c_2)\)</span></li>
</ul>
<p>Further, this mapping is subject to two fundamental properties:</p>
<ul>
<li>Identities are preserved: <span class="math inline">\(F(\text{id}_c) = \text{id}_{F(c)}\)</span></li>
<li>Composition is too: <span class="math inline">\(F(f ;g) = F(f) ;F(g)\)</span></li>
</ul>
<p>The first property is fairly intuitive and simply states that objects cannot be separated from their identities. The second property is more interesting, since it tells us that all compositions (chains of arrows) must be preserved. Other than that, we are free to map the objects and arrows as we wish. For instance, we can map multiple objects in <span class="math inline">\(\text{Ob}(\mathcal{C})\)</span> to a single object in <span class="math inline">\(\text{Ob}(\mathcal{D})\)</span>, “squish” a morphism (or a chain of morphisms) in <span class="math inline">\(\mathcal{C}\)</span> by mapping it to an identity morphism in <span class="math inline">\(\mathcal{D}\)</span>, or “stretch” a morphism in <span class="math inline">\(\mathcal{C}\)</span> by mapping it to a composite morphism in <span class="math inline">\(\mathcal{D}\)</span>. However, we cannot “rip” or “tear” any morphism or chain of morphisms in <span class="math inline">\(\mathcal{C}\)</span> into multiple morphisms or chains in <span class="math inline">\(\mathcal{D}\)</span>.</p>
<p>This second property of preserving composition can be described by the following commutative diagram:</p>
<div class="figure"><span style="display:block;" id="fig:functor"></span>
<img src="figures/functor.png" alt="A commutative diagram showing how a functor $F$ preserves associativity. $A$, $B$, $C$ are objects in category $\mathcal{C}$, $F(A)$, $F(B)$, $F(C)$ are objects in category $\mathcal{D}$, $f$ and $g$ are morphisms in $\mathcal{C}$, and $F(F)$ and $F(g)$ are objects in $\mathcal{D}$." width="75%" />
<p class="caption">
Figure 4.22: A commutative diagram showing how a functor <span class="math inline">\(F\)</span> preserves associativity. <span class="math inline">\(A\)</span>, <span class="math inline">\(B\)</span>, <span class="math inline">\(C\)</span> are objects in category <span class="math inline">\(\mathcal{C}\)</span>, <span class="math inline">\(F(A)\)</span>, <span class="math inline">\(F(B)\)</span>, <span class="math inline">\(F(C)\)</span> are objects in category <span class="math inline">\(\mathcal{D}\)</span>, <span class="math inline">\(f\)</span> and <span class="math inline">\(g\)</span> are morphisms in <span class="math inline">\(\mathcal{C}\)</span>, and <span class="math inline">\(F(F)\)</span> and <span class="math inline">\(F(g)\)</span> are objects in <span class="math inline">\(\mathcal{D}\)</span>.
</p>
</div>
<p>Here, <span class="math inline">\(A\)</span>, <span class="math inline">\(B\)</span>, and <span class="math inline">\(C\)</span> are three objects in category <span class="math inline">\(\mathcal{C}\)</span> and <span class="math inline">\(F(A)\)</span>, <span class="math inline">\(F(B)\)</span>, and <span class="math inline">\(F(C)\)</span> are the same three objects mapped to category <span class="math inline">\(\mathcal{D}\)</span> (and the same for morphisms <span class="math inline">\(f\)</span> and <span class="math inline">\(g\)</span>). The diagram commuting means that following any two parallel arrows (same source and destination) gives us the same result. For instance, to get from <span class="math inline">\(A\)</span> to <span class="math inline">\(F(C)\)</span>, we may either:</p>
<ul>
<li>Map <span class="math inline">\(A \to C\)</span> (via <span class="math inline">\(f ;g\)</span>) and then apply the functor (<span class="math inline">\(F(\text{id}_C)\)</span>)</li>
<li>Map <span class="math inline">\(A \to B\)</span> (via <span class="math inline">\(f\)</span>), apply the functor (<span class="math inline">\(F(\text{id}_B)\)</span>), and then map <span class="math inline">\(F(B) \to F(C)\)</span> (via <span class="math inline">\(F(g)\)</span>)</li>
<li>Apply the functor immediately (<span class="math inline">\(F(\text{id}_A)\)</span>) and then map <span class="math inline">\(F(A) \to F(C)\)</span> (via <span class="math inline">\(F(f ;g) = F(f) ;F(g)\)</span>)</li>
</ul>
<p>The second property of functors states that all of the above paths must lead to the same object <span class="math inline">\(F(C)\)</span> (if <span class="math inline">\(F\)</span> is a functor).</p>
</div>
<div id="aggregation-functor" class="section level4 hasAnchor" number="4.3.2.4">
<h4><span class="header-section-number">4.3.2.4</span> Aggregation: A functor from data subsets to summary statistics<a href="problems.html#aggregation-functor" class="anchor-section" aria-label="Anchor link to header"></a></h4>
<p>As we have established before, when visualizing data, we may start with the category/preorder of data subsets ordered by sibling subset union, as in Figure <a href="problems.html#fig:barplot-preorder2">4.12</a> (reproduced below for reminder). We would like to translate these data subsets into summary statistics, in a way that preserves the inherent structure in the data. As we will see, the appropriate way to do this is via a functor.</p>

<div class="figure"><span style="display:block;" id="fig:barplot-preorder22"></span>
<img src="figures/barplot-preorder2.png" alt="Reproduction of Figure 4.12: Diagram of the barplot/spineplot preorder (category), ordered by set union." width="717" />
<p class="caption">
Figure 4.23: Reproduction of Figure <a href="problems.html#fig:barplot-preorder2">4.12</a>: Diagram of the barplot/spineplot preorder (category), ordered by set union.
</p>
</div>
<p>But first, let’s discuss the summary statistics. Since we want to summarize each data subset, then, it is given that we should end up with an equal number of summaries. For instance, if <span class="math inline">\(D = \{ D_D, D_{B_1}, \ldots D_{B_n}, D_{S_1}, \ldots, D_{S_k} \}\)</span> is the set of data subsets corresponding to the whole data set, bars, and segments, respectively, and <span class="math inline">\(S\)</span> is the set of summaries, then <span class="math inline">\(\lvert D \lvert = \lvert S \lvert\)</span>. Further, since the elements of <span class="math inline">\(D\)</span> are actually objects in a category (<span class="math inline">\(\mathcal{D}\)</span>), then, intuitively, <span class="math inline">\(S\)</span> should be a part of a category as well, let’s call it <span class="math inline">\(\mathcal{S}\)</span>.</p>
<p>If the elements of <span class="math inline">\(S\)</span> are objects in a category <span class="math inline">\(\mathcal{S}\)</span>, what should be the morphisms? In the category of data subsets <span class="math inline">\(\mathcal{D}\)</span>, the morphisms are given by union with the sibling subsets. In the category of summaries, we want the morphisms to reflect some operation that “behaves like set union”, such that it represents the operation of <em>combining sibling summaries</em>. We can label this operation with the symbol <span class="math inline">\(\otimes\)</span>, such that the resulting category looks as follows:</p>
<div class="figure"><span style="display:block;" id="fig:barplot-preorder4"></span>
<img src="figures/barplot-preorder4.png" alt="A diagram of barplot/spineplot summary statistic preorder/category, ordered by the combination operator $\otimes$." width="686" />
<p class="caption">
Figure 4.24: A diagram of barplot/spineplot summary statistic preorder/category, ordered by the combination operator <span class="math inline">\(\otimes\)</span>.
</p>
</div>
<p>As before, each <span class="math inline">\(\otimes\)</span> in the diagram above corresponds to the operation of combining a summary with the other sibling summaries, such that, for example, the label for the arrow <span class="math inline">\(S_{S_1} \to S_{B_1}\)</span> should be <span class="math inline">\(- \otimes S_{S_1} \otimes S_{S_2}\)</span>. In words, “a segment summary combines into a bar summary”.</p>
<p>Now comes the key point. Suppose that we have some summary operation <span class="math inline">\(F: D \to S\)</span> which maps data subsets to summaries. To preserve the structure of <span class="math inline">\(\mathcal{D}\)</span>, <span class="math inline">\(F\)</span> has to be a functor <span class="math inline">\(F: \mathcal{D} \to \mathcal{S}\)</span>, mapping data subsets in <span class="math inline">\(D\)</span> to summaries in <span class="math inline">\(S\)</span> and set unions <span class="math inline">\(D_i \cup D_j\)</span> to combinations of summaries <span class="math inline">\(S_i \otimes S_j\)</span>, such that composition and identities are preserved. Specifically, by substituting our morphisms into the composition-preserving property of functors:</p>
<p><span class="math display">\[F(- \cup D_{i} ;- \cup D_{j}) = F(- \cup D_i) ;F(- \cup D_j)\]</span></p>
<p>The expression above appears somewhat unwieldy due to the mixing of function expressions with the binary operator <span class="math inline">\(\cup\)</span> and the composition operator <span class="math inline">\(;\)</span>. However, <span class="math inline">\(- \cup D_i\)</span> and <span class="math inline">\(- \cup D_j\)</span> are just morphisms, so if we had instead labeled these as <span class="math inline">\(f\)</span> and <span class="math inline">\(g\)</span>, we could rewrite the same expression as <span class="math inline">\(F(f ;g) = F(f) ;F(g)\)</span> and it would still express the same idea. Even better however, we can greatly simplify the expression by noting two facts:</p>
<ul>
<li><span class="math inline">\(F(- \cup D_i ) = - \otimes F(D_i)\)</span>. This follows from the definition of our functor: the union operator in the data category is mapped to combining summaries in the summary category.</li>
<li>We can omit the composition operator <span class="math inline">\(;\)</span>. This is due to the fact that <span class="math inline">\(\cup\)</span> and <span class="math inline">\(\otimes\)</span> are associative binary operators (associativity follows from the definition of composition in categories). As an example, if <span class="math inline">\(f(x) = - \otimes 2 = x + 2\)</span>, then we can write <span class="math inline">\([f ;f](x) = f(f(x)) = ((x + 2) + 2) = x + 2 + 2\)</span>.</li>
</ul>
<p>This leads to the following simplification:</p>
<p><span class="math display">\[F(- \cup D_i \cup D_j) = - \otimes F(D_i) \otimes F(D_j)\]</span></p>
<p>Finally, without loss of generality, we can choose the empty set <span class="math inline">\(\varnothing\)</span> as the operand (<span class="math inline">\(-\)</span>), and then the equation reduces to:</p>
<p><span class="math display" id="eq:summary-functor-composition">\[\begin{equation}
F(D_i \cup D_j) = F(D_i) \otimes F(D_j)
\tag{4.1}
\end{equation}\]</span></p>
<p>In other words, when summarizing data, <em>it should not matter whether we first take the union of the underlying data and then summarize the resulting superset, or first summarize the subsets and then combine the summaries via the combination operator <span class="math inline">\(\otimes\)</span> (i.e. the summary should distribute across set union)</em>.</p>
<p>Finally, we should note that, to be fully functorial, the operation should also preserve identities:</p>
<p><span class="math display" id="eq:summary-functor-identity">\[\begin{equation}
F(\text{id}_{D_i}) = \text{id}_{F(D_i)}
\tag{4.2}
\end{equation}\]</span></p>
</div>
<div id="functorial-summaries-and-set-union" class="section level4 hasAnchor" number="4.3.2.5">
<h4><span class="header-section-number">4.3.2.5</span> Functorial summaries and set union<a href="problems.html#functorial-summaries-and-set-union" class="anchor-section" aria-label="Anchor link to header"></a></h4>
<p>Let’s explore the functoriality of summary statistics in more concrete terms. First, as was mentioned in Section <a href="problems.html#plots-as-preorders">4.2.4.1</a>, the identity morphism for a data subset is just union with the empty set, <span class="math inline">\(- \cup \varnothing\)</span>. Therefore, preserving identities as per Equation <a href="problems.html#eq:summary-functor-identity">(4.2)</a> amounts to:</p>
<p><span class="math display">\[\begin{align}
F(\text{id}_{D_i}) &amp;= F(D_i \cup \varnothing) \\
                   &amp;= F(D_i) \otimes F(\varnothing) \\
                   &amp;= F(D_i) \otimes e \\
                   &amp;= F(D_i) = \text{id}_{F(D_i)}
\end{align}\]</span></p>
<p>This means that the summary operation <span class="math inline">\(F\)</span> must be defined for the empty set, and should return some “neutral” element <span class="math inline">\(F(\varnothing) = e \in S\)</span>, which, when combined with any other summary, just returns the same summary back.</p>
<p>Second, as per Equation <a href="problems.html#eq:summary-functor-composition">(4.1)</a>, the summary operation should distribute across set union via the combination operator <span class="math inline">\(\otimes\)</span>:</p>
<p><span class="math display">\[F(D_i \cup D_j) = F(D_i) \otimes F(D_j)\]</span></p>
<p>This distributive property needs to hold over <em>all</em> disjoint subsets of the data as these correspond to all possible arrows we can draw in the set union diagram of the data subset preorder (Figure <a href="problems.html#fig:barplot-preorder2">4.12</a>). Further, given any set <span class="math inline">\(D_i \in D\)</span>, the smallest possible (non-empty) disjoint subset is a single data point (row) <span class="math inline">\(d_j \in D_i\)</span>. Thus, the summary operation should distribute over individual data points:</p>
<p><span class="math display">\[F(d_1 \cup d_2 \cup \ldots \cup d_n) = F(d_1) \otimes F(d_2) \otimes \ldots \otimes F(d_n)\]</span></p>
<p>Thus, from a certain point of view, <span class="math inline">\(F\)</span> <em>is</em> the binary combination operator <span class="math inline">\(\otimes\)</span>. For instance, if we take <span class="math inline">\(D\)</span> to be a subset of real numbers, <span class="math inline">\(D \subseteq \mathbb{R}\)</span>, and the operation <span class="math inline">\(\otimes\)</span> to be addition, then we can simply write:</p>
<p><span class="math display">\[F(d_1 \cup d_2 \cup \ldots d_k) = d_1 + d_2 + \ldots d_n\]</span></p>
<p>Things become slightly more complicated when <span class="math inline">\(D\)</span> represents more generic, heterogeneous data, i.e. when <span class="math inline">\(d_i \in D\)</span> are tuples (rows). Then, the summary functor <span class="math inline">\(F\)</span> may also “lift” values out of the tuple, and so the <span class="math inline">\(\otimes\)</span> operator would need to perform this lifting while remaining closed under repeated application. For illustration, in code, if we wanted to summarize a data frame by iterating over rows and summing a single numeric variable named <code>x</code>, we would need to write something like the following:</p>
<div class="sourceCode" id="cb21"><pre class="sourceCode r"><code class="sourceCode r"><span id="cb21-1"><a href="problems.html#cb21-1" tabindex="-1"></a>df <span class="ot">&lt;-</span> <span class="fu">data.frame</span>(<span class="at">x =</span> <span class="dv">1</span><span class="sc">:</span><span class="dv">3</span>, <span class="at">y =</span> letters[<span class="dv">1</span><span class="sc">:</span><span class="dv">3</span>])</span>
<span id="cb21-2"><a href="problems.html#cb21-2" tabindex="-1"></a>rows <span class="ot">&lt;-</span> <span class="fu">split</span>(df, <span class="dv">1</span><span class="sc">:</span><span class="dv">3</span>) <span class="co"># Want to iterate the data row-wise</span></span>
<span id="cb21-3"><a href="problems.html#cb21-3" tabindex="-1"></a></span>
<span id="cb21-4"><a href="problems.html#cb21-4" tabindex="-1"></a>                                     <span class="co"># Either sum, or sum + lift</span></span>
<span id="cb21-5"><a href="problems.html#cb21-5" tabindex="-1"></a>pick_sum <span class="ot">&lt;-</span> <span class="cf">function</span>(s, d) <span class="fu">ifelse</span>(<span class="fu">is.numeric</span>(d), s <span class="sc">+</span> d, s <span class="sc">+</span> d<span class="sc">$</span>x)</span>
<span id="cb21-6"><a href="problems.html#cb21-6" tabindex="-1"></a><span class="fu">Reduce</span>(pick_sum, rows, <span class="dv">0</span>)</span></code></pre></div>
<pre><code>## [1] 6</code></pre>
<p>However, this is more of a technical detail. The key point is that we can encode everything we need about the summarizing function <span class="math inline">\(F\)</span> into the binary operator <span class="math inline">\(\otimes\)</span>. To further illustrate this, we can also follow the equality the other way, starting with combining the summaries of two data subsets <span class="math inline">\(F(D_i)\)</span> and <span class="math inline">\(F(D_j)\)</span>. Then:</p>
<p><span class="math display">\[\begin{align}
F(D_i) \otimes F(D_j) &amp;= (d_{i1} \otimes d_{i2} \otimes \ldots d_{in}) \otimes (d_{j1} \otimes d_{j1} \otimes \ldots d_{jk}) \\
&amp;= d_{i1} \otimes d_{i2} \otimes \ldots d_{in} \otimes d_{j1} \otimes d_{j1} \otimes \ldots d_{jk} \qquad \text{(by associativity)} \\
&amp;= F(D_i \cup D_j)
\end{align}\]</span></p>
<p>Again, this shows that combining summaries leads to a valid summary of the underlying set union, which is precisely the desired property we set out to find.</p>
<p>Finally, we can also consider the case when <span class="math inline">\(F\)</span> is <em>not</em> functorial, i.e. <span class="math inline">\(F(D_i \cup D_j) \neq F(D_i) \otimes F(D_j)\)</span>. This corresponds to a situation where the summary of the superset somehow contains some additional “non-additive” information that the summaries of either of the two subsets do not. More generally, these situation where the <em>whole is more than “sum” of its parts</em> are called an <em>interactive</em> or <em>generative effects</em> <span class="citation">(<a href="#ref-adam2017">Adam 2017</a>; <a href="#ref-fong2019">Fong and Spivak 2019</a>)</span>. Generative effects apply to a broader class of mappings than just the specific case with set union we have outlined here, however, the idea of (not) preserving composition (<span class="math inline">\(F(f ;g) \neq F(f) ;F(g)\)</span>) is the same. For our summary statistics to be well-behaved under features like linked selection, they should <em>not</em> have any kind of generative effect.</p>
</div>
<div id="monoids" class="section level4 hasAnchor" number="4.3.2.6">
<h4><span class="header-section-number">4.3.2.6</span> Whole equal to the sum of its parts: Monoids<a href="problems.html#monoids" class="anchor-section" aria-label="Anchor link to header"></a></h4>
<p>Above, I have argued that, for plots to be well-behaved under certain kinds of interactions such as linked selection, the summary statistics we display should <em>“behave like set union”</em>. Specifically, they should be a functor from the preorder of data subsets, such that combining two summaries gives the same result as summarizing the union of the underlying data. Conversely, the summary of the union should result in no non-additive “surprises” or generative effects.</p>
<p>The framing of the summary mapping <span class="math inline">\(F\)</span> as functor has lead to two key insights: the summary statistic should be based on some binary associative operation <span class="math inline">\(\otimes\)</span>, and the summarized values should be equipped with some “neutral” value that is the result of summarizing an empty set. It turns out there is a well-known algebraic structure with these exact properties: a monoid.</p>
<p>Formally, a monoid <span class="math inline">\((M, e, \otimes)\)</span> is a set <span class="math inline">\(M\)</span> equipped with a binary operation <span class="math inline">\(\otimes\)</span> and a special neutral element <span class="math inline">\(e\)</span>, such that the operation is:</p>
<ul>
<li>Unital: <span class="math inline">\(m \otimes e = e \otimes m = m\)</span> for all <span class="math inline">\(m \in M\)</span></li>
<li>Associative: <span class="math inline">\((m_1 \otimes m_2) \otimes m_3 = m_1 \otimes (m_2 \otimes m_3) = m_1 \otimes m_2 \otimes m_3\)</span></li>
</ul>
<p>These are exactly the properties we were looking for. In other words, if the summary statistic is a monoid, it behaves like set union. The summary functor <span class="math inline">\(F\)</span> then just acts the following way:</p>
<ul>
<li>For the empty set, it just returns the neutral value: <span class="math inline">\(F(\varnothing) = e\)</span></li>
<li>For a non-empty set <span class="math inline">\(D_i\)</span>, it “folds” the set by repeatedly applying the combination operator: <span class="math inline">\(F(D_i) = F(\{d_{i1} , d_{i2}, \ldots, d_{in} \}) = d_{i1} \otimes d_{i2} \otimes \ldots \otimes d_{in}\)</span></li>
</ul>
<p>Monoids are well-known in category theory and functional programming. When <span class="math inline">\(M\)</span> is the set of real numbers, a typical example is the summation <span class="math inline">\((\mathbb{R}, 0, +)\)</span> (which we are familiar with as the “default” summary statistic in typical barplots). Other examples include the product <span class="math inline">\((\mathbb{R}, 1, \cdot)\)</span> and maximum operators <span class="math inline">\((\mathbb{R}, \max, -\infty)\)</span>. However, the set <span class="math inline">\(M\)</span> does not have to be only numbers. For example, the set of strings with the concatenation operator <span class="math inline">\(\text{++}\)</span> and the empty string <span class="math inline">\(\text{&quot;&quot;}\)</span> as the neutral element forms a valid monoid:</p>
<p><span class="math display">\[\text{&quot;hello&quot; ++ &quot;&quot;} = \text{&quot;&quot; ++ &quot;hello&quot; } = \text{&quot;hello&quot;} \]</span>
<span class="math display">\[\begin{align}
\text{&quot;quick &quot; ++ (&quot; brown&quot; ++ &quot; fox&quot;)} &amp;= \text{(&quot;quick &quot; ++ &quot; brown &quot;) ++ &quot; fox&quot;} \\
&amp;= \text{&quot;quick brown fox&quot;}
\end{align}\]</span></p>
<p>While most summary statistics we care about in data visualization are quantitative, the fact that some non-numeric data summaries can behave like set union may be still interesting to ponder.</p>
<p>Further, even the set union <span class="math inline">\(\cup\)</span> operation itself forms a monoid, with the empty set <span class="math inline">\(\varnothing\)</span> as the neutral/identity element. Thus, in a certain way, the mapping of data subsets to summaries <span class="math inline">\(F\)</span> can be seen as a mapping between two monoids: a <em>monoid homomorphism</em> (which is just an abstract algebra term for a functor between monoids). However, <span class="math inline">\(F\)</span> is more than just a monoid homomorphism; monoids alone do not capture the hierarchical structure of <span class="math inline">\(\mathcal{D}\)</span> and <span class="math inline">\(\mathcal{P}\)</span>. Instead, <span class="math inline">\(F\)</span> is a mapping between two categories that have the features of both a monoid <em>and</em> preorder. As a sidenote, a monoid that is also a preorder is called, unsurprisingly, a <em>monoidal preorder</em> <span class="citation">(<a href="#ref-nlab2024e">nLab 2025</a>)</span>. Thus, <span class="math inline">\(F\)</span> could technically be called a <em>“monoidal preorder homomorphism”</em>, however, I believe it is far easier and clearer to simply refer to <span class="math inline">\(F\)</span> as a functor.</p>
<p>As a final note, a key consequence of the associativity of monoids is linearizability. Specifically, an arbitrary expression tree built with an associative binary function <span class="math inline">\(f\)</span>, e.g. <span class="math inline">\(f(f(x, y), f(z, f(u, w)))\)</span> can always be rewritten as a linear sequence of steps (e.g. <span class="math inline">\(f(x, f(y, f(z, f(u, w))))\)</span>). This effectively flattens the expression tree into a linear chain <span class="citation">(<a href="#ref-adam2017">Adam 2017</a>)</span>.</p>
</div>
<div id="programming-with-monoids" class="section level4 hasAnchor" number="4.3.2.7">
<h4><span class="header-section-number">4.3.2.7</span> Programming with monoids<a href="problems.html#programming-with-monoids" class="anchor-section" aria-label="Anchor link to header"></a></h4>
<p>Monoids translate well to code and are in fact frequently used in programming, particularly functional and generic programming <span class="citation">(see e.g. <a href="#ref-milewski2018">Milewski 2018</a>; <a href="#ref-stepanov2009">Stepanov and McJones 2009</a>; <a href="#ref-stepanov2014">Stepanov and Rose 2014</a>)</span>. Further, with few assumptions, we can even directly test whether an arbitrary summary function conforms to a monoid. For instance, in R, if we replace the set union operation with vector/array concatenation (the <code>c()</code> function), and provided that we have some three representative data vectors <code>x</code>, <code>y</code>, and <code>z</code>, we can test associativity as follows:</p>
<div class="sourceCode" id="cb23"><pre class="sourceCode r"><code class="sourceCode r"><span id="cb23-1"><a href="problems.html#cb23-1" tabindex="-1"></a>x <span class="ot">&lt;-</span> <span class="dv">1</span><span class="sc">:</span><span class="dv">10</span></span>
<span id="cb23-2"><a href="problems.html#cb23-2" tabindex="-1"></a>y <span class="ot">&lt;-</span> <span class="dv">11</span><span class="sc">:</span><span class="dv">20</span></span>
<span id="cb23-3"><a href="problems.html#cb23-3" tabindex="-1"></a>z <span class="ot">&lt;-</span> <span class="dv">21</span><span class="sc">:</span><span class="dv">30</span></span>
<span id="cb23-4"><a href="problems.html#cb23-4" tabindex="-1"></a></span>
<span id="cb23-5"><a href="problems.html#cb23-5" tabindex="-1"></a><span class="co">#     F(f; g)       =     F(f);F(g)</span></span>
<span id="cb23-6"><a href="problems.html#cb23-6" tabindex="-1"></a><span class="fu">sum</span>(<span class="fu">c</span>(<span class="fu">c</span>(x, y), z)) <span class="sc">==</span> <span class="fu">sum</span>(<span class="fu">c</span>(<span class="fu">sum</span>(<span class="fu">c</span>(x, y)), z))</span>
<span id="cb23-7"><a href="problems.html#cb23-7" tabindex="-1"></a><span class="fu">mean</span>(<span class="fu">c</span>(<span class="fu">c</span>(x, y), z)) <span class="sc">==</span> <span class="fu">mean</span>(<span class="fu">c</span>(<span class="fu">mean</span>(<span class="fu">c</span>(x, y)), z))</span></code></pre></div>
<pre><code>## [1] TRUE
## [1] FALSE</code></pre>
<p>Likewise, we can easily test the unitality property for a given neutral element <code>e</code>. We could even create a wrapper function to test whether a given function with a neutral element forms monoid:</p>
<div class="sourceCode" id="cb25"><pre class="sourceCode r"><code class="sourceCode r"><span id="cb25-1"><a href="problems.html#cb25-1" tabindex="-1"></a>is_unital <span class="ot">&lt;-</span> <span class="cf">function</span>(fn, e, x) {</span>
<span id="cb25-2"><a href="problems.html#cb25-2" tabindex="-1"></a>  <span class="co"># Test two-sided unitality</span></span>
<span id="cb25-3"><a href="problems.html#cb25-3" tabindex="-1"></a>  (<span class="fu">fn</span>(<span class="fu">c</span>(e, x)) <span class="sc">==</span> <span class="fu">fn</span>(<span class="fu">c</span>(x, e))) <span class="sc">&amp;&amp;</span> (<span class="fu">fn</span>(<span class="fu">c</span>(e, x)) <span class="sc">==</span> <span class="fu">fn</span>(x))</span>
<span id="cb25-4"><a href="problems.html#cb25-4" tabindex="-1"></a>}</span>
<span id="cb25-5"><a href="problems.html#cb25-5" tabindex="-1"></a></span>
<span id="cb25-6"><a href="problems.html#cb25-6" tabindex="-1"></a>is_associative <span class="ot">&lt;-</span> <span class="cf">function</span>(fn, x, y, z) {</span>
<span id="cb25-7"><a href="problems.html#cb25-7" tabindex="-1"></a>  <span class="fu">fn</span>(<span class="fu">c</span>(<span class="fu">c</span>(x, y), z)) <span class="sc">==</span> <span class="fu">fn</span>(<span class="fu">c</span>(<span class="fu">fn</span>(<span class="fu">c</span>(x, y)), z))</span>
<span id="cb25-8"><a href="problems.html#cb25-8" tabindex="-1"></a>}</span>
<span id="cb25-9"><a href="problems.html#cb25-9" tabindex="-1"></a></span>
<span id="cb25-10"><a href="problems.html#cb25-10" tabindex="-1"></a>is_monoid <span class="ot">&lt;-</span> <span class="cf">function</span>(fn, e, x, y, z) {</span>
<span id="cb25-11"><a href="problems.html#cb25-11" tabindex="-1"></a>  <span class="fu">is_unital</span>(fn, e, x) <span class="sc">&amp;&amp;</span> <span class="fu">is_associative</span>(fn, x, y, z)</span>
<span id="cb25-12"><a href="problems.html#cb25-12" tabindex="-1"></a>}</span>
<span id="cb25-13"><a href="problems.html#cb25-13" tabindex="-1"></a></span>
<span id="cb25-14"><a href="problems.html#cb25-14" tabindex="-1"></a>string_concat <span class="ot">&lt;-</span> <span class="cf">function</span>(x) <span class="fu">paste0</span>(x, <span class="at">collapse =</span> <span class="st">&quot;&quot;</span>)</span>
<span id="cb25-15"><a href="problems.html#cb25-15" tabindex="-1"></a>l2_norm <span class="ot">&lt;-</span> <span class="cf">function</span>(x) <span class="fu">sqrt</span>(<span class="fu">sum</span>(x<span class="sc">^</span><span class="dv">2</span>)) <span class="co"># aka euclidean distance</span></span>
<span id="cb25-16"><a href="problems.html#cb25-16" tabindex="-1"></a></span>
<span id="cb25-17"><a href="problems.html#cb25-17" tabindex="-1"></a><span class="fu">is_monoid</span>(sum, <span class="dv">0</span>, x, y, z)</span>
<span id="cb25-18"><a href="problems.html#cb25-18" tabindex="-1"></a><span class="fu">is_monoid</span>(max, <span class="sc">-</span><span class="cn">Inf</span>, x, y, z)</span>
<span id="cb25-19"><a href="problems.html#cb25-19" tabindex="-1"></a><span class="fu">is_monoid</span>(prod, <span class="dv">1</span>, x, y, z)</span>
<span id="cb25-20"><a href="problems.html#cb25-20" tabindex="-1"></a><span class="fu">is_monoid</span>(string_concat, <span class="st">&quot;&quot;</span>, <span class="st">&quot;a&quot;</span>, <span class="st">&quot;b&quot;</span>, <span class="st">&quot;c&quot;</span>)</span>
<span id="cb25-21"><a href="problems.html#cb25-21" tabindex="-1"></a><span class="fu">is_monoid</span>(l2_norm, <span class="dv">0</span>, x, y, z)</span>
<span id="cb25-22"><a href="problems.html#cb25-22" tabindex="-1"></a><span class="fu">is_monoid</span>(mean, <span class="dv">0</span>, x, y, z)</span>
<span id="cb25-23"><a href="problems.html#cb25-23" tabindex="-1"></a><span class="fu">is_monoid</span>(median, <span class="dv">0</span>, x, y, z)</span>
<span id="cb25-24"><a href="problems.html#cb25-24" tabindex="-1"></a><span class="fu">is_monoid</span>(sd, <span class="dv">0</span>, x, y, z)</span></code></pre></div>
<pre><code>## [1] TRUE
## [1] TRUE
## [1] TRUE
## [1] TRUE
## [1] TRUE
## [1] FALSE
## [1] FALSE
## [1] FALSE</code></pre>
<p>A couple of points. First, based on what we have shown before, we could simplify our task by defining <code>fn</code> as a binary function which takes two (scalar) arguments instead of a vector. This binary formulation would demonstrate that, for example, <code>mean2 == median2 == function(x, y) (x + y) / 2</code> (median of even number of elements is the average of the middle two), and so if we can show that <code>(x + y) / 2</code> is not associative, we disprove both <code>mean2</code> and <code>median2</code> being monoids. More intuitively, with three or more values, applying <code>median2</code> amounts to repeatedly averaging values pairwise, and this operation is clearly different from picking the middle value. Furthermore, the binary formulation of <code>fn</code> also makes it easier to identify whether neutral element <code>e</code> exists or not. For instance, it is not difficult to see that there is no (constant) value <code>e</code> such that <code>(x + e) / 2 == x</code> for all <code>x</code>. Thus, generally, it might be more advantageous to always formulate <code>fn</code> as a binary function. However, in the code block above, I used the vector formulation to allow for comparison with R standard library functions such as <code>mean</code>, <code>median</code>, and <code>sd</code>.</p>
<p>Second, the properties of associativity and unitality need to hold for <em>all</em> possible inputs in the function’s domain. Thus, if a function passes the <code>is_monoid</code> test for any three specific values, this is not sufficient for proving that it is monoidal. For instance, while it is the case that <code>mean(c(c(2, 4), 3)) == mean(c(mean(c(2, 4)), 3))</code>, this does not prove that <code>mean</code> is associative<a href="#fn5" class="footnote-ref" id="fnref5"><sup>5</sup></a>. However, a single counter-example does definitely prove that a summary function is <em>not</em> monoid, as is the case, for example, with <code>mean</code>, <code>median</code>, and <code>sd</code> functions above. Thus, while not a fool-proof method, functions like <code>is_monoid</code> function can serve as a valuable sanity check.</p>
<p>Finally, monoids also imply certain computational advantages. Specifically, because the operation of reducing a set of <span class="math inline">\(n\)</span> elements via a monoid translates into <span class="math inline">\(n - 1\)</span> binary operations, we know we can always compute the result in linear (<span class="math inline">\(O(n)\)</span>) time (provided that the product <span class="math inline">\(\otimes\)</span> itself is constant). Additionally, due to associativity, monoids are easily parallelizable (embarassingly parallel), making them useful in distributed computing strategies such as MapReduce <span class="citation">(<a href="#ref-lin2013">Lin 2013</a>)</span>. Finally, when the total product consists of repeated products of the same element (i.e. <span class="math inline">\(a \otimes a \otimes a \otimes \ldots\)</span>), the result can be computed in sub-linear <span class="math inline">\(O(\log n)\)</span> time, by applying the squaring algorithm <span class="citation">(also known as the Russian peasant or Egyptian multiplication algorithm, see <a href="#ref-stepanov2009">Stepanov and McJones 2009</a>; <a href="#ref-stepanov2014">Stepanov and Rose 2014</a>)</span>.</p>
</div>
<div id="groups-inverses" class="section level4 hasAnchor" number="4.3.2.8">
<h4><span class="header-section-number">4.3.2.8</span> Groups and inverses<a href="problems.html#groups-inverses" class="anchor-section" aria-label="Anchor link to header"></a></h4>
<p>Suppose we have our summary functor <span class="math inline">\(F\)</span> which summarizes a data subset <span class="math inline">\(D_i\)</span> by repeatedly applying some monoidal operation <span class="math inline">\(\otimes\)</span>. As we have shown, given two data subsets <span class="math inline">\(D_i\)</span> and <span class="math inline">\(D_j\)</span>, <span class="math inline">\(F(D_i) \otimes F(D_j) = F(D_i \cup D_j)\)</span>. More concretely, with data subsets <span class="math inline">\(D_1, D_2, D_3, \ldots\)</span>, it is the case that, for example:</p>
<p><span class="math display">\[\begin{align}
&amp;F(D_1) = F(D_1) \\
&amp;F(D_1) \otimes F(D_2) = F(D_1 \cup D_2) \\
&amp;F(D_1) \otimes F(D_2) \otimes F(D_3) = F(D_1 \cup D_2 \cup D_3) \\
&amp;F(D_1) \otimes F(D_2) \otimes F(D_3) \otimes \ldots = F(D_1 \cup D_2 \cup D_3 \cup \ldots)
\end{align}\]</span></p>
<p>Now, comparing the statistic <span class="math inline">\(F(D_1)\)</span> with <span class="math inline">\(F(D_1) \otimes F(D_2)\)</span> amounts to comparing the summaries of <span class="math inline">\(D_1\)</span> with that of <span class="math inline">\(D_1 \cup D_2\)</span>. For instance, in a barplot where <span class="math inline">\(D_{S_1}\)</span> and <span class="math inline">\(D_{S_2}\)</span> represent segment subsets that together form a bar subset, <span class="math inline">\(D_{B_1} = D_{S_1} \cup D_{S_2}\)</span>, comparing <span class="math inline">\(F(D_{S_1})\)</span> and <span class="math inline">\(F(D_{S_1}) \otimes F(D_{S_2})\)</span> amounts to comparing the summary on the subset <span class="math inline">\(D_{S_1}\)</span> with that of <span class="math inline">\(D_{S_1} \cup D_{S_2}\)</span>, i.e. the summary of all cases in the bar.</p>
<p>Why is this important? It is critical to note that <em>comparing <span class="math inline">\(D_i\)</span> with <span class="math inline">\(D_i \cup D_j\)</span> is different from comparing <span class="math inline">\(D_i\)</span> with <span class="math inline">\(D_j\)</span> directly</em>. That is, while <span class="math inline">\(F(D_i) \otimes F(D_j) = F(D_i \cup D_j)\)</span> is a valid summary of <span class="math inline">\(D_i \cup D_j\)</span>, <em>there is no guarantee that we will be able to recover <span class="math inline">\(F(D_j)\)</span> from it</em>. In other words, <span class="math inline">\(F(D_i) \otimes F(D_j)\)</span> may collapse information contained in either <span class="math inline">\(F(D_i)\)</span> or <span class="math inline">\(F(D_j)\)</span> individually. If we want to use the combined summary <span class="math inline">\(F(D_i) \otimes F(D_j) = F(D_i \cup D_j)\)</span> to compare <span class="math inline">\(D_i\)</span> and <span class="math inline">\(D_j\)</span> <em>as disjoint subsets</em>, then we also require the presence of an inverse operator <span class="math inline">\(\otimes^{-1}\)</span>, such that:</p>
<p><span class="math display">\[F(D_i) \otimes F(D_j) = F(D_i \cup D_j) \iff F(D_i \cup D_j) \otimes^{-1} F(D_j) = F(D_i)\]</span></p>
<p>Specifically, at times, we may also want some inverse operator <span class="math inline">\(\otimes^{-1}\)</span> that would allow our statistic <em>to also preserve/distribute over set difference</em> (<span class="math inline">\(\setminus\)</span>). Specifically, we could imagine taking the diagram in Figure <a href="problems.html#fig:barplot-preorder2">4.12</a> and adding a second set of arrows pointing in the opposite direction, labeled with <span class="math inline">\(\setminus\)</span>. Then, for <span class="math inline">\(F\)</span> to be a functor, it would have to preserve the composition of these set difference arrows as well.</p>
<p>Fortunately, we do not have to search for a monoid with an inverse operator; this is precisely the definition of another class of algebraic structures: groups. Groups are well-studied in group theory and subject to many interesting results <span class="citation">(see e.g., <a href="#ref-pinter2010">Pinter 2010</a>)</span>. However, for our purposes here, a group is just a monoid equipped with the inverse operator <span class="math inline">\(\otimes^{-1}\)</span>, such that:</p>
<p><span class="math display">\[x \otimes y = z \iff (z \otimes^{-1} x = y) \wedge (z \otimes^{-1} y = x)\]</span></p>
<p>When the inverse operator is not present, we can still compare <span class="math inline">\(D_i\)</span> with <span class="math inline">\(D_i \cup D_j\)</span>, however, direct comparisons of <span class="math inline">\(D_i\)</span> and <span class="math inline">\(D_j\)</span> may no longer be possible after applying the combination operator <span class="math inline">\(\otimes\)</span>. For instance, a typical example of a monoid which lacks inverse is the maximum operator. It is easy to show that maximum is associative:</p>
<p><span class="math display">\[\max(x, \max(y, z)) = \max(\max(x, y), z) = \max(x, y, z)\]</span></p>
<p>And it also has a neutral element, namely <span class="math inline">\(-\infty\)</span>. Thus maximum is a valid monoid. However, maximum lacks an inverse <span class="math inline">\(\otimes^{-1}\)</span>:</p>
<p><span class="math display">\[\not \exists \otimes^{-1} \text{ s. t. } \max(x, y) \otimes^{-1} y = x\]</span></p>
<p>Thus, for example, if it is the case that:</p>
<p><span class="math display">\[\max(x, y) = 8\]</span></p>
<p>Then, even if we know that <span class="math inline">\(y = 8\)</span>, there is no way to recover the value of <span class="math inline">\(x\)</span>. In a certain sense, maximum irretrievably discards some of the information contained in its operands. This happens despite the combined value still being a valid summary of the underlying data: due to associativity, a maximum of maximums is always a valid maximum of all cases. However, there is no meaningful way to reverse the effect of the maximum operator: once we pick the larger of two values, the smaller is lost.</p>
<div class="figure"><span style="display:block;" id="fig:monoids-groups-inverses"></span>
<img src="figures/monoids-groups-inverses.png" alt="While monoids facilitate the comparison of a single selection groups against the whole data set (or of nested data subsets, more generally), groups allow the display of multiple disjoint selection groups (subsets). The top row shows bars stacked using the sum ($+$) operator, whereas the bottom row shows bars stacked using the maximum operator. The panels left to right show different permutations (orderings) of the selection groups (coloured segments). Notice that, when summing, the presence of the inverse operator guarantees that we can always visually recover all selection groups regardless of their permutation (the blue, red, and green segments are present in all three top-row pannels). Conversely, when taking the maximum, certain permutations may collapse information about the individual subsets, effectively 'hiding' segments (even though the presented information remains a valid summary of the underlying data)." width="750" />
<p class="caption">
Figure 4.25: While monoids facilitate the comparison of a single selection groups against the whole data set (or of nested data subsets, more generally), groups allow the display of multiple disjoint selection groups (subsets). The top row shows bars stacked using the sum (<span class="math inline">\(+\)</span>) operator, whereas the bottom row shows bars stacked using the maximum operator. The panels left to right show different permutations (orderings) of the selection groups (coloured segments). Notice that, when summing, the presence of the inverse operator guarantees that we can always visually recover all selection groups regardless of their permutation (the blue, red, and green segments are present in all three top-row pannels). Conversely, when taking the maximum, certain permutations may collapse information about the individual subsets, effectively ‘hiding’ segments (even though the presented information remains a valid summary of the underlying data).
</p>
</div>
<p>The presence (absence) of inverses translates into tangible differences in interactive behavior, see Figure <a href="problems.html#fig:monoids-groups-inverses">4.25</a>. Specifically, when implementing linked selection, some interactive data visualization systems allow the user to select only a single group, whereas others allow multiple selection groups to be present at the same time. This seemingly superficial implementation details has a significant impact on the kinds of statistics we can display effectively. Specifically, with single-group selection, the user defines a single “special” subset <span class="math inline">\(D_i\)</span> that can be compared against the whole data set <span class="math inline">\(D = D_i \cup \neg D_i\)</span>. Crucially, the “rest” of the data set, <span class="math inline">\(\neg D_i\)</span>, plays a secondary role: we only care about it in as much as it contributes to the superset <span class="math inline">\(D\)</span>. As such, it is enough if the combination operator <span class="math inline">\(\otimes\)</span> forms a monoid. However, in multi-group selection, we actually care about comparing the individual selection groups <span class="math inline">\(D_i, D_j, D_k, \ldots\)</span> as disjoint subsets. Thus, we require the inverse operator <span class="math inline">\(\otimes^{-1}\)</span>.</p>
<p>Therefore, groups and monoids support two fundamentally different modes of selection. If we care about using parts of a geometric object to highlight some “special” subset against the subset representing the rest of the data (or highlighting nested subsets more generally), then it is enough for the underlying summary statistic to form a monoid. However, if we directly want to compare disjoint subsets, then we also need the inverse operator and the underlying summary needs to be a group.</p>
<p>This distinction even has interesting implications for data interpretation more broadly. For instance, the reason why the maximum operator “works” in Figure <a href="problems.html#fig:grammar-barplot-maximums">4.16</a> is because we are comparing a special subset of the study participants (smokers) against the subset of all participants (smokers <em>and</em> non-smokers). In other words, with the smoking status variable, it makes sense to compare one category against the union of both categories. This is not the case for all categorical variables, however. For instance, with a gender variable, it rarely makes sense to think of men as a special subset of men and women, or vice versa; the vast majority of time, we are interested in comparing men and women directly, as disjoint subsets. Conversely, this is also the case why monoids work with single-group linked selection: the selected points really are a “special” subset, and the subset representing the “rest” of the data is only interesting in that it is part of “all” of the data points to compare against. However, with multiple selection groups, disjoint comparisons become essential.</p>
</div>
<div id="monotonicity-commutativity" class="section level4 hasAnchor" number="4.3.2.9">
<h4><span class="header-section-number">4.3.2.9</span> Other properties: Monotonicity and commutativity<a href="problems.html#monotonicity-commutativity" class="anchor-section" aria-label="Anchor link to header"></a></h4>
<p>There are other algebraic properties of set union we may wish to preserve in our visualizations. The two most important ones are monotonicity and commutativity.</p>
<div id="monotonicity" class="section level5 hasAnchor" number="4.3.2.9.1">
<h5><span class="header-section-number">4.3.2.9.1</span> Monotonicity<a href="problems.html#monotonicity" class="anchor-section" aria-label="Anchor link to header"></a></h5>
<p>One property of set union which it may also be very useful to preserve is monotonicity. In a monoid <span class="math inline">\((M, e, \otimes)\)</span> with and associated preorder <span class="math inline">\((M, \leq)\)</span> (i.e. the monoid and preorder jointly form a monoidal preorder), monotonicity is defined as follows:</p>
<p><span class="math display">\[x_1 \leq x_2 \wedge y_1 \leq y_2 \implies x_1 \otimes y_1 \leq x_2 \otimes y_2\]</span></p>
<p>Union of disjoint sets is monotonic, in two different ways. First, if we let the comparison operator be set inclusion, <span class="math inline">\(\subseteq\)</span>, then it is the case that <span class="math inline">\(A_1 \subseteq A_2 \wedge B_1 \subseteq B_2 \implies A_1 \cup A_2 \subseteq B_1 \cup B_2\)</span>. Second, if we let the comparison operator be the comparison of set cardinalities, <span class="math inline">\(A \leq B \implies \lvert A \lvert \leq \lvert B \lvert\)</span>, then <span class="math inline">\(\lvert A_1 \lvert \leq \lvert A_2 \lvert \wedge \lvert B_1 \lvert \wedge \lvert B_2 \lvert  \implies \lvert A_1 \cup B_1 \lvert \leq \lvert A_2 \cup B_2 \lvert\)</span> (since <span class="math inline">\(\lvert A \cup B \lvert = \lvert A \lvert + \lvert B \lvert\)</span>, by disjointness).</p>
<p>Likewise, when drawing geometric objects composed of parts, we typically consider the parts to be “less” than the whole, i.e. having a smaller area or length. As discussed in Section <a href="problems.html#stacking-part-whole">4.3.1.4</a>, this has certain advantages: we can use the fact that the quantities corresponding to the parts are bounded by the quantities corresponding to the whole to avoid unnecessary computation. However, there are also examples of geometric objects where the <em>whole is equal to the sum of its parts, but where the parts are not necessarily “less” than the whole</em>. As an example, such is the case in the following visualization of vector addition:</p>
<div class="figure"><span style="display:block;" id="fig:lineplot-monotonicity"></span>
<img src="figures/lineplot-monotonicity.png" alt="Some geometric representations may form a monoid without exhibiting monotonic growth. The plot shows a line (gray, dashed) formed by adding up three vector segments (red, blue, and green). The operation of concatenating vectors end-to-end is associative (order of concatenation does not change the final endpoint) and unital (zero vector forms the monoidal unit), however, it is not monotonic since the combined vector may be shorter than any of its constituent components." width="750" />
<p class="caption">
Figure 4.26: Some geometric representations may form a monoid without exhibiting monotonic growth. The plot shows a line (gray, dashed) formed by adding up three vector segments (red, blue, and green). The operation of concatenating vectors end-to-end is associative (order of concatenation does not change the final endpoint) and unital (zero vector forms the monoidal unit), however, it is not monotonic since the combined vector may be shorter than any of its constituent components.
</p>
</div>
<p>Figure <a href="problems.html#fig:lineplot-monotonicity">4.26</a> shows a line formed by the addition of three two-dimensional vectors. Vector addition forms a monoid, since for any three vectors <span class="math inline">\(\vec{x}, \vec{y}, \vec{z}\)</span>, the addition operation is associative, <span class="math inline">\((\vec{x} + \vec{y}) + \vec{z} = \vec{x} + (\vec{y} + \vec{z})\)</span>, and unital, <span class="math inline">\(\vec{x} + \vec{0} = \vec{0} + \vec{x} = x\)</span> (where <span class="math inline">\(\vec{0}\)</span> is the zero vector). Consequently, the final position reached by summing vectors <span class="math inline">\(\vec{x}\)</span>, <span class="math inline">\(\vec{y}\)</span>, and <span class="math inline">\(\vec{z}\)</span> is independent of the order of addition. However, vector addition is not monotonic with respect to vector length. In other words, even if it the case that <span class="math inline">\(\lvert \vec{x}_1 \lvert \leq \lvert \vec{x}_2 \lvert \wedge \lvert \vec{y}_1 \lvert \leq \lvert \vec{y}_2 \lvert\)</span>, it may not be the case that <span class="math inline">\(\lvert \vec{x}_1 + \vec{y}_1 \lvert \leq \lvert \vec{x}_2 + \vec{y}_2 \lvert\)</span>. For instance, if <span class="math inline">\(\vec{x}\)</span> and <span class="math inline">\(\vec{y}\)</span> are opposite vectors of equal magnitude, then their combined length will be 0, which will be less than the combined length of any two shorter, non-opposite vectors.</p>
<p>Thus, it is possible to conceive of monoidal statistics and visual representations which are not monotonic, however, these may suffer from some of the same issues discussed in Section <a href="problems.html#stacking-part-whole">4.3.1.4</a>. For instance, in Figure <a href="problems.html#fig:lineplot-monotonicity">4.26</a>, the segment representing the combined vector does not provide any kind of bound on the segments representing the constituent vectors. As such, if we tried to implement this graphic with interactive features such as linked selection, we would either have to make the axis limits reactive or otherwise infer the maximum possible value they can take.</p>
</div>
<div id="commutativity" class="section level5 hasAnchor" number="4.3.2.9.2">
<h5><span class="header-section-number">4.3.2.9.2</span> Commutativity<a href="problems.html#commutativity" class="anchor-section" aria-label="Anchor link to header"></a></h5>
</div>
</div>
<div id="transforming-summaries" class="section level4 hasAnchor" number="4.3.2.10">
<h4><span class="header-section-number">4.3.2.10</span> Transforming summaries: Stacking, normalizing, and shifting<a href="problems.html#transforming-summaries" class="anchor-section" aria-label="Anchor link to header"></a></h4>
<p>Finally, once we have computed our tree/category of summaries <span class="math inline">\(\mathcal{S}\)</span> via the functor <span class="math inline">\(F: \mathcal{S} \to \mathcal{D}\)</span>, we may also need to transform these summaries further, while respecting the structure of the tree. Indeed, such is the precise nature of stacking, as well as normalization in plots such as spineplots and spinograms.</p>
<p>Specifically, consider the diagram of <span class="math inline">\(\mathcal{S}\)</span> again:</p>

<div class="figure"><span style="display:block;" id="fig:unnamed-chunk-16"></span>
<img src="figures/barplot-preorder4.png" alt="Reproduction of Figure Figure 4.24: Diagram of the barplot/spineplot summary statistic preorder (category), ordered by the combination operator $\otimes$." width="686" />
<p class="caption">
Figure 4.27: Reproduction of Figure Figure <a href="problems.html#fig:barplot-preorder4">4.24</a>: Diagram of the barplot/spineplot summary statistic preorder (category), ordered by the combination operator <span class="math inline">\(\otimes\)</span>.
</p>
</div>
<div id="stacking" class="section level5 hasAnchor" number="4.3.2.10.1">
<h5><span class="header-section-number">4.3.2.10.1</span> Stacking<a href="problems.html#stacking" class="anchor-section" aria-label="Anchor link to header"></a></h5>
<p>To stack statistics, we need to apply our summary/combination operator <span class="math inline">\(\otimes\)</span> cumulatively, across the child nodes corresponding to the object we want to stack. For instance, in a typical barplot, to stack summaries of segments into the summary of single whole bar <span class="math inline">\(S_{B_i}\)</span>, we can cumulatively sum the child/segment summaries (sums or counts). More specifically, to compute the summaries underlying a stacked bar <span class="math inline">\(B_1\)</span>, we compute <span class="math inline">\(S_{S_1}\)</span>, <span class="math inline">\(S_{S_1} + S_{S_2}\)</span>, <span class="math inline">\(S_{S_1} + S_{S_2} + S_{S_3}, \ldots\)</span>, and so on. To turn this “typical” barplot into barplot of maximums (Figure <a href="problems.html#fig:grammar-barplot-maximums">4.16</a>), we can simply replace the sum operator with the maximum operator: e.g., compute <span class="math inline">\(S_{S_1}\)</span>, <span class="math inline">\(\max(S_{S_1}, S_{S_2})\)</span>, <span class="math inline">\(\max(\max(S_{S_1}, S_{S_2}), S_{S_3}), \ldots\)</span>. As shown before, the properties of monoids ensure that the stacked summary is a valid summary of the underlying set, <span class="math inline">\(S_{S_1} \otimes S_{S_2} \otimes S_{S_3} \otimes \ldots = S_{B_1}\)</span>.</p>
<p>Importantly, stacking can be applied at different levels of the hierarchical structure. Spinograms provide a good example. In spinograms, segments are stacked vertically, within bars, and also bars are stacked horizontally, to form the monolithic rectangle corresponding to the whole data set. Thus, on top of segment-stacking, e.g., <span class="math inline">\(S_{S_1} \otimes S_{S_2} \otimes S_{S_3} \otimes \ldots = S_{B_1}\)</span>, we also have whole-object-stacking, <span class="math inline">\(S_{B_1} \otimes S_{B_2} \otimes S_{B_3} \otimes \ldots = S_{D}\)</span>.</p>
<p>Similar to stacking multiple selection groups, horizontally stacking summary statistics that lack the inverse operator may produce some rather bizzare-looking spinograms. For instance, if we stack maximums and the first histogram bin contains the greatest data value, then the spinogram will consist of only a single bar (all of the bar values stack to the same value). Nevertheless, the plot will be a valid summary of the underlying data. Again, the underlying issue is the lack of the inverse operator and the distinction between monoids and groups.</p>
</div>
<div id="normalizing" class="section level5 hasAnchor" number="4.3.2.10.2">
<h5><span class="header-section-number">4.3.2.10.2</span> Normalizing<a href="problems.html#normalizing" class="anchor-section" aria-label="Anchor link to header"></a></h5>
<p>To normalize statistics, we can apply a binary function that takes as the second argument the value of the parent statistic. For instance, if we have some already stacked segments, e.g. <span class="math inline">\(S_{S_1}\)</span>, <span class="math inline">\(S_{S_1} + S_{S_2}\)</span>, <span class="math inline">\(S_{S_1} + S_{S_2} + S_{S_3}\)</span>, we can normalize them between [0, 1] by dividing by the parent bar statistic: <span class="math inline">\(S_{S_1} / S_{B_1}\)</span>, <span class="math inline">\((S_{S_1} + S_{S_2}) / S_{B_1}\)</span>, <span class="math inline">\((S_{S_1} + S_{S_2} + S_{S_3}) / S_{B_1}\)</span>. Thus, as was mentioned in Section <a href="problems.html#hierarchy">4.2.4</a>, we need the hierarchical structure to divide <em>across the levels of the hierarchy</em>.</p>
<p>It is worth considering whether functions other than simple division could serve as “normalizing” functions. For example, weighted division (e.g. <span class="math inline">\(\sqrt{S_{S_1}} / \sqrt{S_{B_1}}\)</span>) could be used to down-weigh large values. It may also possible to apply a binary function that is entirely different from division. To be fair, these alternative ways of normalizing data may result in plots which are difficult to interpret, and I have not been able to come up with a real, practical application. Nevertheless, this alternative view of normalization does present intriguing possibilities.</p>
</div>
<div id="shifting" class="section level5 hasAnchor" number="4.3.2.10.3">
<h5><span class="header-section-number">4.3.2.10.3</span> Shifting<a href="problems.html#shifting" class="anchor-section" aria-label="Anchor link to header"></a></h5>
<p>One final point to mention is that the monoidal structure of the summary statistics presents the possibility of “shifting” values towards the neutral element. For instance, with a list of sums (e.g. <span class="math inline">\(\{ 4, 2, 3, 2 \}\)</span>), we may use the neutral element (0) to “shift the values leftwards” (<span class="math inline">\(\{ 0, 4, 2, 3 \}\)</span>).</p>
<p>This method is useful, for example, when horizontally stacking values in a spinogram. Specifically, it ensures we have a way to represent the left edge of the first bar (the <code>x0</code> aesthetic). For instance, if we stack bars horizontally using the cumulative product, e.g. <span class="math inline">\(\{ 4, 2, 3, 2 \} \to \{ 4, 8, 24, 48 \}\)</span>, then we want the statistics for the left edge of the bars to be <span class="math inline">\(\{ 1, 4, 8, 24, \}\)</span> (notice that the first value - the neutral element - is 1; also, the right edge will be just the stacked summaries, <span class="math inline">\(\{ 4, 8, 24, 48 \}\)</span>). Care must be taken when the neutral element is not finite: for instance, with the maximum operator, the neutral element is negative infinity (<span class="math inline">\(-\infty\)</span>), which is not representable in most types of plots; however, if all summarized values are non-negative, we may use zero as the neutral element (i.e. the monoid becomes <span class="math inline">\((\mathbb{R}^+, 0, \max)\)</span> instead of <span class="math inline">\((\mathbb{R}, -\infty, \max)\)</span>).</p>
<p>Finally, like with normalizing, while the practical utility of shifting values beyond spineplots and “typical” statistics like sums and counts may be limited, it does expand the way we may think about the relationship between summary statistics and our graphs. The existence of a well-defined “zero-point” is also useful more generally, for instance, when setting the lower y-axis limit in a barplot.</p>
</div>
</div>
</div>
</div>
<div id="scaling" class="section level2 hasAnchor" number="4.4">
<h2><span class="header-section-number">4.4</span> Scaling and encoding<a href="problems.html#scaling" class="anchor-section" aria-label="Anchor link to header"></a></h2>
<p>Suppose we have partitioned our data and computed all relevant summary statistics. Now we need a way to to encode these summaries into visual attributes that we can then present on the computer screen. In most data visualization systems, this is done by specialized components called scales or coordinate systems <span class="citation">(see e.g. <a href="#ref-murrell2005">Murrell 2005</a>; <a href="#ref-wickham2016">Wickham 2016</a>; <a href="#ref-wilkinson2012">Wilkinson 2012</a>; <a href="#ref-petricek2020">Petricek 2020</a>)</span>.</p>
<p>As discussed in Sections <a href="background.html#scales-measurement">3.3.3</a> and <a href="background.html#visual-perception">3.3.2</a>, there exists is a fair amount of literature on the theoretical properties of scales and their relationship to the mechanisms of visual perception <span class="citation">(see e.g. <a href="#ref-krzywinski2013">Krzywinski 2013</a>; <a href="#ref-michell1986">Michell 1986</a>; <a href="#ref-wilkinson2012">Wilkinson 2012</a>; <a href="#ref-stevens1946">Stevens 1946</a>)</span>. However, when it comes to applying this knowledge and implementing scales in concrete data visualization systems, few research papers are available, and most only discuss the problem in vague, abstract terms <span class="citation">(for some rare counter-examples, see e.g. <a href="#ref-murrell2005">Murrell 2005</a>; <a href="#ref-ziemkiewicz2009">Ziemkiewicz and Kosara 2009</a>)</span>. To learn about how to actually implement scales scales, one has to go digging through open-source code repositories, which are rarely the most concise educational resources.</p>
<p>This gap between theory and practice is quite unfortunate in my opinion, since scales are an integral part of the data visualization pipeline. Further, they are the foundation of many interactive features, such as zooming, panning, and reordering. Finally, within existing data visualization systems, it is often the case that a large portion of the code is dedicated to scales. For instance, within the <code>ggplot2</code> codebase, the file containing the definition of the <code>Scale</code> class has the greatest number of lines, by quite a significant margin <span class="citation">(as of 4th of December 2024, <a href="#ref-ggplot2repo2024">Wickham 2024</a>)</span>, see Figure <a href="problems.html#fig:ggplot2-linecounts">4.28</a>:</p>
<div class="figure"><span style="display:block;" id="fig:ggplot2-linecounts"></span>
<img src="figures/ggplot2-linecounts.png" alt="The top 10 longest source files within the `ggplot2` codebase. Notice that `scale-.R` files contains significantly more lines than the other files." width="750" />
<p class="caption">
Figure 4.28: The top 10 longest source files within the <code>ggplot2</code> codebase. Notice that <code>scale-.R</code> files contains significantly more lines than the other files.
</p>
</div>
<p>For the reasons outlined above, I believe it is important to discuss the issue of applied scaling in more depth. The information here is based largely on how scales have been implemented in existing data visualization codebases, such as the <code>ggplot2</code>package <span class="citation">(<a href="#ref-wickham2016">Wickham 2016</a>)</span> or <code>d3-scale</code> module of D3 <span class="citation">(<a href="#ref-d3-scale2024">Observable 2024</a>; used also by e.g. Vega <a href="#ref-satyanarayan2015">Satyanarayan et al. 2015</a>)</span>, as well as on personal insights gained while implementing my package.</p>
<div id="scales-as-functions" class="section level4 hasAnchor" number="4.4.0.1">
<h4><span class="header-section-number">4.4.0.1</span> Scales as functions<a href="problems.html#scales-as-functions" class="anchor-section" aria-label="Anchor link to header"></a></h4>
<p>From a high-level perspective, a scale is just a function <span class="math inline">\(s: D \to V\)</span> which maps data values <span class="math inline">\(d \in D\)</span> to values of some visual attribute <span class="math inline">\(v \in V\)</span>, such as the x- and y-position, length, area, radius, or color <span class="citation">(<a href="#ref-wilkinson2012">Wilkinson 2012</a>; <a href="#ref-petricek2020">Petricek 2020</a>)</span>. This function may or may not be invertible, such that, at times, each value of the visual attribute may be uniquely identifiable with a single data value, or not.</p>
<p>One of the most common examples of a scale is a function where both <span class="math inline">\(D\)</span> and <span class="math inline">\(V\)</span> are subsets of the real numbers:</p>
<p><span class="math display">\[s: [d_{min}, d_{max}] \to [v_{min}, v_{max}] \qquad d_{min}, d_{max}, v_{min}, v_{max} \in \mathbb{R}\]</span></p>
<p>For example, suppose our data takes values in the range from 1 to 10 and we want to plot it along the x-axis, within a 800 pixels wide plotting region. Then, our scale is simply:</p>
<p><span class="math display">\[s_x: [1, 10] \to [0, 800]\]</span></p>
<p>Now, there is an infinite number of functions that fit this signature. However, one particularly nice and simple candidate is the following function<a href="#fn6" class="footnote-ref" id="fnref6"><sup>6</sup></a>:</p>
<div class="definition">
<p><span id="def:linear-mapping" class="definition"><strong>Definition 4.3  (Simple linear mapping) </strong></span><span class="math display">\[s(d) = v_{min} + \frac{d - d_{min}}{d_{max} - d_{min}} \cdot (v_{max} - v_{min})\]</span></p>
</div>
<p>if we substitute our concrete values into the formula, this becomes:</p>
<p><span class="math display">\[s_x(d) = 0 + \frac{d - 1}{10 - 1} \cdot (800 - 0) = [(d - 1) / 9] \cdot 800\]</span></p>
<p>The function acts on the data in the following way:</p>
<ul>
<li><span class="math inline">\(s_x(1) = (1 - 1) / 9 \cdot 800 = 0\)</span></li>
<li><span class="math inline">\(s_x(10) = (10 - 1) / 9 \cdot 800 = 800\)</span></li>
<li><span class="math inline">\(s_x(d) \in [0, 800]\)</span> for any <span class="math inline">\(d \in [1, 10]\)</span></li>
</ul>
<p>That is, the function maps the data value 1 to pixel 0 (left border of the plotting region), value 10 to to pixel 800 (right border of the plotting region), and any value in between 1 and 10 inside the interval 0 to 800, proportionally to where in the data range it is located. In computer science, this function is also often known as <em>linear interpolation</em> <span class="citation">(or <em>lerp</em> for short, see e.g. <a href="#ref-shirley2009">Shirley, Ashikhmin, and Marschner 2009</a>)</span></p>
</div>
<div id="simple-scale-limits" class="section level4 hasAnchor" number="4.4.0.2">
<h4><span class="header-section-number">4.4.0.2</span> Limits of modeling scales with simple functions<a href="problems.html#simple-scale-limits" class="anchor-section" aria-label="Anchor link to header"></a></h4>
<p>Simple linear maps like the one in Definition <a href="problems.html#def:linear-mapping">4.3</a> can work fine for basic data visualization systems. However, once we begin adding more features to our scales, this design can become prohibitive. Consider, for example, what happens if we want to:</p>
<ul>
<li>Expand the scale limits</li>
<li>Scale discrete data</li>
<li>Apply non-linear transformations</li>
<li>Pan, zoom, reverse, reorder, or otherwise modify the scale interactively</li>
</ul>
<p>While a single function could handle all these tasks, adding all of the required arguments might make it overly complex and difficult to reason about. Let’s take the first point in the list above as a motivating example. Consider what happens to data points at the limits of the data range under the simple linear mapping:</p>
<div class="sourceCode" id="cb27"><pre class="sourceCode r"><code class="sourceCode r"><span id="cb27-1"><a href="problems.html#cb27-1" tabindex="-1"></a><span class="fu">set.seed</span>(<span class="dv">123456</span>)</span>
<span id="cb27-2"><a href="problems.html#cb27-2" tabindex="-1"></a>x <span class="ot">&lt;-</span> <span class="dv">1</span><span class="sc">:</span><span class="dv">10</span></span>
<span id="cb27-3"><a href="problems.html#cb27-3" tabindex="-1"></a>y <span class="ot">&lt;-</span> <span class="fu">rnorm</span>(<span class="dv">10</span>, <span class="dv">0</span>, <span class="dv">5</span>)</span>
<span id="cb27-4"><a href="problems.html#cb27-4" tabindex="-1"></a>col <span class="ot">&lt;-</span> <span class="fu">ifelse</span>(<span class="dv">1</span><span class="sc">:</span><span class="dv">10</span> <span class="sc">%in%</span> <span class="fu">c</span>(<span class="dv">1</span>, <span class="dv">10</span>), <span class="st">&quot;indianred&quot;</span>, <span class="st">&quot;grey80&quot;</span>)</span>
<span id="cb27-5"><a href="problems.html#cb27-5" tabindex="-1"></a></span>
<span id="cb27-6"><a href="problems.html#cb27-6" tabindex="-1"></a><span class="co"># xaxs = &quot;i&quot; makes sure the x-axis limits match the data range exactly</span></span>
<span id="cb27-7"><a href="problems.html#cb27-7" tabindex="-1"></a><span class="fu">plot</span>(x, y, <span class="at">col =</span> col, <span class="at">cex =</span> <span class="dv">3</span>, <span class="at">xaxs =</span> <span class="st">&quot;i&quot;</span>, <span class="at">pch =</span> <span class="dv">19</span>)</span></code></pre></div>
<p><img src="_main_files/figure-html/unnamed-chunk-17-1.png" width="672" style="display: block; margin: auto;" /></p>
<p>The plot above shows values scaled using the simple linear mapping along the x-axis, that is, <span class="math inline">\(s: [1, 10] \to [0, 800]\)</span> (effect of the <code>xaxs = "i"</code> argument). Notice that, since the positions of the points representing the values 1 and 10 (highlighted in red) get mapped to pixel values 0 and 800 (the left and right border of the plot), only half of each point is visible. This is problematic: as was discussed in Section <a href="problems.html#show-all-data">4.2.1</a>, a fundamental principles of graphical integrity is that our graphics should not downplay or hide certain features of the data <span class="citation">(<a href="#ref-tufte2001">Tufte 2001</a>)</span>. Since the points near the axis limits are represented by only a fraction of the area of the rest, they become less visually salient, and this is particularly problematic since these points are more likely to be outliers.</p>
<p>To address this problem, most data visualization systems automatically expand the range of the domain by some pre-specified percentage:</p>
<div class="sourceCode" id="cb28"><pre class="sourceCode r"><code class="sourceCode r"><span id="cb28-1"><a href="problems.html#cb28-1" tabindex="-1"></a><span class="co"># By default, the base R plot() function automatically expands the x- and y-axis</span></span>
<span id="cb28-2"><a href="problems.html#cb28-2" tabindex="-1"></a><span class="co"># limits by approximately 4% on each end, see `xaxs` in ?graphics::par</span></span>
<span id="cb28-3"><a href="problems.html#cb28-3" tabindex="-1"></a><span class="fu">plot</span>(x, y, <span class="at">col =</span> col, <span class="at">cex =</span> <span class="dv">3</span>, <span class="at">pch =</span> <span class="dv">19</span>)</span></code></pre></div>
<p><img src="_main_files/figure-html/unnamed-chunk-18-1.png" width="672" style="display: block; margin: auto;" /></p>
<p>We could achieve this by expanding our data range by some pre-specified percentage, for example, a symmetric 10% margin on each side:</p>
<p><span class="math display" id="eq:margins">\[\begin{equation}
  s(d) = v_{min} + \bigg[ 0.1 + \frac{d - d_{min}}{d_{max} - d_{min}} \cdot (0.9 - 0.1)
            \bigg] \cdot (v_{max} - v_{min})
  \tag{4.3}
\end{equation}\]</span></p>
<p>Now, if we wanted these margins to be modifiable parameters as well, we should include them in the function signature:</p>
<p><span class="math display">\[\begin{equation}
  s(d; m_{lower}, m_{upper}) = v_{min} + \bigg[ m_{lower} + \frac{d - d_{min}}{d_{max} - d_{min}} \cdot (m_{upper} - m_{lower})
            \bigg] \cdot (v_{max} - v_{min})
\end{equation}\]</span></p>
<p>Likewise, we should probably include the data and visual attribute limits in the function signature as well, i.e. <span class="math inline">\(s(d; d_{min}, d_{max}, v_{min}, v_{max}, m_{lower}, m_{upper})\)</span>. However, as you can see, the function signature as well as the body start becoming fairly busy and hard to reason about, making this design prohibitive. For example, if we wanted to map some discrete data values to the same visual attribute codomain <span class="math inline">\(V\)</span>, would we have to design an entirely new mapping function? Similarly, what if we want apply some other transformation, such as flipping the scale’s direction? It would be useful if there were some way to abstract out the data domain <span class="math inline">\(D\)</span> and the visual attribute codomain <span class="math inline">\(V\)</span>, such that we could apply some common operations to the scale regardless of its specific implementation.</p>
</div>
<div id="scales-composition" class="section level4 hasAnchor" number="4.4.0.3">
<h4><span class="header-section-number">4.4.0.3</span> Solution: Scales as function composition<a href="problems.html#scales-composition" class="anchor-section" aria-label="Anchor link to header"></a></h4>
<p>The linear mapping formula in Equation <a href="problems.html#eq:margins">(4.3)</a> can guide us in decomposing the scale function into smaller, more manageable parts. Let’s look at it again:</p>
<p><span class="math display">\[  s(d) = v_{min} + \bigg[ 0.1 + \frac{d - d_{min}}{d_{max} - d_{min}} \cdot (0.9 - 0.1)
            \bigg] \cdot (v_{max} - v_{min}) \]</span></p>
<p>If we look closely, we may be able to see that the function can be split into three parts:</p>
<p><span class="math display" id="eq:scale-composition">\[\begin{equation}
s(d) = \color{steelblue}{v_{min} +} \bigg[ \color{seagreen}{0.1 +} \color{indianred}{\frac{\color{black}{d} - d_{min}}{d_{max} - d_{min}}} \color{seagreen}{\cdot (0.9 - 0.1)} \bigg] \color{steelblue}{\cdot (v_{max} - v_{min})}
\tag{4.4}
\end{equation}\]</span></p>
<p>That is, the linear mapping can be interpreted as a composition of three simpler functions:</p>
<ul>
<li><span class="math inline">\(\color{indianred}{n_D(d) = (d - d_{min}) / (d_{max} - d_{min})}\)</span> takes a data value <span class="math inline">\(d \in D\)</span> and maps it to the interval <span class="math inline">\([0, 1]\)</span><a href="#fn7" class="footnote-ref" id="fnref7"><sup>7</sup></a></li>
<li><span class="math inline">\(\color{seagreen}{r(p) = 0.1 + p \cdot (0.9 - 0.1)}\)</span> takes a value in <span class="math inline">\([0, 1]\)</span> and maps it elsewhere in <span class="math inline">\([0, 1]\)</span></li>
<li><span class="math inline">\(\color{steelblue}{u_V(p) = v_{min} + p \cdot (v_{max} - v_{min})}\)</span> takes a value in <span class="math inline">\([0, 1]\)</span> and maps it to a visual attribute value <span class="math inline">\(v \in V\)</span></li>
</ul>
<p>In other words, instead of thinking of scale as direct mapping from <span class="math inline">\(D\)</span> to <span class="math inline">\(V\)</span> directly, we can break the transformation into three distinct steps. This leads us to the following definition of a scale:</p>
<div class="definition">
<p><span id="def:scale" class="definition"><strong>Definition 4.4  (Scale as function composition) </strong></span>A scale <span class="math inline">\(s: D \to V\)</span> can be created by composing:</p>
<ul>
<li>A <em>data normalizing</em> function <span class="math inline">\(n_D: D \to \mathbb{R}\)</span>, mapping data values to the real numbers <span class="math inline">\(\mathbb{R}\)</span></li>
<li>A linear <em>rescale</em> function <span class="math inline">\(r: \mathbb{R} \to \mathbb{R}\)</span></li>
<li>An <em>visual attribute unnormalizing</em> function <span class="math inline">\(u_V: \mathbb{R} \to V\)</span>, mapping real numbers to the visual attribute codomain</li>
</ul>
<p>Such that:</p>
<p><span class="math display">\[s(d) = u_V(r(n_D(d)))\]</span></p>
<p>or, more tersely:</p>
<p><span class="math display">\[s = n_D ;r ;u_V\]</span></p>
</div>
<p>This is the proposed model of scales in a nutshell. However, there are several important points which bear explaining in more detail.</p>
<div id="reusability-and-discrete-scales" class="section level5 hasAnchor" number="4.4.0.3.1">
<h5><span class="header-section-number">4.4.0.3.1</span> Reusability and discrete scales<a href="problems.html#reusability-and-discrete-scales" class="anchor-section" aria-label="Anchor link to header"></a></h5>
<p>First, by expressing scales as the composition of three functions, we gain the flexibility of three adjustable components. By choosing a specific data normalizing function <span class="math inline">\(n_D\)</span>, a rescale function <span class="math inline">\(r\)</span>, or visual attribute unnormalizing function <span class="math inline">\(u_V\)</span>, we can express a wide range of scales. Further, by swapping only one or two of the components, we may be able to create entirely new scales while reusing a lot of the functionality.</p>
<p>For instance, take the linear mapping from Equation <a href="problems.html#eq:scale-composition">(4.4)</a>. To turn it into a discrete scale, we could simply replace the linear mapping normalize function <span class="math inline">\(n_D(d) = (d - d_{\min}) / (d_{\max} - d_{\min})\)</span> by some discrete mapping <span class="math inline">\(n_D\)</span>:</p>
<p><span class="math display">\[s(d) = v_{min} + \bigg[ 0.1 + n_D(d) \cdot (0.9 - 0.1) \bigg] \cdot (v_{max} - v_{min})\]</span>
For example, if our data takes on discrete values such that, e.g. <span class="math inline">\(d \in \{ Berlin, Prague, Vienna \}\)</span>, one simple discrete mapping may be to place the discrete values at equidistant points along the <span class="math inline">\([0, 1]\)</span> interval:</p>
<p><span class="math display">\[n_D(d) = \begin{cases} 0.25 &amp; \text{ if } d = Berlin \\ 0.5 &amp; \text{ if } d = Prague \\ 0.75 &amp; \text{ if } d = Vienna  \end{cases}\]</span></p>
<p>The function will then correctly map the discrete values in <span class="math inline">\(D = \{ Berlin, Prague, Vienna \}\)</span> to the interval given by <span class="math inline">\([v_{\min}, v_{\max}]\)</span>, with the 10% margins. Further, we could just as easily replace the unnormalizing function <span class="math inline">\(u_V\)</span> by some discrete mapping, provided we wanted to scale to some discrete visual attribute values (e.g. to a discrete colour palette).</p>
</div>
<div id="scaling-intermediate" class="section level5 hasAnchor" number="4.4.0.3.2">
<h5><span class="header-section-number">4.4.0.3.2</span> The intermediate interval<a href="problems.html#scaling-intermediate" class="anchor-section" aria-label="Anchor link to header"></a></h5>
<p>Second, note that in Definition <a href="problems.html#def:scale">4.4</a>, the intermediate interval is identified as <span class="math inline">\(\mathbb{R}\)</span>. This is technically correct, however, note that, for data values <span class="math inline">\(d \in D\)</span> which fall into some <em>typical</em> subset (such as <span class="math inline">\([d_{\min}, d_{\max}]\)</span> for continuous <span class="math inline">\(D\)</span>), <span class="math inline">\(n_D\)</span> should <em>generally</em> return values in the unit interval <span class="math inline">\([0, 1]\)</span> (and, conversely, <span class="math inline">\(u_V\)</span> should map values in <span class="math inline">\([0, 1]\)</span> to typical values of the visual attribute).</p>
<p>The reason why the intermediate interval is identified as <span class="math inline">\(\mathbb{R}\)</span> instead of <span class="math inline">\([0, 1]\)</span> is because, at times, we may want to be able to map values which fall outside of the typical range of the data or the visual attribute. For instance, suppose we zoom into a region of a scatterplot and there is a point with its center just outside of the new plot limits. If the point’s radius is greater than the distance of its center to the plot border, a part of the point will still overlap the plotting region and we should render it, even though the x- and y- coordinates lie outside the data range.</p>
<p>However, for most intents and purposes, we can act as if the intermediate interval was <span class="math inline">\([0, 1]\)</span>. This is somewhat arbitrary - any interval <span class="math inline">\([a, b]\)</span> with <span class="math inline">\(a, b \in \mathbb{R}\)</span> will work - however, <span class="math inline">\([0, 1]\)</span> offers a convenient interpretation. Specifically, values <span class="math inline">\(p \in [0, 1]\)</span> can be interpreted as percentages: for example, <span class="math inline">\(n_D(d) = 0.5\)</span> indicates data value is at the 50th percentile of the data range, and should, therefore, be generally mapped to the middle of the visual attribute range (other factors that we will discuss later aside). Values outside of <span class="math inline">\([0, 1]\)</span> represent data values extending beyond the data (visual attribute) range. For example, <span class="math inline">\(n_D(d) = 1.2\)</span> suggests that the data point lies 20% beyond the upper limit of the data range (provided that <span class="math inline">\(D\)</span> is continuous).</p>
<p>Finally, note that the terms <em>normalizing</em> and <em>unnormalizing</em> are also arbitrary, however, I believe they make for useful labels. We can interpret them as 1D equivalent of vector normalization, mapping a one-dimensional vector in <span class="math inline">\(D\)</span> to and from the extended unit interval <span class="math inline">\([0, 1]\)</span> (and vice-versa for <span class="math inline">\(V\)</span>). Further, note that I had already also used the term <em>normalizing</em> in Section <a href="problems.html#transforming-summaries">4.3.2.10</a>, when discussing transformations of aggregated summaries. While using the same term to refer to two different operations may cause some confusion, the underlying concept is very similar: converting values to (and, in the case of scales, from) the interval <span class="math inline">\([0, 1]\)</span>. For this reason, rather than coming up with a new term (which may be less semantically fitting), I chose to refer to both concepts the same way.</p>
</div>
<div id="implementing-scale-features-via-the-intermediate-interval" class="section level5 hasAnchor" number="4.4.0.3.3">
<h5><span class="header-section-number">4.4.0.3.3</span> Implementing scale features via the intermediate interval<a href="problems.html#implementing-scale-features-via-the-intermediate-interval" class="anchor-section" aria-label="Anchor link to header"></a></h5>
<p>The three-component scale model becomes particularly useful when implementing many of the standard features of scales. Specifically, plot margins, as well as interactive features such as zooming and panning, can be implemented by manipulating the parameters of the rescale function <span class="math inline">\(r\)</span> only. This is advantageous for reuse, since these operations can apply homomorphically, independent of the data domain <span class="math inline">\(D\)</span> or the visual attribute codomain <span class="math inline">\(V\)</span>.</p>
<div id="margins" class="section level6 hasAnchor" number="4.4.0.3.3.1">
<h6><span class="header-section-number">4.4.0.3.3.1</span> Margins<a href="problems.html#margins" class="anchor-section" aria-label="Anchor link to header"></a></h6>
<p>One feature we have seen already implemented via the rescale function are plot margins. For example, suppose we want to implement margins on the x-axis scale. Starting with a simple “identity” rescale function:</p>
<p><span class="math display">\[r(p) = p\]</span></p>
<p>we can shift data values closer to the centre of visual attribute range by introducing “limits” into the rescale function. For example, to implement symmetric 10% margins on each side, we can rescale with <span class="math inline">\((0.1, 0.9)\)</span> limits:</p>
<p><span class="math display">\[r(p) = 0.1 + p \cdot (0.9 - 0.1)\]</span></p>
<p>However, the limits do not have to be symmetric. For example, we could implement a 10% left margin and 30% right margin like so:</p>
<p><span class="math display">\[r(p) = 0.1 + p \cdot (0.7 - 0.1)\]</span></p>
<p>Importantly, the margins are independent of the data domain <span class="math inline">\(D\)</span> and the visual attribute codomain <span class="math inline">\(V\)</span>. As long as the data normalizing function correctly maps values <span class="math inline">\(D \to \mathbb{R}\)</span> and the visual attribute unnormalizing function correctly maps values <span class="math inline">\(\mathbb{R} \to V\)</span>, the scale will correctly implement margins.</p>
</div>
<div id="panning" class="section level6 hasAnchor" number="4.4.0.3.3.2">
<h6><span class="header-section-number">4.4.0.3.3.2</span> Panning<a href="problems.html#panning" class="anchor-section" aria-label="Anchor link to header"></a></h6>
<p>Now, suppose we also want to pan the plot 25% to the right. Again, all we need to do is to change the parameters of the rescale function for the x-axis scale. For example, using the scale with 10% symmetric margins above, we can simply increment the margins by 0.25:</p>
<p><span class="math display">\[\begin{align}
r(p) &amp;= (0.1 + 0.25) + p \cdot [(0.9 + 0.25) - (0.1 + 0.25)] \\
    &amp;= 0.35 + p \cdot (1.15 - 0.35)
\end{align}\]</span></p>
<p>Now, the “least” data point <span class="math inline">\(d \in D\)</span> gets mapped to 0.35 (10% margin + 25% to the right), whereas the “greatest” data point gets mapped to 1.15 (25% to the right - 10% margin). Notice that, again, this is entirely independent of <span class="math inline">\(D\)</span> and <span class="math inline">\(V\)</span>. That is, for instance, we can pan a continuous scale the exact same way we can pan a discrete scale.</p>
</div>
<div id="zooming" class="section level6 hasAnchor" number="4.4.0.3.3.3">
<h6><span class="header-section-number">4.4.0.3.3.3</span> Zooming<a href="problems.html#zooming" class="anchor-section" aria-label="Anchor link to header"></a></h6>
<p>Zooming can also be implemented entirely using the rescale function <span class="math inline">\(r\)</span>. The key here is to notice that if we set the limits outside of <span class="math inline">\([0, 1]\)</span>, the scale essentially gets stretched such that the least and the greatest data values get mapped outside of the visual attribute range (leading to a zoom behavior).</p>
<p>For instance, setting the limits to <span class="math inline">\(-(0.5, 1.5)\)</span> effectively zooms into the middle 50% of the range, since the 25th percentile data value gets mapped to zero and the 75th percentile data value gets mapped to one:</p>
<p><span class="math display">\[r(0.25) = -0.5 + 0.25 \cdot [1.5 - (-0.5)] = 0\]</span>
<span class="math display">\[r(0.75) = -0.5 + 0.75 \cdot [1.5 - (-0.5)] = 1\]</span></p>
<p>Care must be taken when zooming in the presence of pre-existing limits, such as those caused by margins or multiple levels of zoom. In that case, we need to re-normalize the new limits within the context of the current limits. Coming up with the right formula requires a little bit of careful algebra; details of the algorithm are given in Section <a href="system.html#scales">6.4.4.7</a>.</p>
</div>
</div>
<div id="scaling-inverses" class="section level5 hasAnchor" number="4.4.0.3.4">
<h5><span class="header-section-number">4.4.0.3.4</span> Inverses<a href="problems.html#scaling-inverses" class="anchor-section" aria-label="Anchor link to header"></a></h5>
<p>Another advantage of the three component scale system is that if both <span class="math inline">\(n_D\)</span> and <span class="math inline">\(u_V\)</span> have inverses (or at least retractions), we can easily implement an inverse scale function. Specifically, let <span class="math inline">\((n_D)^{-1} = u_D\)</span> and <span class="math inline">\((u_V)^{-1} = n_V\)</span> such that <span class="math inline">\(u_D: \mathbb{R} \to D\)</span> and <span class="math inline">\(n_V = V \to \mathbb{R}\)</span>, and <span class="math inline">\(u_D \circ n_D = n_V \circ u_V = \text{id}\)</span>, the identity function. Then:</p>
<p><span class="math display">\[s^{-1}(v) = u_D(r^{-1}(n_V(v)))\]</span></p>
<p>(the inverse of the rescale function <span class="math inline">\(r\)</span>, <span class="math inline">\(r^{-1}\)</span>, effectively always exists, since the function is just a simple linear map)</p>
<p>The inverse scale function allows us to go from the values of the visual attribute to the values of the data domain. This may be useful in certain situations, such as when we want to find the closest data point to a given x- and y-axis coordinate.</p>
<p>However, as was mentioned above, <span class="math inline">\(n_D\)</span> and <span class="math inline">\(u_V\)</span> may not always have a full inverse. For example, such is the case with the discrete mapping <span class="math inline">\(n_D\)</span>:</p>
<p><span class="math display">\[n_D(d) = \begin{cases} 0.25 &amp; \text{ if } d = Berlin \\ 0.5 &amp; \text{ if } d = Prague \\ 0.75 &amp; \text{ if } d = Vienna  \end{cases}\]</span>
We can construct a function which reverts the effect of <span class="math inline">\(n_D\)</span>:</p>
<p><span class="math display">\[u_D(p)^ = \begin{cases} Berlin &amp; \text{ if } p = 0.25 \\ Prague &amp; \text{ if } p = 0.5 \\ Vienna &amp; \text{ if } p = 0.75  \end{cases}\]</span>
Such that <span class="math inline">\(u_D(n_D(d)) = d\)</span> for all <span class="math inline">\(d \in D\)</span>. However, the converse is not necessarily true: it is not the case that <span class="math inline">\(n_D(u_D(p)) = p\)</span> for all <span class="math inline">\(p \in \mathbb{R}\)</span>, since <span class="math inline">\(u_D(p)\)</span> is only defined for <span class="math inline">\(p \in \{ 0.25, 0.5, 0.75 \}\)</span>. We could construct <span class="math inline">\(u_D\)</span> in such a way that it e.g. maps the intermediate value <span class="math inline">\(p\)</span> to the “closest” value in <span class="math inline">\(D\)</span>, such that, e.g. <span class="math inline">\(p &lt; 0.375\)</span> gets mapped to <span class="math inline">\(Berlin\)</span>, <span class="math inline">\(0.375 \leq p &lt; 0.625\)</span> gets mapped to <span class="math inline">\(Prague\)</span>, and <span class="math inline">\(p \geq 0.625\)</span> get mapped to <span class="math inline">\(Vienna\)</span>. This way, <span class="math inline">\(u_D(p)\)</span> will be defined for all <span class="math inline">\(p \in \mathbb{R}\)</span>, however, it is still not the case that <span class="math inline">\(n_D(u_D(p)) = p\)</span> for all <span class="math inline">\(p \in \mathbb{R}\)</span>. And such will be the case for any finite <span class="math inline">\(D\)</span>, or more generally, any time the dimensionalities of <span class="math inline">\(D\)</span> and <span class="math inline">\(V\)</span> do not match. However, even when the functions have only a one-sided inverse (a retraction), the inverse scale function may still prove quite useful.</p>
</div>
<div id="scale-transformations" class="section level5 hasAnchor" number="4.4.0.3.5">
<h5><span class="header-section-number">4.4.0.3.5</span> Scale transformations<a href="problems.html#scale-transformations" class="anchor-section" aria-label="Anchor link to header"></a></h5>
<blockquote>
<p>“Transformation is a critical tool for visualization or for any other mode of data analysis
because it can substantially simplify the structure of a set of data.”</p>
<p><span class="citation">Cleveland (<a href="#ref-cleveland1993">1993</a>)</span>, pp. 48</p>
</blockquote>
</div>
</div>
<div id="scales-comparison" class="section level4 hasAnchor" number="4.4.0.4">
<h4><span class="header-section-number">4.4.0.4</span> Comparison to past implementations of scales<a href="problems.html#scales-comparison" class="anchor-section" aria-label="Anchor link to header"></a></h4>
<p>Many popular data visualization systems implement a multi-component model of scales similar to the one outlined above, however, they typically omit the <span class="math inline">\(r\)</span> function and implement the <span class="math inline">\(n_D\)</span> and <span class="math inline">\(u_V\)</span> mappings quite differently. For example, in <code>D3</code> <span class="citation">(<a href="#ref-bostock2011">Michael Bostock, Ogievetsky, and Heer 2011</a>)</span>, scales are implemented in a functional style, such that the data domain and the visual attribute codomain are passed as tuples or arrays of values to a higher-order <code>scale*</code> function (such as <code>scaleLinear</code>, <code>scalePoint</code>, or <code>scaleBand</code>), which then returns a new function that can be used for scaling. The domain and codomain can also be modified afterwards, using the <code>scale*.domain</code> and <code>scale*.range</code> methods respectively (JavaScript functions are objects and can have other functions/methods attached to them).</p>
<p>For illustration, here are few examples from the official documentation <span class="citation">(<a href="#ref-d3-scale2024">Observable 2024</a>)</span>:</p>
<div class="sourceCode" id="cb29"><pre class="sourceCode ts"><code class="sourceCode typescript"><span id="cb29-1"><a href="problems.html#cb29-1" tabindex="-1"></a><span class="kw">const</span> x <span class="op">=</span> d3<span class="op">.</span><span class="fu">scaleLinear</span>([<span class="dv">10</span><span class="op">,</span> <span class="dv">130</span>]<span class="op">,</span> [<span class="dv">0</span><span class="op">,</span> <span class="dv">960</span>])<span class="op">;</span></span>
<span id="cb29-2"><a href="problems.html#cb29-2" tabindex="-1"></a><span class="fu">x</span>(<span class="dv">20</span>)<span class="op">;</span> <span class="co">// 80</span></span>
<span id="cb29-3"><a href="problems.html#cb29-3" tabindex="-1"></a><span class="kw">const</span> color <span class="op">=</span> d3<span class="op">.</span><span class="fu">scaleLinear</span>([<span class="dv">10</span><span class="op">,</span> <span class="dv">100</span>]<span class="op">,</span> [<span class="st">&quot;brown&quot;</span><span class="op">,</span> <span class="st">&quot;steelblue&quot;</span>])<span class="op">;</span></span>
<span id="cb29-4"><a href="problems.html#cb29-4" tabindex="-1"></a><span class="fu">color</span>(<span class="dv">20</span>)<span class="op">;</span> <span class="co">// &quot;rgb(154, 52, 57)&quot;</span></span>
<span id="cb29-5"><a href="problems.html#cb29-5" tabindex="-1"></a><span class="co">// The domain and codomain can be changed after initialization</span></span>
<span id="cb29-6"><a href="problems.html#cb29-6" tabindex="-1"></a><span class="kw">const</span> y <span class="op">=</span> d3<span class="op">.</span><span class="fu">scaleLinear</span>()<span class="op">.</span><span class="fu">domain</span>([<span class="dv">10</span><span class="op">,</span> <span class="dv">130</span>])<span class="op">;</span> </span></code></pre></div>
<p>Internally, the <code>scale*</code> functions rely on other specialized functions to translate from its domain to the codomain (such as the <code>normalize()</code> and <code>scale()</code> functions for continuous and discrete/ordinal domains, respectively, and various <code>interpolate()</code> functions for codomains).</p>
<p>Similarly, in <code>ggplot2</code> <span class="citation">(<a href="#ref-wickham2016">Wickham 2016</a>)</span>, all scales inherit from the <code>Scale</code> base class, with each subtype implementing <code>limits</code> and <code>palette</code> properties. The <code>limits</code> property is a vector which corresponds to the data domain and the <code>palette</code> property is a function which corresponds roughly to the visual codomain (the x- and y-position behave slightly differently, due to being transformed via coordinate systems). Internally, the package uses the <code>rescale</code> function from the <code>scales</code> package <span class="citation">(<a href="#ref-wickham2023">Wickham, Pedersen, and Seidel 2023</a>)</span> to map data values to <span class="math inline">\([0, 1]\)</span> and then the <code>palette</code> function is responsible for mapping these normalized values to the visual attribute. For illustration, here’s the full definition of the <code>map</code> method on the <code>ScaleContinuous</code> class (I’ve added comments for clarity):</p>
<div class="sourceCode" id="cb30"><pre class="sourceCode r"><code class="sourceCode r"><span id="cb30-1"><a href="problems.html#cb30-1" tabindex="-1"></a>map <span class="ot">=</span> <span class="cf">function</span>(self, x, <span class="at">limits =</span> self<span class="sc">$</span><span class="fu">get_limits</span>()) {</span>
<span id="cb30-2"><a href="problems.html#cb30-2" tabindex="-1"></a>  <span class="co"># Limits are just a tuple, rescale maps x to [0, 1]</span></span>
<span id="cb30-3"><a href="problems.html#cb30-3" tabindex="-1"></a>  x <span class="ot">&lt;-</span> self<span class="sc">$</span><span class="fu">rescale</span>(self<span class="sc">$</span><span class="fu">oob</span>(x, <span class="at">range =</span> limits), limits) </span>
<span id="cb30-4"><a href="problems.html#cb30-4" tabindex="-1"></a></span>
<span id="cb30-5"><a href="problems.html#cb30-5" tabindex="-1"></a>  uniq <span class="ot">&lt;-</span> <span class="fu">unique0</span>(x)</span>
<span id="cb30-6"><a href="problems.html#cb30-6" tabindex="-1"></a>  <span class="co"># Palette is a function which returns a vector of attribute values</span></span>
<span id="cb30-7"><a href="problems.html#cb30-7" tabindex="-1"></a>  pal <span class="ot">&lt;-</span> self<span class="sc">$</span><span class="fu">palette</span>(uniq) </span>
<span id="cb30-8"><a href="problems.html#cb30-8" tabindex="-1"></a>  scaled <span class="ot">&lt;-</span> pal[<span class="fu">match</span>(x, uniq)]</span>
<span id="cb30-9"><a href="problems.html#cb30-9" tabindex="-1"></a></span>
<span id="cb30-10"><a href="problems.html#cb30-10" tabindex="-1"></a>  <span class="fu">ifelse</span>(<span class="sc">!</span><span class="fu">is.na</span>(scaled), scaled, self<span class="sc">$</span>na.value)</span>
<span id="cb30-11"><a href="problems.html#cb30-11" tabindex="-1"></a>}</span></code></pre></div>
<p>Thus, a key difference between the models of scales discussed above, and the model I propose, is that the domain and codomain are generally implemented as different types. In <code>D3</code>, internally, the functions used to translate from <span class="math inline">\(D \to \mathbb{R}\)</span> are fundamentally different from those used to translate from <span class="math inline">\(\mathbb{R} \to V\)</span>. This difference is even more pronounced in <code>ggplot2</code>, where <code>limits</code> is a simple vector/tuple whereas <code>palette</code> is a function.</p>
<p>I contend that having different types for the domain and codomain has several disadvantages. First, it impedes code reuse, since we cannot simply use the same object in either place. Second, it complicates the mental model: the user has to hold a completely different concept for the domain and codomain in their head. Finally, the models of scales outlined above are designed to work in only one direction: from the data to the visual attribute. To go the other way around, from the visual attribute to the data, other, specialized functions have to be implemented.</p>
<p>Instead, I propose a unified model where the data domain and visual attribute codomain differ only in the context they are used. Details will be discussed in Section <a href="system.html#scales">6.4.4.7</a>.</p>
</div>
</div>
<div id="rendering" class="section level2 hasAnchor" number="4.5">
<h2><span class="header-section-number">4.5</span> Rendering<a href="problems.html#rendering" class="anchor-section" aria-label="Anchor link to header"></a></h2>
<p>Assuming we have done the work of splitting our data into subsets, summarizing these subsets, and encoding the resulting summaries as visual encodings/aesthetics, only the final part of the visualization pipeline remains: rendering. During this stage, we take all of our pre-computed quantities and render these into a visual representation on the computer screen. This process relies on several different components, which will be discussed in the present section.</p>
<div id="frames" class="section level3 hasAnchor" number="4.5.1">
<h3><span class="header-section-number">4.5.1</span> Frames<a href="problems.html#frames" class="anchor-section" aria-label="Anchor link to header"></a></h3>
<p>Frames or canvases are a key component of the rendering pipeline <span class="citation">(see <a href="#ref-wilkinson2012">Wilkinson 2012</a>; <a href="#ref-wilhelm2003">Wilhelm 2003</a>)</span>. Put simply, a frame describes a two-dimensional region where the graphical elements which make up a plot are placed. It may be abstracted over the underlying image encoding format (see Section <a href="background.html#graphics-formats">3.3.4</a>), although some authors also directly refer to a frame as a “set of pixels” <span class="citation">(<a href="#ref-wilhelm2003">Wilhelm 2003</a>)</span>; however, this is what it will ultimately reduce to within the output device (screen or printer). Further, frame dimensions, usually limited by the window/viewport size but not always <span class="citation">(see e.g. <a href="#ref-wilhelm2003">Wilhelm 2003</a>)</span>, are often measured in pixels, and scales (see Section <a href="system.html#scales">6.4.4.7</a>) provide a mapping from data coordinates to these dimensions.</p>
<p>While a single frame may be used to construct and entire plot or even a figure, generally, in most data visualization systems multiple frames are used. For instance, in many data visualization systems, a single plot is composed of multiple semi-transparent frames layered on top of each other, with each frame being responsible for rendering a different class of graphical elements. This layering has several important benefits. First, it simplifies rendering logic, since by rendering different classes of elements in separate layers, rendering order becomes less critical. For instance, in a scatterplot, if we use one layer to render the points, and another, higher-placed layer (greater z-index) to render some annotations, we can be always sure that the annotations will be plotted on top of the points and not vice versa, regardless of the order we render them. Second, layering also allows for greater computational efficiency via strategic updates <span class="citation">(<a href="#ref-urbanek2011">Urbanek 2011</a>; <a href="#ref-wilhelm2008">Wilhelm 2008</a>)</span>. For instance, during linked selection, if the user clicks and drags to select a rectangular region, we can do fast updates to the layer rendering the selection rectangle (since re-rendering a single rectangle is cheap) and throttle updates on the layer representing selected objects (since many objects have to be re-rendered, e.g. thousands of points in a scatterplot). Layers representing graphical elements independent of selection, such as axes, often do not have to be re-rendered at all.</p>
<p><span class="citation">Urbanek (<a href="#ref-urbanek2011">2011</a>)</span> identifies the following four fundamental graphical layers (ordered from top-most to bottom-most):</p>
<ul>
<li>Interaction layer</li>
<li>Selection layer</li>
<li>Objects layer</li>
<li>Background layer</li>
</ul>
<p>Additionally, in some data visualization systems, certain elements of the visualization may be rendered out-of-frame entirely. For instance, in web-based interactive visualization frameworks, some elements may be represented via external DOM nodes, e.g. a query pop-up may be represented via an independent <code>&lt;div&gt;</code>/<code>&lt;table&gt;</code> element. This can simplify rendering logic: for instance, in the case of the query pop-up, we can offload the work of rendering the table to the browser instead of having it to implement it ourselves. Similarly, many GUI platforms (including browsers) provide ready-made interactive inputs, such as buttons or sliders.</p>
</div>
<div id="geoms" class="section level3 hasAnchor" number="4.5.2">
<h3><span class="header-section-number">4.5.2</span> Geoms<a href="problems.html#geoms" class="anchor-section" aria-label="Anchor link to header"></a></h3>
<p>To visualize information, every plot relies on a primary set of graphical elements which directly represent the data. These objects, hereafter referred to as “geoms”, are of primary concern as they are essential for identifying trends. They also tend to be the most computationally expensive class of graphical elements to render. This high cost is due to the fact that the number of geoms often scales with the size of the data. For instance, in scatterplots and parallel coordinate plots, the number of geoms is typically equal to the number of rows. Likewise, in categorical plots like barplots and fluctuation diagrams, larger data set size often implies a greater number of unique categories to be rendered. Furthermore, many interactive features, such as zooming, panning, reordering, selection, and parametric interaction affect the visual attributes of geoms (either directly or by modifying the summary statistics underlying the plot), which makes re-rendering a frequent operation.</p>
<p>As mentioned in Section <a href="problems.html#frames">4.5.1</a>, geoms can be rendered in multiple frames stacked vertically in layers. This layering can be used to create more complex visualizations, or to streamline the rendering process. For instance, in data visualization systems such as <code>ggplot2</code> <span class="citation">(<a href="#ref-wickham2016">Wickham 2016</a>)</span> enable the creation of new visualization types by vertically layering compatible geoms, such as plotting individual points over boxplot boxes. Another popular example is plotting a computed regression fit over scatterplot points. Conversely, in interactive data visualization systems, layering is used to enhance rendering efficiency, by plotting a dynamic highlighting layer on top of a static “base” layer <span class="citation">(<a href="#ref-urbanek2011">Urbanek 2011</a>)</span>.</p>
<div id="rendering-functor" class="section level4 hasAnchor" number="4.5.2.1">
<h4><span class="header-section-number">4.5.2.1</span> Rendering geoms: A functor from summary statistics to graphics<a href="problems.html#rendering-functor" class="anchor-section" aria-label="Anchor link to header"></a></h4>
<p>Importantly, just as we can think of aggregation as a functor from the category of data subsets to the category of summary statistics (see Section <a href="problems.html#aggregation-functor">4.3.2.4</a>), so can we interpret rendering as a functor from the category of summary statistics to the category of graphics or geometric objects (geoms). Specifically, if the statistics underlying the plot form a hierarchy, then so should the geometric objects representing them, and the mapping from one to the other should preserve the inherent structure.</p>
<p>Formally, supposing that <span class="math inline">\(F: \mathcal{D} \to \mathcal{S}\)</span> is a functor from the category of data subsets to the category of summary statistics, then we can also define a functor <span class="math inline">\(H: \mathcal{S} \to \mathcal{G}\)</span> from the category of summary statistics to the category of geoms. By virtue of functor composition (see Section <a href="math.html#functors">11.0.0.10</a>), this automatically creates a new functor <span class="math inline">\(F ;H\)</span>, which corresponds to a mapping from the category of data subsets to the category of geoms. All together, this defines the following structure-preserving mappings:</p>
<p><span class="math display">\[\mathcal{D} \to \mathcal{S} \to \mathcal{G}\]</span></p>
<p>In more practical terms, this suggests that the geoms representing our data should have a structure which is compatible with that of the summary statistics. If the summary statistics are monoids, then the geoms should be too: they need an “empty” geom and a binary associative operation for merging two geoms into one. For most simple geometric objects, these properties are trivially satisfied. For example, rectangles and circular regions can be combined through stacking or layering, and line segments can be concatenated end-to-end. Importantly, this combination operation does not always necessarily have to involve “summing” underlying values. For instance, when combining two barplot bars, we can “cut off” the excess height of the taller bar and append the resulting segment to the shorter one, or equivalently, draw the shorter bar on top of the taller. When applied to bars sorted by height, this operation is unital and associative, yet does not result in summing the underlying values (see also Section <a href="problems.html#groups-inverses">4.3.2.8</a>).</p>
</div>
</div>
<div id="auxiliary-elements" class="section level3 hasAnchor" number="4.5.3">
<h3><span class="header-section-number">4.5.3</span> Auxiliary graphical elements<a href="problems.html#auxiliary-elements" class="anchor-section" aria-label="Anchor link to header"></a></h3>
<p>Beyond geoms, plots also contain auxiliary graphical elements such as grid lines, axis labels, and ticks. In contrast to geoms, these auxiliary graphical elements are typically fewer in a number and require less frequent re-rendering. For instance, a continuous axis is typically represented by only 4-6 labels (as an example, in R, the <code>pretty</code> function uses <code>n = 5</code> as the default number of <em>desired</em> intervals used to find axis breaks). Thus, rendering two continuous axes requires drawing just 8-12 text strings, which, in many plots, is considerably fewer than the number of geoms. Furthermore, interaction does not always require re-rendering the auxiliary elements. For instance, as was mentioned in Section <a href="problems.html#stacking-part-whole">4.3.1.4</a>, in monoidal plots like stacked barplots and histograms, axis limits are constant throughout linked selection, and so the axis labels do not need to be re-rendered. While other types of interactions, such as zooming and panning, do require re-rendering of axis labels, this is usually still relatively inexpensive when compared to the rendering of geoms. Finally, some auxiliary graphical elements require little to no re-rendering. For instance, the only time when axis titles need to be re-rendered is during representation switching, such as when transforming a barplot to a spineplot.</p>
<p>For many auxiliary graphical elements derive all of the required information from the plot scales. For instance, axis labels, ticks, and grid lines can be obtained from the x- and y-scales. Axis titles are also often specified during scale construction or inferred from the data if not explicitly set. Beyond that, many data visualization systems also allow users to insert custom primitives such as text annotations, polygons, or lines. These can be used to enhance the visualization: for instance, polygons can be used as ribbons to highlight specific data ranges, and lines can be used to show trend lines computed from an arbitrary statistical model. However, it is important to note that, in interactive data visualization systems, due to being provided externally, these auxiliary graphical elements cannot be integrated with data-dependent interactions such as linked selection.</p>
</div>
</div>
<div id="summary-1" class="section level2 hasAnchor" number="4.6">
<h2><span class="header-section-number">4.6</span> Summary<a href="problems.html#summary-1" class="anchor-section" aria-label="Anchor link to header"></a></h2>
<p>Creating data visualizations involves a complex series of steps which together form the data visualization pipeline. This pipeline typically includes partitioning the data into subsets, computing summary statistics on these subsets, scaling the summaries and encoding them as visual attributes, and finally rendering them as geometric objects. Interactivity can affect all four stages of this process, and any resulting changes need to be propagated appropriately.</p>
<p>Importantly, a core argument I have made throughout this section is that the four steps of the data visualization are not independent, of each other or of user interaction. Specifically, the geometric objects we draw need to be congruent with the summary statistics computed on the underlying data, as well as with any interactions we may wish to incorporate. In other words, what we can <em>do</em> with our visualization is fundamentally determined by what the visualization <em>is</em>. This perspective goes against the model established in the Grammar of Graphics <span class="citation">(<a href="#ref-wilkinson2012">Wilkinson 2012</a>)</span>, which views plots as composed out of independent, modular components. While this independence model has many appealing properties, I argue that it is inadequate for reasoning about visualizations exhibiting hierarchical structure, such as those which naturally arise when highlighting parts of objects as a result of linked selection (see Section <a href="problems.html#stacking-not-graphical">4.3.1.2</a>).</p>
<p>As an alternative, I proposed a simple algebraic model based on some fundamental concepts from category theory. Specifically, I conceptualize the whole data visualization pipeline as a functor (see Section <a href="problems.html#structure-functors">4.3.2.3</a>), mapping objects from a category (hierarchy) of data subsets to a category of objects. This functor is in turn composed of two other functors, the first which maps data subsets to sets of summary statistics (see Section <a href="problems.html#aggregation-functor">4.3.2.4</a>), and another which maps the summary statistics to geometric objects (see Section <a href="problems.html#rendering-functor">4.5.2.1</a>). The key point is that, for the visualization to be valid, the two mappings need to preserve the underlying structure. This naturally identifies certain algebraic structures as candidates for our statistics and geometric objects: namely, groups and monoids.</p>
<p>The model allow us to identify which combinations of graphics and statistics will produce meaningful objects composed of parts, which in turn allow us to identify which visualizations will behave well under features like linked selection. Further, it also allows us to identify what kinds of linked selection will work. For instance, if our visualization (graphics and underlying statistics) is composed of monoids, we know it will behave well under single-group linked selection. However, if we want to highlight several selection groups simultaneously, then we also require the presence of inverses, necessitating groups.</p>

</div>
</div>
<h3> References<a href="references.html#references" class="anchor-section" aria-label="Anchor link to header"></a></h3>
<div id="refs" class="references csl-bib-body hanging-indent" entry-spacing="0">
<div id="ref-adam2017" class="csl-entry">
Adam, Elie M. 2017. <span>“Systems, Generativity and Interactional Effects.”</span> PhD thesis, Massachusetts Institute of Technology.
</div>
<div id="ref-alsallakh2013" class="csl-entry">
Alsallakh, Bilal, Wolfgang Aigner, Silvia Miksch, and Helwig Hauser. 2013. <span>“Radial Sets: Interactive Visual Analysis of Large Overlapping Sets.”</span> <em>IEEE Transactions on Visualization and Computer Graphics</em> 19 (12): 2496–2505.
</div>
<div id="ref-alsallakh2014" class="csl-entry">
Alsallakh, Bilal, Luana Micallef, Wolfgang Aigner, Helwig Hauser, Silvia Miksch, and Peter Rodgers. 2014. <span>“Visualizing Sets and Set-Typed Data: State-of-the-Art and Future Challenges.”</span> <em>Eurographics Conference on Visualization (EuroVis)</em>.
</div>
<div id="ref-beckmann1995" class="csl-entry">
Beckmann, Peter E. 1995. <span>“On the Problem of Visualizing Point Distributions in High Dimensional Spaces.”</span> <em>Computers &amp; Graphics</em> 19 (4): 617–29.
</div>
<div id="ref-benjamin2019" class="csl-entry">
Benjamin, Daniel J. 2019. <span>“Errors in Probabilistic Reasoning and Judgment Biases.”</span> <em>Handbook of Behavioral Economics: Applications and Foundations 1</em> 2: 69–186.
</div>
<div id="ref-bertin1983" class="csl-entry">
Bertin, Jacques. 1983. <em>Semiology of Graphics</em>. University of Wisconsin press.
</div>
<div id="ref-bishop2006" class="csl-entry">
Bishop, Christopher M, and Nasser M Nasrabadi. 2006. <em>Pattern Recognition and Machine Learning</em>. Vol. 4. 4. Springer.
</div>
<div id="ref-blitzstein2019" class="csl-entry">
Blitzstein, Joseph K, and Jessica Hwang. 2019. <em>Introduction to Probability</em>. Chapman; Hall/CRC.
</div>
<div id="ref-bostock2011" class="csl-entry">
Bostock, Michael, Vadim Ogievetsky, and Jeffrey Heer. 2011. <span>“D<span class="math inline">\(^3\)</span> Data-Driven Documents.”</span> <em>IEEE Transactions on Visualization and Computer Graphics</em> 17 (12): 2301–9.
</div>
<div id="ref-bostock2022" class="csl-entry">
Bostock, Mike. 2022. <span>“D3.js - Data-Driven Documents.”</span> <a href="https://d3js.org">https://d3js.org</a>.
</div>
<div id="ref-buja1996" class="csl-entry">
Buja, Andreas, Dianne Cook, and Deborah F Swayne. 1996. <span>“Interactive High-Dimensional Data Visualization.”</span> <em>Journal of Computational and Graphical Statistics</em> 5 (1): 78–99.
</div>
<div id="ref-byron2008" class="csl-entry">
Byron, Lee, and Martin Wattenberg. 2008. <span>“Stacked Graphs–Geometry &amp; Aesthetics.”</span> <em>IEEE Transactions on Visualization and Computer Graphics</em> 14 (6): 1245–52.
</div>
<div id="ref-cairo2014" class="csl-entry">
Cairo, Alberto. 2014. <span>“Graphics Lies, Misleading Visuals: Reflections on the Challenges and Pitfalls of Evidence-Driven Visual Communication.”</span> In <em>New Challenges for Data Design</em>, 103–16. Springer.
</div>
<div id="ref-cairo2016" class="csl-entry">
———. 2016. <em>The Truthful Art: Data, Charts, and Maps for Communication</em>. New Riders.
</div>
<div id="ref-cairo2019" class="csl-entry">
———. 2019. <em>How Charts Lie: Getting Smarter about Visual Information</em>. WW Norton &amp; Company.
</div>
<div id="ref-shiny2024" class="csl-entry">
Chang, Winston, Joe Cheng, JJ Allaire, Carson Sievert, Barret Schloerke, Yihui Xie, Jeff Allen, Jonathan McPherson, Alan Dipert, and Barbara Borges. 2024. <em>Shiny: Web Application Framework for r</em>. <a href="https://CRAN.R-project.org/package=shiny">https://CRAN.R-project.org/package=shiny</a>.
</div>
<div id="ref-chen2008" class="csl-entry">
Chen, Chun-houh, Wolfgang Härdle, Antony Unwin, Dianne Cook, Andreas Buja, Eun-Kyung Lee, and Hadley Wickham. 2008. <span>“Grand Tours, Projection Pursuit Guided Tours, and Manual Controls.”</span> <em>Handbook of Data Visualization</em>, 295–314.
</div>
<div id="ref-chi2000" class="csl-entry">
Chi, Ed Huai-hsin. 2000. <span>“A Taxonomy of Visualization Techniques Using the Data State Reference Model.”</span> In <em>IEEE Symposium on Information Visualization 2000. INFOVIS 2000. Proceedings</em>, 69–75. IEEE.
</div>
<div id="ref-cleveland1985" class="csl-entry">
Cleveland, William S. 1985. <em>The Elements of Graphing Data</em>. Wadsworth Publ. Co.
</div>
<div id="ref-cleveland1993" class="csl-entry">
———. 1993. <em>Visualizing Data</em>. Hobart press.
</div>
<div id="ref-cleveland1984" class="csl-entry">
Cleveland, William S, and Robert McGill. 1984. <span>“Graphical Perception: Theory, Experimentation, and Application to the Development of Graphical Methods.”</span> <em>Journal of the American Statistical Association</em> 79 (387): 531–54.
</div>
<div id="ref-codd1970" class="csl-entry">
Codd, Edgar F. 1970. <span>“A Relational Model of Data for Large Shared Data Banks.”</span> <em>Communications of the ACM</em> 13 (6): 377–87.
</div>
<div id="ref-conway2017" class="csl-entry">
Conway, Jake R, Alexander Lex, and Nils Gehlenborg. 2017. <span>“UpSetR: An r Package for the Visualization of Intersecting Sets and Their Properties.”</span> <em>Bioinformatics</em> 33 (18): 2938–40.
</div>
<div id="ref-dalal1989" class="csl-entry">
Dalal, Siddhartha R, Edward B Fowlkes, and Bruce Hoadley. 1989. <span>“Risk Analysis of the Space Shuttle: Pre-Challenger Prediction of Failure.”</span> <em>Journal of the American Statistical Association</em> 84 (408): 945–57.
</div>
<div id="ref-dastani2002" class="csl-entry">
Dastani, Mehdi. 2002. <span>“The Role of Visual Perception in Data Visualization.”</span> <em>Journal of Visual Languages &amp; Computing</em> 13 (6): 601–22.
</div>
<div id="ref-rmeta2024" class="csl-entry">
Data Science Meta. 2024. <span>“CRAN r Packages by Number of Downloads.”</span> <a href="https://www.datasciencemeta.com/rpackages">https://www.datasciencemeta.com/rpackages</a>.
</div>
<div id="ref-dimara2019" class="csl-entry">
Dimara, Evanthia, and Charles Perin. 2019. <span>“What Is Interaction for Data Visualization?”</span> <em>IEEE Transactions on Visualization and Computer Graphics</em> 26 (1): 119–29.
</div>
<div id="ref-referendum2020" class="csl-entry">
Electoral Commission New Zealand. 2020. <span>“Official Referendum Results Released.”</span> <a href="https://elections.nz/media-and-news/2020/official-referendum-results-released">https://elections.nz/media-and-news/2020/official-referendum-results-released</a>.
</div>
<div id="ref-election2023" class="csl-entry">
———. 2023. <span>“E9 Statistics - Overall Results.”</span> <a href="https://www.electionresults.govt.nz/electionresults_2023/index.html">https://www.electionresults.govt.nz/electionresults_2023/index.html</a>.
</div>
<div id="ref-fong2019" class="csl-entry">
Fong, Brendan, and David I Spivak. 2019. <em>An Invitation to Applied Category Theory: Seven Sketches in Compositionality</em>. Cambridge University Press.
</div>
<div id="ref-franconeri2021" class="csl-entry">
Franconeri, Steven L, Lace M Padilla, Priti Shah, Jeffrey M Zacks, and Jessica Hullman. 2021. <span>“The Science of Visual Data Communication: What Works.”</span> <em>Psychological Science in the Public Interest</em> 22 (3): 110–61.
</div>
<div id="ref-franconeri2003" class="csl-entry">
Franconeri, Steven L, and Daniel J Simons. 2003. <span>“Moving and Looming Stimuli Capture Attention.”</span> <em>Perception &amp; Psychophysics</em> 65 (7): 999–1010.
</div>
<div id="ref-head2015" class="csl-entry">
Head, Megan L, Luke Holman, Rob Lanfear, Andrew T Kahn, and Michael D Jennions. 2015. <span>“The Extent and Consequences of p-Hacking in Science.”</span> <em>PLoS Biology</em> 13 (3): e1002106.
</div>
<div id="ref-heer2010" class="csl-entry">
Heer, Jeffrey, and Michael Bostock. 2010. <span>“Crowdsourcing Graphical Perception: Using Mechanical Turk to Assess Visualization Design.”</span> In <em>Proceedings of the SIGCHI Conference on Human Factors in Computing Systems</em>, 203–12.
</div>
<div id="ref-hellerstein1999" class="csl-entry">
Hellerstein, J. M., R. Avnur, A. Chou, C. Hidber, C. Olston, and V. Raman. 1999. <span>“<span class="nocase">Interactive data analysis: the Control project</span>.”</span> <em>Computer</em> 32 (8): 51–59. <a href="https://doi.org/10.1109/2.781635">https://doi.org/10.1109/2.781635</a>.
</div>
<div id="ref-hibbard1994" class="csl-entry">
Hibbard, William L, Charles R Dyer, and Brian E Paul. 1994. <span>“A Lattice Model for Data Display.”</span> In <em>Proceedings Visualization’94</em>, 310–17. IEEE.
</div>
<div id="ref-hutchins1999" class="csl-entry">
Hutchins, Matthew A. 1999. <em>Modelling Visualisation Using Formal Algebra</em>. Australian National University.
</div>
<div id="ref-kahn2005" class="csl-entry">
Kahn, Michael. 2005. <span>“An Exhalent Problem for Teaching Statistics.”</span> <em>Journal of Statistics Education</em> 13 (2).
</div>
<div id="ref-keim2002" class="csl-entry">
Keim, Daniel A. 2002. <span>“Information Visualization and Visual Data Mining.”</span> <em>IEEE Transactions on Visualization and Computer Graphics</em> 8 (1): 1–8.
</div>
<div id="ref-keller2024" class="csl-entry">
Keller, Mark S, Trevor Manz, and Nils Gehlenborg. 2024. <span>“Use-Coordination: Model, Grammar, and Library for Implementation of Coordinated Multiple Views.”</span> In <em>2024 IEEE Visualization and Visual Analytics (VIS)</em>, 166–70. IEEE.
</div>
<div id="ref-kerr1998" class="csl-entry">
Kerr, Norbert L. 1998. <span>“HARKing: Hypothesizing After the Results Are Known.”</span> <em>Personality and Social Psychology Review</em> 2 (3): 196–217.
</div>
<div id="ref-kim2022" class="csl-entry">
Kim, Hyeok, Ryan Rossi, Fan Du, Eunyee Koh, Shunan Guo, Jessica Hullman, and Jane Hoffswell. 2022. <span>“Cicero: A Declarative Grammar for Responsive Visualization.”</span> In <em>Proceedings of the 2022 CHI Conference on Human Factors in Computing Systems</em>, 1–15.
</div>
<div id="ref-kindlmann2014" class="csl-entry">
Kindlmann, Gordon, and Carlos Scheidegger. 2014. <span>“An Algebraic Process for Visualization Design.”</span> <em>IEEE Transactions on Visualization and Computer Graphics</em> 20 (12): 2181–90.
</div>
<div id="ref-kolmogorov2018" class="csl-entry">
Kolmogorov, Andrei Nikolaevich, and Albert T Bharucha-Reid. 2018. <em>Foundations of the Theory of Probability: Second English Edition</em>. Courier Dover Publications.
</div>
<div id="ref-kosara2016" class="csl-entry">
Kosara, Robert. 2016. <span>“Presentation-Oriented Visualization Techniques.”</span> <em>IEEE Computer Graphics and Applications</em> 36 (1): 80–85.
</div>
<div id="ref-krzywinski2013" class="csl-entry">
Krzywinski, Martin. 2013. <span>“Axes, Ticks and Grids.”</span> <em>Nature Methods</em> 10 (February): 183. <a href="https://doi.org/10.1038/nmeth.2337">https://doi.org/10.1038/nmeth.2337</a>.
</div>
<div id="ref-lawvere2009" class="csl-entry">
Lawvere, F William, and Stephen H Schanuel. 2009. <em>Conceptual Mathematics: A First Introduction to Categories</em>. Cambridge University Press.
</div>
<div id="ref-lex2014" class="csl-entry">
Lex, Alexander, Nils Gehlenborg, Hendrik Strobelt, Romain Vuillemot, and Hanspeter Pfister. 2014. <span>“UpSet: Visualization of Intersecting Sets.”</span> <em>IEEE Transactions on Visualization and Computer Graphics</em> 20 (12): 1983–92.
</div>
<div id="ref-lin2013" class="csl-entry">
Lin, Jimmy. 2013. <span>“Monoidify! Monoids as a Design Principle for Efficient Mapreduce Algorithms.”</span> <em>arXiv Preprint arXiv:1304.7544</em>.
</div>
<div id="ref-lisnic2024" class="csl-entry">
Lisnic, Maxim, Zach Cutler, Marina Kogan, and Alexander Lex. 2024. <span>“Visualization Guardrails: Designing Interventions Against Cherry-Picking in Interactive Data Explorers.”</span> <a href="https://osf.io/preprints/osf/4j9nr">https://osf.io/preprints/osf/4j9nr</a>.
</div>
<div id="ref-mathematicalmathematics2024" class="csl-entry">
Martínez, Alejandro. 2024. <span>“Rustic OC Instead of Being Pr[o]du[c]tive.”</span> <a href="https://www.facebook.com/photo/?fbid=8191809750834143&amp;set=g.1567682496877142">https://www.facebook.com/photo/?fbid=8191809750834143&amp;set=g.1567682496877142</a>.
</div>
<div id="ref-mcdonald1990" class="csl-entry">
McDonald, John Alan, Werner Stuetzle, and Andreas Buja. 1990. <span>“Painting Multiple Views of Complex Objects.”</span> <em>ACM SIGPLAN Notices</em> 25 (10): 245–57.
</div>
<div id="ref-mcnutt2022" class="csl-entry">
McNutt, Andrew M. 2022. <span>“No Grammar to Rule Them All: A Survey of Json-Style Dsls for Visualization.”</span> <em>IEEE Transactions on Visualization and Computer Graphics</em> 29 (1): 160–70.
</div>
<div id="ref-michell1986" class="csl-entry">
Michell, Joel. 1986. <span>“Measurement Scales and Statistics: A Clash of Paradigms.”</span> <em>Psychological Bulletin</em> 100 (3): 398.
</div>
<div id="ref-milewski2018" class="csl-entry">
Milewski, Bartosz. 2018. <em>Category Theory for Programmers</em>. Blurb.
</div>
<div id="ref-murrell2005" class="csl-entry">
Murrell, Paul. 2005. <em>R Graphics</em>. Chapman; Hall/CRC.
</div>
<div id="ref-nlab2024e" class="csl-entry">
nLab. 2025. <span>“Monoidal Preorder in nLab.”</span> <a href="https://ncatlab.org/nlab/show/monoidal+preorder">https://ncatlab.org/nlab/show/monoidal+preorder</a>.
</div>
<div id="ref-d3-scale2024" class="csl-entry">
Observable. 2024. <span>“D3-Scale <span><span class="math inline">\(\vert\)</span></span> D3 by Observable.”</span> <a href="https://d3js.org/d3-scale">https://d3js.org/d3-scale</a>.
</div>
<div id="ref-parent2013" class="csl-entry">
Parent, Sean. 2013. <span>“Inheritance Is the Base Class of Evil.”</span> <em>GoingNative</em>. Youtube. <a href="https://www.youtube.com/watch?v=2bLkxj6EVoM&amp;list=PLM5v5JsFsgP21eB4z2mIL8upkvT00Tw9B">https://www.youtube.com/watch?v=2bLkxj6EVoM&amp;list=PLM5v5JsFsgP21eB4z2mIL8upkvT00Tw9B</a>.
</div>
<div id="ref-parent2018" class="csl-entry">
———. 2018. <span>“<span>Generic Programming</span>.”</span> Pacific++. <a href="https://www.youtube.com/watch?v=iwJpxWHuZQY">https://www.youtube.com/watch?v=iwJpxWHuZQY</a>.
</div>
<div id="ref-petricek2020" class="csl-entry">
Petricek, Tomas. 2020. <span>“Designing Composable Functional Libraries.”</span> <em>Lambda Days</em>. <a href="https://www.youtube.com/watch?v=G1Dp0NtQHeY">https://www.youtube.com/watch?v=G1Dp0NtQHeY</a>.
</div>
<div id="ref-petricek2021" class="csl-entry">
———. 2021. <span>“Composable Data Visualizations.”</span> <em>Journal of Functional Programming</em> 31: e13.
</div>
<div id="ref-pinter2010" class="csl-entry">
Pinter, Charles C. 2010. <em>A Book of Abstract Algebra</em>. Courier Corporation.
</div>
<div id="ref-plotly2023" class="csl-entry">
Plotly Inc. 2023. <span>“<span>Plotly: Low-Code Data App Development</span>.”</span> <a href="https://plotly.com">https://plotly.com</a>.
</div>
<div id="ref-quadri2021" class="csl-entry">
Quadri, Ghulam Jilani, and Paul Rosen. 2021. <span>“A Survey of Perception-Based Visualization Studies by Task.”</span> <em>IEEE Transactions on Visualization and Computer Graphics</em>.
</div>
<div id="ref-roberts2000" class="csl-entry">
Roberts, Jonathan C, Rob Knight, Mark Gibbins, and Nimesh Patel. 2000. <span>“Multiple Window Visualization on the Web Using VRML and the EAI.”</span> In <em>Proceedings of the Seventh UK VR-SIG Conference</em>, 149–57. SChEME.
</div>
<div id="ref-satyanarayan2016" class="csl-entry">
Satyanarayan, Arvind, Dominik Moritz, Kanit Wongsuphasawat, and Jeffrey Heer. 2016. <span>“Vega-Lite: A Grammar of Interactive Graphics.”</span> <em>IEEE Transactions on Visualization and Computer Graphics</em> 23 (1): 341–50.
</div>
<div id="ref-satyanarayan2015" class="csl-entry">
Satyanarayan, Arvind, Ryan Russell, Jane Hoffswell, and Jeffrey Heer. 2015. <span>“Reactive Vega: A Streaming Dataflow Architecture for Declarative Interactive Visualization.”</span> <em>IEEE Transactions on Visualization and Computer Graphics</em> 22 (1): 659–68.
</div>
<div id="ref-satyanarayan2014" class="csl-entry">
Satyanarayan, Arvind, Kanit Wongsuphasawat, and Jeffrey Heer. 2014. <span>“Declarative Interaction Design for Data Visualization.”</span> In <em>Proceedings of the 27th Annual ACM Symposium on User Interface Software and Technology</em>, 669–78.
</div>
<div id="ref-shirley2009" class="csl-entry">
Shirley, Peter, Michael Ashikhmin, and Steve Marschner. 2009. <em>Fundamentals of Computer Graphics</em>. AK Peters/CRC Press.
</div>
<div id="ref-sievert2020" class="csl-entry">
Sievert, Carson. 2020. <em>Interactive Web-Based Data Visualization with r, Plotly, and Shiny</em>. Chapman; Hall/CRC.
</div>
<div id="ref-slingsby2009" class="csl-entry">
Slingsby, Aidan, Jason Dykes, and Jo Wood. 2009. <span>“Configuring Hierarchical Layouts to Address Research Questions.”</span> <em>IEEE Transactions on Visualization and Computer Graphics</em> 15 (6): 977–84.
</div>
<div id="ref-smeltzer2018" class="csl-entry">
Smeltzer, Karl, and Martin Erwig. 2018. <span>“A Domain-Specific Language for Exploratory Data Visualization.”</span> In <em>Proceedings of the 17th ACM SIGPLAN International Conference on Generative Programming: Concepts and Experiences</em>, 1–13.
</div>
<div id="ref-smeltzer2014" class="csl-entry">
Smeltzer, Karl, Martin Erwig, and Ronald Metoyer. 2014. <span>“A Transformational Approach to Data Visualization.”</span> In <em>Proceedings of the 2014 International Conference on Generative Programming: Concepts and Experiences</em>, 53–62.
</div>
<div id="ref-stepanov2009" class="csl-entry">
Stepanov, Alexander A, and Paul McJones. 2009. <em>Elements of Programming</em>. Addison-Wesley Professional.
</div>
<div id="ref-stepanov2014" class="csl-entry">
Stepanov, Alexander A, and Daniel E Rose. 2014. <em>From Mathematics to Generic Programming</em>. Pearson Education.
</div>
<div id="ref-stevens1946" class="csl-entry">
Stevens, Stanley Smith. 1946. <span>“On the Theory of Scales of Measurement.”</span> <em>Science</em> 103 (2684): 677–80.
</div>
<div id="ref-tager1979" class="csl-entry">
Tager, Ira B, Scott T Weiss, Bernard Rosner, and Frank E Speizer. 1979. <span>“Effect of Parental Cigarette Smoking on the Pulmonary Function of Children.”</span> <em>American Journal of Epidemiology</em> 110 (1): 15–26.
</div>
<div id="ref-theus2002" class="csl-entry">
Theus, Martin. 2002. <span>“<span class="nocase">Interactive Data Visualization using Mondrian</span>.”</span> <em>J. Stat. Soft.</em> 7 (November): 1–9. <a href="https://doi.org/10.18637/jss.v007.i11">https://doi.org/10.18637/jss.v007.i11</a>.
</div>
<div id="ref-thudt2016" class="csl-entry">
Thudt, Alice, Jagoda Walny, Charles Perin, Fateme Rajabiyazdi, Lindsay MacDonald, Diane Vardeleon, Saul Greenberg, and Sheelagh Carpendale. 2016. <span>“Assessing the Readability of Stacked Graphs.”</span> In <em>Proceedings of Graphics Interface Conference (GI)</em>.
</div>
<div id="ref-tierney2023" class="csl-entry">
Tierney, Nicholas, and Dianne Cook. 2023. <span>“<span class="nocase">Expanding Tidy Data Principles to Facilitate Missing Data Exploration, Visualization and Assessment of Imputations</span>.”</span> <em>J. Stat. Soft.</em> 105 (February): 1–31. <a href="https://doi.org/10.18637/jss.v105.i07">https://doi.org/10.18637/jss.v105.i07</a>.
</div>
<div id="ref-tufte2001" class="csl-entry">
Tufte, Edward R. 2001. <em>The Visual Display of Quantitative Information</em>. Cheshire, Connecticut: Graphics Press LLC.
</div>
<div id="ref-tukey1993" class="csl-entry">
Tukey, John W. 1993. <span>“Graphic Comparisons of Several Linked Aspects: Alternatives and Suggested Principles.”</span> <em>Journal of Computational and Graphical Statistics</em> 2 (1): 1–33.
</div>
<div id="ref-tversky1983" class="csl-entry">
Tversky, Amos, and Daniel Kahneman. 1983. <span>“Extensional Versus Intuitive Reasoning: The Conjunction Fallacy in Probability Judgment.”</span> <em>Psychological Review</em> 90 (4): 293.
</div>
<div id="ref-unwin1996" class="csl-entry">
Unwin, Antony, George Hawkins, Heike Hofmann, and Bernd Siegl. 1996. <span>“Interactive Graphics for Data Sets with Missing Values—MANET.”</span> <em>Journal of Computational and Graphical Statistics</em> 5 (2): 113–22.
</div>
<div id="ref-urbanek2011" class="csl-entry">
Urbanek, Simon. 2011. <span>“iPlots eXtreme: Next-Generation Interactive Graphics Design and Implementation of Modern Interactive Graphics.”</span> <em>Computational Statistics</em> 26 (3): 381–93.
</div>
<div id="ref-vaneerd2023" class="csl-entry">
Van Eerd, Tony. 2023. <span>“Value Oriented Programming Part 1: You Say You Want to Write a Function.”</span> <em>CppNow</em>. Youtube. <a href="https://www.youtube.com/watch?v=b4p_tcLYDV0">https://www.youtube.com/watch?v=b4p_tcLYDV0</a>.
</div>
<div id="ref-vaneerd2024" class="csl-entry">
———. 2024. <span>“Value Oriented Programming Part v - Return of the Values.”</span> <em>CppNow</em>. Youtube. <a href="https://www.youtube.com/watch?v=sc1guyo5Rso">https://www.youtube.com/watch?v=sc1guyo5Rso</a>.
</div>
<div id="ref-vanderplas2020" class="csl-entry">
Vanderplas, Susan, Dianne Cook, and Heike Hofmann. 2020. <span>“Testing Statistical Charts: What Makes a Good Graph?”</span> <em>Annual Review of Statistics and Its Application</em> 7: 61–88.
</div>
<div id="ref-velleman1993" class="csl-entry">
Velleman, Paul F, and Leland Wilkinson. 1993. <span>“Nominal, Ordinal, Interval, and Ratio Typologies Are Misleading.”</span> <em>The American Statistician</em> 47 (1): 65–72.
</div>
<div id="ref-vickers2012" class="csl-entry">
Vickers, Paul, Joe Faith, and Nick Rossiter. 2012. <span>“Understanding Visualization: A Formal Approach Using Category Theory and Semiotics.”</span> <em>IEEE Transactions on Visualization and Computer Graphics</em> 19 (6): 1048–61.
</div>
<div id="ref-wickham2010" class="csl-entry">
Wickham, Hadley. 2010. <span>“A Layered Grammar of Graphics.”</span> <em>Journal of Computational and Graphical Statistics</em> 19 (1): 3–28.
</div>
<div id="ref-wickham2016" class="csl-entry">
———. 2016. <em>Ggplot2: Elegant Graphics for Data Analysis (2e)</em>. Springer-Verlag New York. <a href="https://ggplot2.tidyverse.org">https://ggplot2.tidyverse.org</a>.
</div>
<div id="ref-ggplot2repo2024" class="csl-entry">
———. 2024. <span>“Ggplot2.”</span> <em>GitHub</em>. <a href="https://github.com/tidyverse/ggplot2">https://github.com/tidyverse/ggplot2</a>.
</div>
<div id="ref-wickham2009" class="csl-entry">
Wickham, Hadley, Michael Lawrence, Dianne Cook, Andreas Buja, Heike Hofmann, and Deborah F Swayne. 2009. <span>“The Plumbing of Interactive Graphics.”</span> <em>Computational Statistics</em> 24: 207–15.
</div>
<div id="ref-wickham2023" class="csl-entry">
Wickham, Hadley, Thomas Lin Pedersen, and Dana Seidel. 2023. <em>Scales: Scale Functions for Visualization</em>. <a href="https://CRAN.R-project.org/package=scales">https://CRAN.R-project.org/package=scales</a>.
</div>
<div id="ref-wilhelm2003" class="csl-entry">
Wilhelm, Adalbert. 2003. <span>“<span class="nocase">User interaction at various levels of data displays</span>.”</span> <em>Comput. Statist. Data Anal.</em> 43 (4): 471–94. <a href="https://doi.org/10.1016/S0167-9473(02)00288-8">https://doi.org/10.1016/S0167-9473(02)00288-8</a>.
</div>
<div id="ref-wilhelm2008" class="csl-entry">
———. 2008. <span>“Linked Views for Visual Exploration.”</span> In <em>Handbook of Data Visualization</em>, 200–214. Springer Science &amp; Business Media.
</div>
<div id="ref-wilke2019" class="csl-entry">
Wilke, Claus O. 2019. <em>Fundamentals of Data Visualization: A Primer on Making Informative and Compelling Figures</em>. O’Reilly Media.
</div>
<div id="ref-wilkinson2012" class="csl-entry">
Wilkinson, Leland. 2012. <em>The Grammar of Graphics</em>. Springer.
</div>
<div id="ref-wills2008" class="csl-entry">
Wills, Graham. 2008. <span>“Linked Data Views.”</span> In <em>Handbook of Data Visualization</em>, 217–41. ch. II. 9. Springer Berlin/Heidelberg, Germany.
</div>
<div id="ref-wills2011" class="csl-entry">
———. 2011. <em>Visualizing Time: Designing Graphical Representations for Statistical Data</em>. Springer Science &amp; Business Media.
</div>
<div id="ref-wu2022" class="csl-entry">
Wu, Eugene. 2022. <span>“View Composition Algebra for Ad Hoc Comparison.”</span> <em>IEEE Transactions on Visualization and Computer Graphics</em> 28 (6): 2470–85.
</div>
<div id="ref-wu2024" class="csl-entry">
Wu, Eugene, and Remco Chang. 2024. <span>“Design-Specific Transformations in Visualization.”</span> <em>arXiv Preprint arXiv:2407.06404</em>.
</div>
<div id="ref-yorgey2012" class="csl-entry">
Yorgey, Brent A. 2012. <span>“Monoids: Theme and Variations (Functional Pearl).”</span> <em>ACM SIGPLAN Notices</em> 47 (12): 105–16.
</div>
<div id="ref-ziemkiewicz2009" class="csl-entry">
Ziemkiewicz, Caroline, and Robert Kosara. 2009. <span>“Embedding Information Visualization Within Visual Representation.”</span> In <em>Advances in Information and Intelligent Systems</em>, 307–26. Springer.
</div>
</div>
<div class="footnotes">
<hr />
<ol start="1">
<li id="fn1"><p>Technically, this is also a function of the points’ radii, and thus to definitely guarantee that no points will overlap the plot’s edges, the axis limits would have to be expanded by a fraction that is greater than the radius of the largest point, however, this is rarely done in practice.<a href="problems.html#fnref1" class="footnote-back">↩︎</a></p></li>
<li id="fn2"><p>But, interestingly, one-dimensional kernel density polygons are once again disjoint.<a href="problems.html#fnref2" class="footnote-back">↩︎</a></p></li>
<li id="fn3"><p>It is not too difficult to create this data structure: see Section <a href="system.html#product-factors">6.4.4.4.4</a>.<a href="problems.html#fnref3" class="footnote-back">↩︎</a></p></li>
<li id="fn4"><p>Being the top most downloaded CRAN package as of 4th of December 2024, <span class="citation">Data Science Meta (<a href="#ref-rmeta2024">2024</a>)</span><a href="problems.html#fnref4" class="footnote-back">↩︎</a></p></li>
<li id="fn5"><p>In fact, with a bit of high-school algebra, it can be shown that the average function will appear associative for any triplets <span class="math inline">\(x, y, z\)</span> where <span class="math inline">\(3x + 3y + 6z = 4x + 4y + 4z\)</span> holds.<a href="problems.html#fnref5" class="footnote-back">↩︎</a></p></li>
<li id="fn6"><p>The function signature should really include the data and visual attribute limits as well, i.e. <span class="math inline">\(s(d; d_{min}, d_{max}, v_{min}, v_{max})\)</span>, I omitted those here to prevent the signature from becoming too busy.<a href="problems.html#fnref6" class="footnote-back">↩︎</a></p></li>
<li id="fn7"><p>More on this below.<a href="problems.html#fnref7" class="footnote-back">↩︎</a></p></li>
</ol>
</div>
            </section>

          </div>
        </div>
      </div>
<a href="background.html" class="navigation navigation-prev " aria-label="Previous page"><i class="fa fa-angle-left"></i></a>
<a href="goals.html" class="navigation navigation-next " aria-label="Next page"><i class="fa fa-angle-right"></i></a>
    </div>
  </div>
<script src="libs/gitbook-2.6.7/js/app.min.js"></script>
<script src="libs/gitbook-2.6.7/js/clipboard.min.js"></script>
<script src="libs/gitbook-2.6.7/js/plugin-search.js"></script>
<script src="libs/gitbook-2.6.7/js/plugin-sharing.js"></script>
<script src="libs/gitbook-2.6.7/js/plugin-fontsettings.js"></script>
<script src="libs/gitbook-2.6.7/js/plugin-bookdown.js"></script>
<script src="libs/gitbook-2.6.7/js/jquery.highlight.js"></script>
<script src="libs/gitbook-2.6.7/js/plugin-clipboard.js"></script>
<script>
gitbook.require(["gitbook"], function(gitbook) {
gitbook.start({
  "sharing": {
    "github": false,
    "facebook": true,
    "twitter": true,
    "linkedin": false,
    "weibo": false,
    "instapaper": false,
    "vk": false,
    "whatsapp": false,
    "all": ["facebook", "twitter", "linkedin", "weibo", "instapaper"]
  },
  "fontsettings": {
    "theme": "white",
    "family": "sans",
    "size": 2
  },
  "edit": {
    "link": null,
    "text": null
  },
  "history": {
    "link": null,
    "text": null
  },
  "view": {
    "link": null,
    "text": null
  },
  "download": ["_main.pdf"],
  "search": {
    "engine": "fuse",
    "options": null
  },
  "toc": {
    "collapse": "subsection"
  }
});
});
</script>

<!-- dynamically load mathjax for compatibility with self-contained -->
<script>
  (function () {
    var script = document.createElement("script");
    script.type = "text/javascript";
    var src = "true";
    if (src === "" || src === "true") src = "https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.9/latest.js?config=TeX-MML-AM_CHTML";
    if (location.protocol !== "file:")
      if (/^https?:/.test(src))
        src = src.replace(/^https?:/, '');
    script.src = src;
    document.getElementsByTagName("head")[0].appendChild(script);
  })();
</script>
</body>

</html>
