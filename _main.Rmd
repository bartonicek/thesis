---
title: "The Fabric of Interactive Visualization"
subtitle: "From the Algebra of Graphics, Statistics, and Interaction to Practical Implementation"
author: "Adam Bartonicek"
site: bookdown::bookdown_site
documentclass: book
always_allow_html: true
output:
  bookdown::gitbook:
    css: styles.css
  bookdown::pdf_document2:
    latex_engine: xelatex
  bookdown::pdf_book:
    latex_engine: xelatex
bibliography: [references.bib]
biblio-style: "apalike"
link-citations: true
editor_options: 
  chunk_output_type: console
header-includes:
  - \usepackage{tikz-cd}
---

# Abstract

Interactive data visualization has become a staple of modern data presentation. However, creating rich interactive figures still remains a challenging task. Certain useful and sophisticated interactive features are often absent from existing tools, or are supported to only a limited degree. This implementation gap may stem from a subtle yet profound issue: what we can *do* with a visualization is fundamentally determined by what the visualization *is*. Since graphs are not mere images, but instead visual representations of structured information, interactive features need to be congruent with the mathematical properties of the underlying data. While seemingly self-evident, this idea is at tension with the prevailing practices. Many current systems based on the Grammar of Graphics model aim to treat graphics, statistics, and interaction as independent, modular components, which can be freely combined. I argue that this independence model, despite many appealing properties, is fundamentally flawed; visualization components are not independent, but instead deeply interconnected.

In this thesis, I explore this inherent interconnectedness of figure components, the challenges it poses for interactive visualization systems, and propose a simple model based on some fundamental ideas from category theory. Furthermore, I also present `plotscaper`, an R package developed to both refine these theoretical ideas and offer a practical tool for interactive data exploration. My goal is to demonstrate that, in order to design truly consistent and general interactive data visualization systems, we need to ground our thinking in algebraic concepts. 

```{r}
#| echo: false

knitr::opts_chunk$set(
  fig.align = "center"
)

directory <- tempdir()

get_ts_filepath <- function(x) {
  if (endsWith(x, ".ts")) {
    paste0(directory, "/", trimws(gsub("//", "", x)))
  } else {
    tempfile(tmpdir = directory, fileext = ".ts")
  }
}

# Create a TypeScript knitr engine
knitr::knit_engines$set(ts = function(options) {
  code <- paste0(options$code, collapse = "\n")
  out <- ""
  
  if (options$eval) {
    ts_path <- get_ts_filepath(options$code[1]) 
    ts_conn <- file(ts_path)
    writeLines(code, ts_conn)
    
    out <- paste("~/.bun/bin/bun run", ts_path) |> 
      system(intern = TRUE, ignore.stderr = TRUE)
    
    close(ts_conn)
  }
  
  knitr::engine_output(options, code, out)
})

```

```{r}
#| echo: false

pal_paired_1 <- palette.colors(2, "Paired")
pal_paired_3 <- palette.colors(6, "Paired")[c(1, 2, 5, 6, 3, 4)]
pal_light_3 <- pal_paired_3[1:3]
pal_dark_3 <- pal_paired_3[2 * 1:3]

library(ggplot2)

clean_theme <- theme_bw() +
  theme(
  axis.ticks = element_blank(),
  panel.grid = element_blank()
)

theme_set(clean_theme)
options(width = 60)
```

\newcommand\then{â¨¾}


<!--chapter:end:index.Rmd-->


# Introduction {#introduction}

Placeholder


#### Thesis Overview

<!--chapter:end:introduction.Rmd-->


# Background {#background}

Placeholder


## Brief history of interactive data visualization {#brief-history}
### Static data visualization: From ancient times to the space age
### Early interactive data visualization: By statisticians for statisticians {#early-interactive}
#### Open-source Statistical Computing
#### Common features and limitations of early interactive systems
### Interactive data visualization and the internet: Web-based interactivity {#web-based}
#### D3
#### Plotly and Highcharts
#### Vega and Vega-Lite
#### Common features and limitations of web-based interactive systems
## What even is interactive data visualization? {#what-is-interactive-visualization}
### Interactive vs. interacting with {#interactive-interacting}
### Interactive *enough*? {#interactive-enough}
### Complexity of interactive features {#complexity-of-features}
### Working definition
### Common interactive features {#common-features}
#### Changing size and opacity
#### Zooming and panning
#### Querying
#### Sorting and reordering
#### Parametric interaction
#### Animation and projection
#### Representation switching {#representation-switching}
#### Linked selection {#linked-selection}
## Overview of broader data visualization topics
### Visualization goals {#visualization-goals}
### Visual perception {#visual-perception}
### Scales and measurement {#scales-measurement}
### Graphics formats {#graphics-formats}
#### Raster graphics
#### Vector graphics
## Summary

<!--chapter:end:litreview.Rmd-->


# Challenges {#problems}

Placeholder


## The structure of this chapter: Data visualization pipeline
## Partitioning {#partitioning}
### Showing the full data {#show-all-data}
### Comparison and disjointness {#comparison-disjointness}
#### Naturality of disjointness
#### Disjointness and bijections
#### Disjointness in visualizations: Real-world example
#### Disjointness and interaction {#disjointness-interaction}
### Plots as partitions
#### Bijection on cases vs. bijection on subsets
#### Products of partitions {#products-of-partitions}
#### Limits of flat product partitions
### Partitions, hierarchy, and preorders {#hierarchy}
#### Plots as preorders {#plots-as-preorders}
#### The graph behind the graph
## Aggregation
### The relationship between graphics and statistics
#### Independence: The grammar-based model
#### Motivating example: Limits of independence {#stacking-not-graphical}
#### Some statistics are stackable but others are not {#stackable-or-not}
#### Advantages of stacking: Part-whole relations {#stacking-part-whole}
### Stackable summaries: A brief journey into Category Theory {#aggregation-category-theory}
#### Past applications of category theory to data visualization {#visualization-category-theory}
#### Generalizing preorders: Categories {#preorders-categories}
#### Structure preserving maps: Functors {#structure-functors}
#### Aggregation: A functor from data subsets to summary statistics {#aggregation-functor}
#### Functorial summaries and set union
#### Whole equal to the sum of its parts: Monoids {#monoids}
#### Programming with monoids {#programming-with-monoids}
#### Groups and inverses {#groups-inverses}
#### Other properties: Monotonicity and commutativity {#monotonicity-commutativity}
##### Monotonicity
##### Commutativity
#### Transforming summaries: Stacking, normalizing, and shifting {#transforming-summaries}
##### Stacking
##### Normalizing
##### Shifting
## Scaling and encoding {#scaling}
#### Scales as functions {#scales-as-functions}
#### Limits of modeling scales with simple functions {#simple-scale-limits}
#### Solution: Scales as function composition {#scales-composition}
##### Reusability and discrete scales
##### The intermediate interval {#scaling-intermediate}
##### Implementing scale features via the intermediate interval
###### Margins
###### Panning
###### Zooming
##### Inverses {#scaling-inverses}
##### Scale transformations
#### Comparison to past implementations of scales {#scales-comparison}
## Rendering
### Frames {#frames}
### Geoms
#### Rendering geoms: A functor from summary statistics to graphics {#rendering-functor}
### Auxiliary graphical elements {#auxiliary-elements}
## Summary

<!--chapter:end:problems.Rmd-->


# Goals {#goals}

Placeholder


## User profile
## Programming interface
## User interface
## Interactive features
## Summary

<!--chapter:end:goals.Rmd-->


# System description {#system}

Placeholder


## Core requirements
## High-level API (`plotscaper`) {#high-level-api}
### API design {#api-design}
### Basic example {#basic-example}
#### Figure vs. plot and selectors {#figure-plot}
#### Variable names
#### Variables and encodings {#variables-encodings}
### The scene and the schema {#scene-and-schema}
### Client-server communication {#client-server}
### HTML embedding
## Low-level implementation (`plotscape`) {#low-level-implementation}
### Programming paradigm {#programming-paradigm}
#### Procedural programming
#### Functional programming {#functional}
#### Object-oriented programming {#oop}
#### Data-oriented programming {#dop}
#### Final choice of programming paradigm and rationale
#### Style used in code examples
### Data representation: Row-oriented vs. column-oriented {#row-column}
#### Ease of use
#### Performance {#row-column-performance}
#### Final choice of data representation and rationale
### Reactivity {#reactivity}
#### Observer pattern {#observer}
#### Streams {#streams}
#### Virtual DOM
#### Signals {#signals}
#### Reactivity in `plotscape` and final thoughts {#reactivity-solution}
### System components {#components}
#### Indexable {#Indexable}
#### Getter {#Getter}
#### Dataframe {#dataframe}
#### Factors
##### Bijection and constant factors
##### Discrete factors
##### Binned factors
##### Product factors {#product-factors}
#### Marker
##### Transient vs. persistent selection {#transient-persistent}
##### Group assignment indices {#group-indices}
##### Updating group assignment indices
#### Aggregation: Reducers, reduceds, and summaries {#aggregation-summaries}
##### Reducers {#reducers}
##### Reduced
##### Summaries {#summaries}
#### Scales {#scales}
##### Scale properties
#### Expanses {#expanses}
#### Continuous expanses
#### Point expanses
#### Band expanses
##### Compound and split expanses
#### Plot {#plot}
##### Data {#plot-data}
##### Scales {#plot-scales}
##### Rendering {#plot-rendering}
#### Events and interactive features
##### Activation and deactivation
##### Growing/shrinking objects
##### Mouse-move interaction: selection, panning, and zooming {#plot-mousemove}
####### Selection
####### Panning
####### Querying
#### Zooming
#### Scene {#scene}
##### Plots
##### Marker
##### WebSockets client
##### Events and Keybindings

<!--chapter:end:system.Rmd-->


# Applied example {#applied-example}

Placeholder


### About the data set
### Interactive exploration
#### The relationship between cases and days
#### Number of cases over time
#### Age and child and adolescent mental health
#### Prevalence of diagnoses
#### Prevalence of diagnoses over time
#### Characteristics of patient cohorts over time
## Summary

<!--chapter:end:example.Rmd-->


# Discussion

Placeholder


## Features and limitations of the theoretical model
### Why the model is necessary
### Disjointness
### Associativity and unitality {#associativity-unitality}
### Groups and inverses {#discussion-groups-inverses}
### Additional properties: Monotonicity, commutativity, and others
### Model constraints
### Potential future directions
## Features and limitations of the delivered software
### Scope and features
### Declarative schemas and extensibility {#declarative-schemas}
### Performance {#performance}

<!--chapter:end:discussion.Rmd-->

# Conclusion

This thesis explored algebraic relationships underlying interactive data visualization pipelines. Specifically, it investigated the intricate interplay between data, summary statistics, graphics, and interaction. A recurring central theme has been that what we compute (statistics), how we represent it (graphics), and what we do with it (interaction) are not independent concerns. Instead, for graphics to behave well, particularly under interaction, their components need to exhibit a particular kind of congruence, which can be described via the language of category theory. 

This perspective challenges the presently dominant approach in data visualization. In many popular data visualization packages, graphics and statistics (and interaction) are treated as independent, modular components. However, I believe I have been able to demonstrate that this independence model is insufficient for reasoning about visualizations comprehensively, and can lead to meaningless, "bizarre or degenerate" graphics. By contrast, the model I propose allows us to identify those combinations of graphics and statistics which will be meaningful, by virtue of composition, and those which will be degenerate or bizzare, due to lack thereof. Further, it also allows us to reason about when certain types of interactions, particularly linked selection, will combine with the graphic to produce certain predictable, natural results.

Further, I also tested and refined many of the ideas surrounding the model by developing an original interactive data visualization library for R: `plotscaper`. Beyond theory testing, `plotscaper` was developed to provide a practical tool for data exploration, a goal which appears to have been achieved with moderate success, as evidence by the package's download statistics in the relatively short time interval since its initial release. Developed largely from scratch and with minimal dependencies, the creation of the `plotscaper` necessitated the resolution of numerous fundamental programming issues and architectural concerns. Many of these challenges and their solutions are also documented throughout this thesis, with the goal of providing directions for potential future research and development.

In conclusion, I find the algebraic structure of data visualizations and its relationship to interactivity to be a fascinating topic. I consider myself lucky to have stumbled upon few intriguing ideas that allowed me to see graphics in an entirely new light. Yet, I recognize that the model presented in this thesis is far from exhaustive, and significant opportunities remain for future research. Since the model is built on some simple, foundational concepts from category theory, it is natural to assume that category theory may yield many further, much deeper insights regarding the nature of the relationships between graphics, statistics, and interaction. Nevertheless, I hope it is clear that even these simple ideas provide a powerful tool for reasoning about graphics and even possess a significant applied utility. Ultimately, developing truly generic and robust interactive data visualization systems may require grappling with these ideas further.

<!--chapter:end:conclusion.Rmd-->


# Appendix: Glossary

Placeholder


#### API {#API}
#### JSON {#JSON}
#### GoG
#### IDE
#### SVG

<!--chapter:end:glossary.Rmd-->


# Appendix: Mathematical theory

Placeholder


#### Relations {#relations}
#### Functions {#functions}
##### More on bijections {#bijections}
##### Composition
##### The image and the pre-image
#### Partitions {#partitions}
#### Preorders {#preorders}
##### Specializing preorders
##### Structure preserving maps: Monotone maps
#### Monoids
#### Simple examples of monoids
##### Beyond numbers
#### Specializing monoids
##### Structure preserving maps: Monoid homomorphisms {#monoid-homomorphism}
#### Groups
##### Simple examples of groups
##### Structure preserving maps: Group homomorphisms {#group-homomorphism}
#### Categories {#categories}
##### Isomorphisms within categories {#isomorphism}
##### Algebraic structures described as categories {#algebraic-as-categories}
#### Functors {#functors}

<!--chapter:end:math.Rmd-->

# References


<!--chapter:end:references.Rmd-->

