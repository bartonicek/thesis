# High-level design

This section contains a description of some of the high-level design decisions that went into making the system.

```{r}
#| echo: false
plot <- function(..., pch = 19, col = "grey80", cex = 2) {
  base::plot(..., col = col, pch = pch, cex = cex, xaxt = 'n', yaxt = 'n')
  axis(1, tick = FALSE)
  axis(2, tick = FALSE, las = 1)
}

```

> The example code chunks in this section are written in both R and TypeScript. While I would prefer to use R for all code examples, due to its tight integration with RMarkdown, some of the concepts are much easier to explain in a language with static typing like TypeScript (particularly, type annotations and interfaces). However, since some examples can also be greatly enhanced by graphical output, I also wanted to use R. 
>
> So, where graphical output is important, the code examples are written in R, and, where the code itself is the main focus, they are written in TypeScript. I hope this bilingualism is not too confusing. I have tried to use only the core features of each language to make the examples clear. 


### User profile

The profile of average user can also differ significantly, across systems and research areas. For example, some areas of interactive data visualization and HCI make no assumptions about the user's level of experience or motivation, whereas others assume a highly motivated "expert" user with a sufficient level of domain knowledge [@dimara2019].

While designing my system, I have attempted to 

## Programming paradigm

> "apex predator of grug is complexity
>
> complexity bad
>
> say again:
>
> complexity very bad
>
> you say now:
>
> complexity very, very bad
>
> given choice between complexity or one on one against t-rex, grug take t-rex: at least grug see t-rex" 
>
> The Grug Brained Developer, @gross2024


It is often the case that the same task problem can be tackled in many different ways. Programs differ in how they decompose their core problem, how they represent and manipulate data, how explicit they are in handling low-level details versus relying on abstractions, and so on. These details matter since they can affect the program's performance, reliability, readability, and maintainability. A wrong choice in one or more of them can result in poorly performing, unmaintainable software.   

However, there is a root concern that many of the programming details above share: complexity [@booch2008]. Any given problem comes with some level inherent complexity, and, absent of careful thought, more will be piled on by the developer [@moseley2006]. Without constant effort, software grows out of scope and becomes unmanageable. Preventing this, and coming up with a set of high-level principles for safeguarding against complexity is the job of programming paradigms [@chambers2014; @jordan2015; @moseley2006; @van2009].

All programming paradigms offer techniques for decomposing code into smaller, more manageable parts, and delineating boundaries between those parts. However, the way they attempt this can differ considerably. 

Most programming languages are geared towards one specific programming paradigm, and typically support only one or two to a reasonable capacity [@van2009]. Fortunately, this is not the case for either JavaScript/TypeScript or R, since both are multiparadigm programming languages [@chambers2014; @mdn2024c]. Both languages support object-oriented programming, via prototype inheritance in the case of JavaScript [@mdn2024d] and the S3, S4, and R6 systems in the case of R [@wickham2019], and treat functions as first class citizens, allowing for functional programming style [@chambers2014; @mdn2024e]. Further, as C based languages, both also support classical imperative/procedural programming style, and also provide some utilities for reflective metaprogramming.  

The flexibility of JavaScript and R had allowed me to experiment with different programming paradigms while developing my interactive data visualization package. I have rewritten the JavaScript side of the package multiple times from scratch, testing out several different programming paradigms and styles in the process. Below, I provide a rough sketch of the paradigms I have sampled, as well as an account of my experience of using each paradigm and some thoughts on its suitability for designing interactive data visualization systems.

### Imperative programming

Imperative programming is one of the oldest and most classical programming paradigms. It conceptualizes the program as a sequence of discrete steps that manipulate some mutable state [@frame2014]. In this way, it closely resembles the way computer programs get executed on the underlying hardware [barring some advanced techniques such as branch prediction and speculative execution, the CPU executes instructions sequentially, see e.g. @parihar2015; @raghavan1998].

### Functional programming

### Object oriented programming

Object oriented programming (OOP) is currently one of the most popular programming paradigms. There are many different interpretation and implementations of OOP, so almost anything one can say about OOP will be wrong in some language. Nevertheless, there are some key ideas which are generally true across most OOP-oriented languages.  

The core idea of OOP is that programs should be modeled as networks of objects: units which bundle related data and code together, as properties (members) and methods, respectively [@booch2008]. Objects are self-contained, and own a hidden, private state; they expose only a limited public interface and, to communicate, they send each other messages [@meyer1997]. In this way, they behave similarly to networks of biological cells [this was the inspiration for Alan Kay, one of the creators of Smalltalk, who also coined the term "object oriented", @kay1996]. Each object is an instance of a class, a sort of a blueprint which provides the object with both a type as well as implementation of its methods. Classes can form hierarchies, where child classes (subclasses) inherit properties and methods from parent classes (superclasses). 

Here's a typical example one might see in a text-book on OOP (animals, and especially mammals are popular in introductory OOP texts). We start with a base class (superclass) `Animal`:

```{ts}
// Animal.ts
type Food = { nutritionalValue: number };

// Abstract classes can declare certain methods without implementing them.
// Any subclasses must then implement these methods.
export abstract class Animal {
  x = 0; // Class properties with default values
  y = 0;
  nutrition = 100;

  move(dx: number, dy: number) { // A basic method
    this.x += dx;
    this.y += dy;
  }

  eat(food: Food) {
    this.nutrition += food.nutritionalValue;
  }

  // Abstract method: subclass must implement this (every Animal has a sound)
  abstract getSound(): string;
}
```
 
Next, we subclass the `Animal` class and create a `Dog` class:

```{ts}
import { Animal } from "./Animal.ts"

type Meat = { type: `meat`; nutritionalValue: number };

class Dog extends Animal {
  eat(food: Meat) { // Overwrite superclass method such that it only accepts Meat
    super.eat(food); // Call superclass method
  }

  getSound() { // Implement the abstract method
    return `Woof!`;
  }
}

const dog = new Dog();

dog.move(-10, 10); // Dog inherits all of the methods and properties of Animal
dog.eat({ type: `meat`, nutritionalValue: 10 }); // This is fine
// dog.eat({ nutritionalValue: 10 }); This would result in a TS compiler error

console.log(dog.x, dog.y, dog.nutrition)
console.log(dog.getSound());
```

This is only a very basic example of how OOP can be done in practice. A more detailed explanation is outside of the scope of the present thesis. However, it is important to discuss some of the big ideas of OOP. 

#### Encapsulation

Encapsulation or information hiding refers to the idea that some (if not most) properties of a class should not be accessible from the outside. Encapsulation is generally seen as one of the most important concepts in OOP, since it allows for continuity: by encapsulating data/functionality, the developer of an OOP system may modify these private properties without affecting the public interface [@meyer1997]. Note that the encapsulation does not mean that the hidden data or implementation has to be entirely *invisible* to the user, merely that the user should not be able to access the hidden data and rely on it in their application [@meyer1997].  

#### Open-closed principle

Modules should be open to extension but close to modification.

#### Polymorphism

In other words, only the behavior of the object should matter [@black2013].

#### Inheritance

"programming without inheritance is distinctly not object-oriented; that would merely be programming with abstract data types" [@booch2008].


#### Domain-driven design

One concept that is not unique to OOP but has a strong tradition in it is domain-drive design: the idea that classes and object should model things in the business domain or the real world [@hadar2013; @meyer1997]. The stated benefit of this strategy is that this makes it easier to discover objects/classes and their relationships, by exploiting the mind's capacity for thinking about the natural world [@booch2008; @hadar2013; @meyer1997]. 

#### Criticism of OOP

Small interfaces [@meyer1997]. In practice, the small interfaces idea is often not closely adhered to in OOP. It is common for class methods to receive pointers to other objects as arguments, effectively sending all of the information contained in the argument objects and defeating the principle of small interfaces [@will2016].

### Data oriented programming

> My second remark is that our intellectual powers are rather geared to master static relations and that our powers to visualize processes evolving in time are relatively poorly developed. For that reason we should do (as wise programmers aware of our limitations) our utmost to shorten the conceptual gap between the static program and the dynamic process, to make the correspondence between the program (spread out in text space) and the process (spread out in time) as trivial as possible.
>
> Edgar Dijkstra -@dijkstra1968

Data oriented programming (DOP) and data oriented design (DOD) are two newer programming paradigms that have been slowly gaining a foothold in the recent years. While the terms are sometimes used interchangeably, there are some important differences: DOP focuses more on high-level principles such as structuring and organizing code [@sharvit2022; @parlog2024], whereas DOD, having originated in the world of video-game development, tends to be more concerned with low-level optimization details such as memory layout and CPU access patterns [@acton2014; @bayliss2022; @kelley2023; @nikolov2018; @fabian2018]. However, there is a considerable overlap the conclusions and high-level guidelines that the two programming paradigms provide. For this reason, I will discuss both DOP and DOD here, within the same section, and refer to both as "DOP" unless explicitly stated otherwise. 

The core idea of DOP is a data-first perspective. In the DOP view, programs should be viewed as transformations of data, nothing less, nothing more [@acton2014; @fabian2018; @sharvit2022]. As a result, every program is composed of two sets of components: stateful data and stateless functions that act on and transform this data [@fabian2018]. In other words, data and code should always be kept separate, such that both can be reasoned about in isolation. Code should live inside modules composed of pure (stateless) functions [@fabian2018; @sharvit2022]. This strict segregation brings several benefits. The data becomes easy to pass around and serialize, and, since the code is composed of pure functions, it becomes easy to test and mock [@sharvit2022]. 

Program is split between what *is* and what *does*.

Data should be represented by plain data structures. These can formed by combining generic components, such as primitives, arrays, and maps/dictionaries/structs [for example [JSON]\; @sharvit2022]. It may even be desirable that the data adheres to the relational model [@codd1970; @moseley2006; @fabian2018]. This does not mean that the data has to actually *live* inside a relational database, just that its shape should be close to that of normalized relational database tables, with columns represented by generic arrays [@fabian2018]. 

Data represents just itself - data - and there is no obligation for it to model the real world or any kind of abstract entity. As a result, and we are free to represent data in any way we want, and this can in fact bring significant performance benefits [@acton2014; @fabian2018]. A typical example of this in DOD is the Structure of Arrays (SoA; aka "parallel arrays" or "columnar format") data structure [@acton2014; @acton2019; @kelley2023], in which a list of records is stored as a single object, with the records' properties being stored as homogeneous arrays (this is also how R's `data.frame` class is implemented). This type of representation reduces memory footprint and can improve cache line utilization, resulting in faster runtime [@acton2014; @fabian2018; @kelley2023]. Another example of idiosyncratic data representation that can lead to improved performance are Entity Component Systems in videogames [@harkonen2019]. Either way, even if performance is not the nubmer one concern, another benefit data representing itself is that it allows us introduce abstraction only gradually, since we can get far by relying on generic data manipulation functions [@fabian2018; @sharvit2022].

It may seem that many of the DOP principles directly contradict many popular OOP principles, specifically encapsulation, inheritance, polymorphism, and domain driven design. However, many of these principles can either be reconciled with DOP, or DOP in fact provides better alternatives. Below, I go over these principles and provide code examples that further illustrate how DOP works. 

##### Encapsulation

When it comes to encapsulation in DOP, we have to differentiate between encapsulating data and encapsulating code. Encapsulating code is easy in DOP - we can simply not export certain functions from the code modules. We are then free to modify the signature of these functions without affecting the public interface [@fabian2018]. Encapsulating data may require a bit more work. Depending on the language, generic data structures may not have property access modifiers [although there does seem to be a trend in recent languages to support property access modifiers more generically, see e.g. @rust2024; @zig2024]. For instance, in JavaScript, private properties can only be declared as part of a class declaration [@mdn2024e]. However, in most languages, it is still possible to use other language features and metaprogramming to achieve data encapsulation - for example, in JavaScript, we can use the Proxy class to emulate private property access ([see Appendix](#dop-encapsulation)).

Thus, encapsulation of data is certainly possible in DOP. However, a question still remains whether it is a good idea. While in OOP, encapsulation is generally seen as a net positive, in DOP it is thought to come with trade-offs. It does provide an additional layer of security, however, it also makes systems more complex and harder to debug [@fabian2018; @sharvit2022]. And, even with full encapsulation, users may still come to rely on hidden features of the system [@fabian2018]. Ultimately, it is necessary to weigh the pros and cons of encapsulating data within the context of the specific use-case.

Some languages also have features which allow for a weak form encapsulation which is compatible with DOP. In JavaScript, this can be implemented by using symbol keys for object properties [@mdn2024f]. Symbols are builtin primitive in JavaScript and are guaranteed to be unique. If we assign a property to an object using an unexported symbol as the key, the user will still be able to inspect the object and see the property, however, they will not be able to access it without using reflection. This is actually in line with the data hiding concept as laid out by @meyer1997.  

I actually found this form a weak encapsulation a good fit for `plotscape`. For example, here is how I implemented the `Meta` mixin which allows use to store arbitrary metadata on objects:

```{ts}
// Meta.ts
const METADATA = Symbol("metadata");
type METADATA = typeof METADATA;

export interface Meta<T extends Record<string, any> = any> {
  [METADATA]: T;
}

export namespace Meta {
  export function of<T extends Object>(object: T) {
    return { ...object, [METADATA]: {} };
  }

  export function get<T extends Meta>(object: T, key: keyof T[METADATA]) {
    return object[METADATA][key];
  }

  export function set<T extends Meta, K extends keyof T[METADATA]>(
    object: T,
    key: K,
    value: T[METADATA][K]
  ) {
    object[METADATA][key] = value;
  }
}
```

Now we can import the module and use it to add secret metadata to arbitrary data objects:

```{ts}
import { Meta } from "./Meta.ts"

interface User extends Meta<{ id: number }> {
  name: string;
}

const user: User = Meta.of({ name: "Adam" });
Meta.set(user, `id`, 1337);
console.log(user)
console.log(Meta.get(user, `id`));
```

We can now use the `Meta` module internally, and, if we do not export the module or the `METADATA` symbol, then the user will not be able to access those properties easily. The user can still inspect the object and see the associated metadata, however, they cannot access it without the symbol. They may still be able to retrieve the symbol using the via the `Reflect.ownKeys` and `Object.getOwnPropertySymbols` functions, and so this is not a strong form of encapsulation [@mdn2024f]. However, arguably, if the user goes this far as to retrive the symbol, and, assuming we are not storing any sensitive data (which is not the case in `plotscape`), it may be reasonable to allow them to access these "private" properties and suffer the consequences.  

##### Inheritance

In OOP, the primary mechanism for code reuse is inheritance.

In DOP, since data is generic and separate from behavior, we can call functions from any module as long as the data we provide it as arguments adheres to the module's interface. This makes code reuse trivial. For example, here's a simplified version of the `Reactive` interface (Observer pattern) from `plotscape`:
 
```{ts}

const LISTENERS = Symbol(`listeners`); // A unique symbol, to avoid namespace clashes
type Dict = Record<string, any>; // Generic dictionary type
type Callback = (data: Dict) => void; // Generic callback function type

interface Reactive {
  [LISTENERS]: Record<string, Callback[]>;
}

namespace Reactive {
  export function of<T extends Object>(object: T): T & Reactive {
    return { ...object, [LISTENERS]: {} };
  }

  export function listen(object: Reactive, event: string, cb: Callback) {
    if (!object[LISTENERS][event]) object[LISTENERS][event] = [];
    object[LISTENERS][event].push(cb);
  }

  export function dispatch(object: Reactive, event: string, data: Dict) {
    for (const cb of object[LISTENERS][event] ?? []) cb(data);
  }
}

interface Dog extends Reactive {
  name: string
}

namespace Dog {
  export function of(name: string) {
    return Reactive.of({ name })
  }
}

const dog = Dog.of(`Terry`)
Reactive.listen(dog, `car goes by`, () => console.log(`Woof!`))
Reactive.dispatch(dog, `car goes by`)
```


